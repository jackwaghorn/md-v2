import { createClient, predicate, cookie } from '@prismicio/client';
import { isFilled, asImageWidthSrcSet, asImagePixelDensitySrcSet, asImageSrc, asLink, asText, asHTML, asDate, documentToLinkField } from '@prismicio/helpers';
import { resolveDynamicComponent, defineComponent, h, inject, computed, unref, reactive, ref, watch, nextTick, onBeforeUnmount, watchEffect, markRaw, shallowRef, isRef } from 'vue';
import { routerKey } from 'vue-router';

const simplyResolveComponent = (component) => {
  return resolveDynamicComponent(component);
};

const defaultWrapper$2 = "div";
const PrismicEmbedImpl = /* @__PURE__ */ defineComponent({
  name: "PrismicEmbed",
  props: {
    field: {
      type: Object,
      required: true
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    }
  },
  setup(props) {
    if (!props.field) {
      return () => null;
    }
    return () => {
      return h(simplyResolveComponent(props.wrapper || defaultWrapper$2), {
        "data-oembed": props.field.embed_url,
        "data-oembed-type": props.field.type,
        "data-oembed-provider": props.field.provider_name,
        innerHTML: props.field.html || null
      });
    };
  }
});
const PrismicEmbed = PrismicEmbedImpl;

if (typeof process === "undefined") {
  globalThis.process = { env: {} };
}
const __PRODUCTION__ = process.env.NODE_ENV === "production";

const prismicKey = Symbol("prismic");

const usePrismic = () => {
  return inject(prismicKey, { options: { endpoint: "" } });
};

const defaultImageComponent = "img";
const usePrismicImage = (props) => {
  const { options } = usePrismic();
  const asImage = computed(() => {
    var _a, _b;
    const field = unref(props.field);
    if (!isFilled.image(field)) {
      return {
        src: null,
        srcset: null
      };
    }
    const imgixParams = unref(props.imgixParams);
    const widths = unref(props.widths);
    const pixelDensities = unref(props.pixelDensities);
    if (widths) {
      if (!__PRODUCTION__ && pixelDensities) {
        console.warn(
          "[PrismicImage] Only one of `widths` or `pixelDensities` props can be provided. You can resolve this warning by removing either the `widths` or `pixelDensities` prop. `widths` will be used in this case.",
          props
        );
      }
      return asImageWidthSrcSet(field, {
        ...imgixParams,
        widths: widths === "defaults" ? (_a = options.components) == null ? void 0 : _a.imageWidthSrcSetDefaults : widths
      });
    } else if (pixelDensities) {
      return asImagePixelDensitySrcSet(field, {
        ...imgixParams,
        pixelDensities: pixelDensities === "defaults" ? (_b = options.components) == null ? void 0 : _b.imagePixelDensitySrcSetDefaults : pixelDensities
      });
    } else {
      return {
        src: asImageSrc(field, imgixParams),
        srcset: null
      };
    }
  });
  const src = computed(() => {
    return asImage.value.src;
  });
  const srcset = computed(() => {
    return asImage.value.srcset;
  });
  const alt = computed(() => {
    return unref(props.field).alt || "";
  });
  const copyright = computed(() => {
    return unref(props.field).copyright || null;
  });
  return {
    src,
    srcset,
    alt,
    copyright
  };
};
const PrismicImageImpl = /* @__PURE__ */ defineComponent({
  name: "PrismicImage",
  props: {
    field: {
      type: Object,
      required: true
    },
    imageComponent: {
      type: [String, Object],
      default: void 0,
      required: false
    },
    imgixParams: {
      type: Object,
      default: void 0,
      required: false
    },
    widths: {
      type: [String, Object],
      default: void 0,
      required: false
    },
    pixelDensities: {
      type: [String, Object],
      default: void 0,
      required: false
    }
  },
  setup(props) {
    if (!props.field) {
      return () => null;
    }
    const { options } = usePrismic();
    const type = computed(() => {
      var _a;
      return props.imageComponent || ((_a = options.components) == null ? void 0 : _a.imageComponent) || defaultImageComponent;
    });
    const { src, srcset, alt, copyright } = usePrismicImage(props);
    return () => {
      const attributes = {
        src: src.value,
        srcset: srcset.value,
        alt: alt.value
      };
      switch (type.value) {
        case "img":
          return h("img", attributes);
        default:
          return h(simplyResolveComponent(type.value), {
            ...attributes,
            copyright: copyright.value
          });
      }
    };
  }
});
const PrismicImage = PrismicImageImpl;

const isInternalURL = (url) => {
  const isInternal = /^\/(?!\/)/.test(url);
  const isSpecialLink = !isInternal && !/^https?:\/\//i.test(url);
  return isInternal && !isSpecialLink;
};

const getSlots = (parent, slots, defaultPayload) => {
  if (typeof parent === "string") {
    return slots.default && slots.default(defaultPayload);
  } else {
    if (slots.default) {
      const content = slots.default(defaultPayload);
      return {
        ...slots,
        default: () => content
      };
    } else {
      return slots;
    }
  }
};

const defaultInternalComponent = "router-link";
const defaultExternalComponent = "a";
const defaultBlankTargetRelAttribute = "noopener noreferrer";
const usePrismicLink = (props) => {
  const { options } = usePrismic();
  const type = computed(() => {
    var _a, _b;
    const internalComponent = unref(props.internalComponent) || ((_a = options.components) == null ? void 0 : _a.linkInternalComponent) || defaultInternalComponent;
    const externalComponent = unref(props.externalComponent) || ((_b = options.components) == null ? void 0 : _b.linkExternalComponent) || defaultExternalComponent;
    return href.value && isInternalURL(href.value) && !target.value ? internalComponent : externalComponent;
  });
  const href = computed(() => {
    var _a, _b;
    const field = unref(props.field);
    const linkResolver = (_a = unref(props.linkResolver)) != null ? _a : options.linkResolver;
    return (_b = asLink(field, linkResolver)) != null ? _b : "";
  });
  const target = computed(() => {
    const field = unref(props.field);
    const target2 = unref(props.target);
    if (typeof target2 !== "undefined") {
      return target2;
    } else {
      return field && "target" in field && field.target ? field.target : null;
    }
  });
  const rel = computed(() => {
    var _a;
    const rel2 = unref(props.rel);
    if (typeof rel2 !== "undefined") {
      return rel2;
    } else if (target.value === "_blank") {
      const blankTargetRelAttribute = unref(props.blankTargetRelAttribute);
      if (typeof blankTargetRelAttribute !== "undefined") {
        return blankTargetRelAttribute;
      } else {
        return typeof ((_a = options.components) == null ? void 0 : _a.linkBlankTargetRelAttribute) !== "undefined" ? options.components.linkBlankTargetRelAttribute : defaultBlankTargetRelAttribute;
      }
    } else {
      return null;
    }
  });
  return {
    type,
    href,
    target,
    rel
  };
};
const PrismicLinkImpl = /* @__PURE__ */ defineComponent({
  name: "PrismicLink",
  props: {
    field: {
      type: Object,
      required: true
    },
    linkResolver: {
      type: Function,
      default: void 0,
      required: false
    },
    target: {
      type: String,
      default: void 0,
      required: false
    },
    rel: {
      type: String,
      default: void 0,
      required: false
    },
    blankTargetRelAttribute: {
      type: String,
      default: void 0,
      required: false
    },
    internalComponent: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    },
    externalComponent: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    }
  },
  setup(props, { slots }) {
    if (!props.field) {
      return () => null;
    }
    const { type, href, target, rel } = usePrismicLink(props);
    return () => {
      const parent = type.value === "a" ? "a" : simplyResolveComponent(type.value);
      const computedSlots = getSlots(
        parent,
        slots,
        reactive({ href: href.value })
      );
      if (typeof parent === "string") {
        return h(
          parent,
          { href: href.value, target: target.value, rel: rel.value },
          computedSlots
        );
      } else {
        return h(parent, { to: href.value }, computedSlots);
      }
    };
  }
});
const PrismicLink = PrismicLinkImpl;

const defaultWrapper$1 = "div";
const usePrismicText = (props) => {
  const text = computed(() => {
    var _a;
    const field = unref(props.field);
    if (!isFilled.richText(field)) {
      return (_a = unref(props.fallback)) != null ? _a : "";
    }
    return asText(unref(field), unref(props.separator));
  });
  return {
    text
  };
};
const PrismicTextImpl = /* @__PURE__ */ defineComponent({
  name: "PrismicText",
  props: {
    field: {
      type: Array,
      default: void 0,
      required: false
    },
    separator: {
      type: String,
      default: void 0,
      required: false
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    },
    fallback: {
      type: String,
      default: void 0,
      required: false
    }
  },
  setup(props) {
    const { text } = usePrismicText(props);
    return () => {
      const parent = simplyResolveComponent(props.wrapper || defaultWrapper$1);
      return h(parent, null, {
        default: () => text.value
      });
    };
  }
});
const PrismicText = PrismicTextImpl;

const defaultWrapper = "div";
const usePrismicRichText = (props) => {
  const { options } = usePrismic();
  const html = computed(() => {
    var _a, _b, _c;
    const field = unref(props.field);
    if (!isFilled.richText(field)) {
      return (_a = unref(props.fallback)) != null ? _a : "";
    }
    const linkResolver = (_b = unref(props.linkResolver)) != null ? _b : options.linkResolver;
    const htmlSerializer = (_c = unref(props.htmlSerializer)) != null ? _c : options.htmlSerializer;
    return asHTML(unref(field), linkResolver, htmlSerializer);
  });
  return {
    html
  };
};
const PrismicRichTextImpl = /* @__PURE__ */ defineComponent({
  name: "PrismicRichText",
  props: {
    field: {
      type: Array,
      default: void 0,
      required: false
    },
    linkResolver: {
      type: Function,
      default: void 0,
      required: false
    },
    htmlSerializer: {
      type: [Function, Object],
      default: void 0,
      required: false
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    },
    fallback: {
      type: String,
      default: void 0,
      required: false
    }
  },
  setup(props) {
    const { html } = usePrismicRichText(props);
    const root = ref(null);
    const maybeRouter = inject(routerKey, null);
    if (maybeRouter) {
      let links = [];
      const navigate = function(event) {
        event.preventDefault();
        maybeRouter.push(this.href);
      };
      const addListeners = () => {
        const node = root.value && "$el" in root.value ? root.value.$el : root.value;
        if (node && "querySelectorAll" in node) {
          links = Array.from(node.querySelectorAll("a")).map((element) => {
            const href = element.getAttribute("href");
            if (href && isInternalURL(href)) {
              const listener = navigate.bind({ href });
              element.addEventListener("click", listener);
              return { element, listener };
            } else {
              return false;
            }
          }).filter((link) => link);
        }
      };
      const removeListeners = () => {
        links.forEach(
          ({ element, listener }) => element.removeEventListener("click", listener)
        );
        links = [];
      };
      watch(
        html,
        () => {
          removeListeners();
          nextTick(addListeners);
        },
        { immediate: true }
      );
      onBeforeUnmount(() => {
        removeListeners();
      });
    }
    return () => {
      return h(simplyResolveComponent(props.wrapper || defaultWrapper), {
        innerHTML: html.value,
        ref: root
      });
    };
  }
});
const PrismicRichText = PrismicRichTextImpl;

const getSliceComponentProps = (propsHint) => ({
  slice: {
    type: Object,
    required: true
  },
  index: {
    type: Number,
    required: true
  },
  slices: {
    type: Array,
    required: true
  },
  context: {
    type: null,
    required: true
  }
});
const TODOSliceComponent = __PRODUCTION__ ? () => null : /* @__PURE__ */ defineComponent({
  name: "TODOSliceComponent",
  props: getSliceComponentProps(),
  setup(props) {
    const type = computed(
      () => "slice_type" in props.slice ? props.slice.slice_type : props.slice.type
    );
    watchEffect(() => {
      console.warn(
        `[SliceZone] Could not find a component for Slice type "${type.value}"`,
        props.slice
      );
    });
    return () => {
      return h(
        "section",
        {
          "data-slice-zone-todo-component": "",
          "data-slice-type": type.value
        },
        [`Could not find a component for Slice type "${type.value}"`]
      );
    };
  }
});
const defineSliceZoneComponents = (components) => {
  const result = {};
  let type;
  for (type in components) {
    const component = components[type];
    result[type] = typeof component === "string" ? component : markRaw(
      component
    );
  }
  return result;
};
const SliceZoneImpl = /* @__PURE__ */ defineComponent({
  name: "SliceZone",
  props: {
    slices: {
      type: Array,
      required: true
    },
    components: {
      type: Object,
      default: void 0,
      required: false
    },
    resolver: {
      type: Function,
      default: void 0,
      required: false
    },
    context: {
      type: null,
      default: void 0,
      required: false
    },
    defaultComponent: {
      type: Object,
      default: void 0,
      required: false
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    }
  },
  setup(props) {
    if (!props.slices) {
      return () => null;
    }
    const { options } = usePrismic();
    const renderedSlices = computed(() => {
      return props.slices.map((slice, index) => {
        var _a;
        const type = "slice_type" in slice ? slice.slice_type : slice.type;
        let component = props.components && type in props.components ? props.components[type] : props.defaultComponent || ((_a = options.components) == null ? void 0 : _a.sliceZoneDefaultComponent) || TODOSliceComponent;
        if (props.resolver) {
          const resolvedComponent = props.resolver({
            slice,
            sliceName: type,
            i: index
          });
          if (resolvedComponent) {
            component = resolvedComponent;
          }
        }
        const key = "id" in slice && slice.id ? slice.id : `${index}-${JSON.stringify(slice)}`;
        const p = {
          key,
          slice,
          index,
          context: props.context,
          slices: props.slices
        };
        return h(simplyResolveComponent(component), p);
      });
    });
    return () => {
      if (props.wrapper) {
        const parent = simplyResolveComponent(props.wrapper);
        if (typeof parent === "string") {
          return h(parent, null, renderedSlices.value);
        } else {
          return h(parent, null, { default: () => renderedSlices.value });
        }
      } else {
        return renderedSlices.value;
      }
    };
  }
});
const SliceZone = SliceZoneImpl;

const createPrismic = (options) => {
  let client;
  if (options.client) {
    client = options.client;
  } else {
    client = createClient(options.endpoint, {
      fetch: async (endpoint, options2) => {
        let fetchFunction;
        if (typeof globalThis.fetch === "function") {
          fetchFunction = globalThis.fetch;
        } else {
          fetchFunction = (await import('isomorphic-unfetch')).default;
        }
        return await fetchFunction(endpoint, options2);
      },
      ...options.clientConfig
    });
  }
  const prismicClient = {
    client,
    predicate,
    cookie
  };
  const prismicHelpers = {
    asText,
    asHTML: (richTextField, linkResolver, htmlSerializer) => {
      return asHTML(
        richTextField,
        linkResolver || options.linkResolver,
        htmlSerializer || options.htmlSerializer
      );
    },
    asLink: (linkField, linkResolver) => {
      return asLink(linkField, linkResolver || options.linkResolver);
    },
    asDate,
    asImageSrc,
    asImageWidthSrcSet,
    asImagePixelDensitySrcSet,
    documentToLinkField
  };
  const prismic = {
    options,
    ...prismicClient,
    ...prismicHelpers,
    install(app) {
      app.provide(prismicKey, this);
      app.config.globalProperties.$prismic = this;
      if (options.injectComponents !== false) {
        app.component(PrismicLink.name, PrismicLink);
        app.component(PrismicEmbed.name, PrismicEmbed);
        app.component(PrismicImage.name, PrismicImage);
        app.component(PrismicText.name, PrismicText);
        app.component(PrismicRichText.name, PrismicRichText);
        app.component(SliceZone.name, SliceZone);
      }
    }
  };
  return prismic;
};

var PrismicClientComposableState = /* @__PURE__ */ ((PrismicClientComposableState2) => {
  PrismicClientComposableState2["Idle"] = "idle";
  PrismicClientComposableState2["Pending"] = "pending";
  PrismicClientComposableState2["Success"] = "success";
  PrismicClientComposableState2["Error"] = "error";
  return PrismicClientComposableState2;
})(PrismicClientComposableState || {});

const isParams = (value) => {
  return typeof value === "object" && value !== null && !Array.isArray(value);
};
const useStatefulPrismicClientMethod = (methodName, args) => {
  const { client } = usePrismic();
  const state = ref(
    PrismicClientComposableState.Idle
  );
  const data = shallowRef(null);
  const error = ref(null);
  const refresh = async () => {
    const lastArg = unref(args[args.length - 1]);
    const { client: explicitClient, ...params } = isParams(lastArg) ? lastArg : {};
    const argsWithoutParams = isParams(lastArg) ? args.slice(0, -1) : args;
    state.value = PrismicClientComposableState.Pending;
    data.value = null;
    error.value = null;
    try {
      data.value = await (unref(explicitClient) || client)[methodName](
        ...argsWithoutParams.map((arg) => unref(arg)),
        params
      );
      state.value = PrismicClientComposableState.Success;
    } catch (err) {
      state.value = PrismicClientComposableState.Error;
      error.value = err;
    }
  };
  const refArgs = args.filter((arg) => isRef(arg));
  if (refArgs.length) {
    watch(refArgs, refresh, { deep: true });
  }
  refresh();
  return { state, data, error, refresh };
};

const usePrismicDocuments = (...args) => useStatefulPrismicClientMethod("get", args);
const useFirstPrismicDocument = (...args) => useStatefulPrismicClientMethod("getFirst", args);
const usePrismicDocumentByID = (...args) => useStatefulPrismicClientMethod("getByID", args);
const usePrismicDocumentsByIDs = (...args) => useStatefulPrismicClientMethod("getByIDs", args);
const useAllPrismicDocumentsByIDs = (...args) => useStatefulPrismicClientMethod("getAllByIDs", args);
const usePrismicDocumentByUID = (...args) => useStatefulPrismicClientMethod("getByUID", args);
const usePrismicDocumentsByUIDs = (...args) => useStatefulPrismicClientMethod("getByUIDs", args);
const useAllPrismicDocumentsByUIDs = (...args) => useStatefulPrismicClientMethod("getAllByUIDs", args);
const useSinglePrismicDocument = (...args) => useStatefulPrismicClientMethod("getSingle", args);
const usePrismicDocumentsByType = (...args) => useStatefulPrismicClientMethod("getByType", args);
const useAllPrismicDocumentsByType = (...args) => useStatefulPrismicClientMethod("getAllByType", args);
const usePrismicDocumentsByTag = (...args) => useStatefulPrismicClientMethod("getByTag", args);
const useAllPrismicDocumentsByTag = (...args) => useStatefulPrismicClientMethod("getAllByTag", args);
const usePrismicDocumentsByEveryTag = (...args) => useStatefulPrismicClientMethod("getByEveryTag", args);
const useAllPrismicDocumentsByEveryTag = (...args) => useStatefulPrismicClientMethod("getAllByEveryTag", args);
const usePrismicDocumentsBySomeTags = (...args) => useStatefulPrismicClientMethod("getBySomeTags", args);
const useAllPrismicDocumentsBySomeTags = (...args) => useStatefulPrismicClientMethod("getAllBySomeTags", args);
const dangerouslyUseAllPrismicDocuments = (...args) => useStatefulPrismicClientMethod("dangerouslyGetAll", args);

export { PrismicClientComposableState, PrismicEmbed, PrismicImage, PrismicLink, PrismicRichText, PrismicText, SliceZone, TODOSliceComponent, createPrismic, dangerouslyUseAllPrismicDocuments, defineSliceZoneComponents, getSliceComponentProps, prismicKey, useAllPrismicDocumentsByEveryTag, useAllPrismicDocumentsByIDs, useAllPrismicDocumentsBySomeTags, useAllPrismicDocumentsByTag, useAllPrismicDocumentsByType, useAllPrismicDocumentsByUIDs, useFirstPrismicDocument, usePrismic, usePrismicDocumentByID, usePrismicDocumentByUID, usePrismicDocuments, usePrismicDocumentsByEveryTag, usePrismicDocumentsByIDs, usePrismicDocumentsBySomeTags, usePrismicDocumentsByTag, usePrismicDocumentsByType, usePrismicDocumentsByUIDs, usePrismicImage, usePrismicLink, usePrismicRichText, usePrismicText, useSinglePrismicDocument };
//# sourceMappingURL=index.js.map
