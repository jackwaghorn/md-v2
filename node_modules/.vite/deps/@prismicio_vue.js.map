{
  "version": 3,
  "sources": ["../../escape-html/index.js", "../../@prismicio/types/src/value/richText.ts", "../../@prismicio/types/src/value/link.ts", "../../@prismicio/types/src/value/embed.ts", "../../@prismicio/types/src/model/types.ts", "../../@prismicio/types/src/model/link.ts", "../../@prismicio/types/src/model/sliceZone.ts", "../../@prismicio/types/src/model/slice.ts", "../../@prismicio/types/src/webhook/types.ts", "../../@prismicio/richtext/src/asTree.ts", "../../@prismicio/richtext/src/asText.ts", "../../@prismicio/richtext/src/serialize.ts", "../../@prismicio/richtext/src/types.ts", "../../@prismicio/richtext/src/wrapMapSerializer.ts", "../../@prismicio/richtext/src/composeSerializers.ts", "../../imgix-url-builder/src/buildURL.ts", "../../imgix-url-builder/src/buildPixelDensitySrcSet.ts", "../../imgix-url-builder/src/buildWidthSrcSet.ts", "../../imgix-url-builder/src/Client.ts", "../../@prismicio/helpers/src/asDate.ts", "../../@prismicio/helpers/src/documentToLinkField.ts", "../../@prismicio/helpers/src/asLink.ts", "../../@prismicio/helpers/src/asText.ts", "../../@prismicio/helpers/src/lib/serializerHelpers.ts", "../../@prismicio/helpers/src/asHTML.ts", "../../@prismicio/helpers/src/isFilled.ts", "../../@prismicio/helpers/src/asImageSrc.ts", "../../@prismicio/helpers/src/asImageWidthSrcSet.ts", "../../@prismicio/helpers/src/asImagePixelDensitySrcSet.ts", "../../@prismicio/helpers/src/index.ts", "../../@prismicio/client/src/isRepositoryName.ts", "../../@prismicio/client/src/PrismicError.ts", "../../@prismicio/client/src/getRepositoryEndpoint.ts", "../../@prismicio/client/src/getRepositoryName.ts", "../../@prismicio/client/src/getGraphQLEndpoint.ts", "../../@prismicio/client/src/isRepositoryEndpoint.ts", "../../@prismicio/client/src/lib/castArray.ts", "../../@prismicio/client/src/buildQueryURL.ts", "../../@prismicio/client/src/lib/appendPredicates.ts", "../../@prismicio/client/src/lib/castThunk.ts", "../../@prismicio/client/src/lib/findRef.ts", "../../@prismicio/client/src/lib/findMasterRef.ts", "../../@prismicio/client/src/lib/findRefByID.ts", "../../@prismicio/client/src/lib/findRefByLabel.ts", "../../@prismicio/client/src/cookie.ts", "../../@prismicio/client/src/lib/getPreviewCookie.ts", "../../@prismicio/client/src/lib/minifyGraphQLQuery.ts", "../../@prismicio/client/src/ForbiddenError.ts", "../../@prismicio/client/src/NotFoundError.ts", "../../@prismicio/client/src/ParsingError.ts", "../../@prismicio/client/src/predicate.ts", "../../@prismicio/client/src/client.ts", "../../@prismicio/client/src/index.ts", "../../@prismicio/vue/src/lib/simplyResolveComponent.ts", "../../@prismicio/vue/src/components/PrismicEmbed.ts", "../../@prismicio/vue/src/lib/__PRODUCTION__.ts", "../../@prismicio/vue/src/injectionSymbols.ts", "../../@prismicio/vue/src/usePrismic.ts", "../../@prismicio/vue/src/components/PrismicImage.ts", "../../@prismicio/vue/src/lib/isInternalURL.ts", "../../@prismicio/vue/src/lib/getSlots.ts", "../../@prismicio/vue/src/components/PrismicLink.ts", "../../@prismicio/vue/src/components/PrismicText.ts", "../../@prismicio/vue/src/components/PrismicRichText.ts", "../../@prismicio/vue/src/components/SliceZone.ts", "../../@prismicio/vue/src/createPrismic.ts", "../../@prismicio/vue/src/types.ts", "../../@prismicio/vue/src/useStatefulPrismicClientMethod.ts", "../../@prismicio/vue/src/composables.ts"],
  "sourcesContent": ["/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n", "import type { EmbedField } from \"./embed\";\nimport type { FieldState } from \"./types\";\nimport type { FilledContentRelationshipField } from \"./contentRelationship\";\nimport type { FilledLinkToMediaField } from \"./linkToMedia\";\nimport type { FilledLinkToWebField } from \"./link\";\n\n/**\n * Types for RichTextNodes\n *\n * @see More details: {@link https://prismic.io/docs/core-concepts/rich-text-title}\n */\nexport const RichTextNodeType = {\n\theading1: \"heading1\",\n\theading2: \"heading2\",\n\theading3: \"heading3\",\n\theading4: \"heading4\",\n\theading5: \"heading5\",\n\theading6: \"heading6\",\n\tparagraph: \"paragraph\",\n\tpreformatted: \"preformatted\",\n\tstrong: \"strong\",\n\tem: \"em\",\n\tlistItem: \"list-item\",\n\toListItem: \"o-list-item\",\n\tlist: \"group-list-item\",\n\toList: \"group-o-list-item\",\n\timage: \"image\",\n\tembed: \"embed\",\n\thyperlink: \"hyperlink\",\n\tlabel: \"label\",\n\tspan: \"span\",\n} as const;\n\n// Text nodes\n\n/**\n * Base to be extended by other RT Nodes.\n */\nexport interface RTTextNodeBase {\n\ttext: string;\n\tspans: RTInlineNode[];\n}\n\n/**\n * Rich Text `heading1` node\n */\nexport interface RTHeading1Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading1;\n}\n\n/**\n * Rich Text `heading2` node\n */\nexport interface RTHeading2Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading2;\n}\n\n/**\n * Rich Text `heading3` node\n */\nexport interface RTHeading3Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading3;\n}\n\n/**\n * Rich Text `heading4` node\n */\nexport interface RTHeading4Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading4;\n}\n\n/**\n * Rich Text `heading5` node\n */\nexport interface RTHeading5Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading5;\n}\n\n/**\n * Rich Text `heading6` node\n */\nexport interface RTHeading6Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading6;\n}\n\n/**\n * Rich Text `paragraph` node\n */\nexport interface RTParagraphNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.paragraph;\n}\n\n/**\n * Rich Text `preformatted` node\n */\nexport interface RTPreformattedNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.preformatted;\n}\n\n/**\n * Rich Text `list-item` node\n */\nexport interface RTListItemNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.listItem;\n}\n\n/**\n * Rich Text `o-list-item` node for ordered lists\n */\nexport interface RTOListItemNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.oListItem;\n}\n\n// Span nodes\n\n/**\n * @internal Span Node base to be extended for other Span nodes\n */\nexport interface RTSpanNodeBase {\n\tstart: number;\n\tend: number;\n}\n/**\n * Rich Text `strong` node\n */\nexport interface RTStrongNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.strong;\n}\n\n/**\n * Rich Text `embed` node\n */\nexport interface RTEmNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.em;\n}\n\n/**\n * Rich Text `label` node\n */\nexport interface RTLabelNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.label;\n\tdata: {\n\t\tlabel: string;\n\t};\n}\n\n// Media nodes\n\n/**\n * Rich Text `image` nodes. They could link to other documents, external web\n * links and media fields\n */\nexport type RTImageNode = {\n\ttype: typeof RichTextNodeType.image;\n\turl: string;\n\talt: string | null;\n\tcopyright: string | null;\n\tdimensions: {\n\t\twidth: number;\n\t\theight: number;\n\t};\n\tlinkTo?:\n\t\t| FilledContentRelationshipField\n\t\t| FilledLinkToWebField\n\t\t| FilledLinkToMediaField;\n};\n\n/**\n * Rich Text `embed` node\n */\nexport type RTEmbedNode = {\n\ttype: typeof RichTextNodeType.embed;\n\toembed: EmbedField;\n};\n\n// Link nodes\n\n/**\n * Rich Text `a` node\n *\n * @see More details: {@link https://prismic.io/docs/core-concepts/edit-rich-text#add-links}\n */\nexport interface RTLinkNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.hyperlink;\n\tdata:\n\t\t| FilledContentRelationshipField\n\t\t| FilledLinkToWebField\n\t\t| FilledLinkToMediaField;\n}\n\n// Serialization related nodes\n\n/**\n * Rich Text `list` node\n */\nexport interface RTListNode {\n\ttype: typeof RichTextNodeType.list;\n\titems: RTListItemNode[];\n}\n\n/**\n * Rich Text o-lost node\n */\nexport interface RTOListNode {\n\ttype: typeof RichTextNodeType.oList;\n\titems: RTOListItemNode[];\n}\n\n// This one is confusing but it's actually the inner content of a block\n/**\n * Rich Text `span` node\n */\nexport interface RTSpanNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.span;\n}\n\n// Helpers\n\n/**\n * Nodes from a Rich Text Field\n */\nexport type RTNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode\n\t| RTImageNode\n\t| RTEmbedNode;\n\n/**\n * Rich text nodes with text\n */\nexport type RTTextNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode;\n\n/**\n * Rich Text block nodes\n */\nexport type RTBlockNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode\n\t| RTListNode\n\t| RTOListNode\n\t| RTImageNode\n\t| RTEmbedNode;\n\n/**\n * Inline Rich Text Nodes\n */\nexport type RTInlineNode = RTStrongNode | RTEmNode | RTLabelNode | RTLinkNode;\n\n/**\n * All Rich Text nodes\n */\nexport type RTAnyNode = RTBlockNode | RTInlineNode | RTSpanNode;\n\n/**\n * Rich Text Field\n *\n * @see Rich Text field documentation: {@link https://prismic.io/docs/core-concepts/rich-text-title}\n */\nexport type RichTextField<State extends FieldState = FieldState> =\n\tState extends \"empty\" ? [] : [RTNode, ...RTNode[]];\n", "import type { FieldState, AnyRegularField } from \"./types\";\nimport type { GroupField } from \"./group\";\nimport type { SliceZone } from \"./sliceZone\";\nimport type { ContentRelationshipField } from \"./contentRelationship\";\nimport type { LinkToMediaField } from \"./linkToMedia\";\n\n/**\n * Link Types\n */\nexport const LinkType = {\n\tAny: \"Any\",\n\tDocument: \"Document\",\n\tMedia: \"Media\",\n\tWeb: \"Web\",\n} as const;\n\n/**\n * For link fields that haven't been filled\n *\n * @typeParam Type - The type of link.\n */\nexport type EmptyLinkField<\n\tType extends typeof LinkType[keyof typeof LinkType] = typeof LinkType.Any,\n> = {\n\tlink_type: Type | string;\n};\n\n/**\n * Link that points to external website\n */\nexport interface FilledLinkToWebField {\n\tlink_type: typeof LinkType.Web;\n\turl: string;\n\ttarget?: string;\n}\n\n/**\n * Link Field\n *\n * @typeParam TypeEnum - Type API ID of the document.\n * @typeParam LangEnum - Language API ID of the document.\n * @typeParam DataInterface - Data fields for the document (filled in via\n *   GraphQuery of `fetchLinks`).\n * @typeParam State - State of the field which determines its shape.\n */\nexport type LinkField<\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n\tState extends FieldState = FieldState,\n> = State extends \"empty\"\n\t? EmptyLinkField<typeof LinkType.Any>\n\t:\n\t\t\t| ContentRelationshipField<TypeEnum, LangEnum, DataInterface, State>\n\t\t\t| FilledLinkToWebField\n\t\t\t| LinkToMediaField<State>;\n", "import type { EmptyObjectField, FieldState } from \"./types\";\n\n/**\n * oEmbed 1.0 possible types.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport const OEmbedType = {\n\tPhoto: \"photo\",\n\tVideo: \"video\",\n\tLink: \"link\",\n\tRich: \"rich\",\n} as const;\n\n/**\n * oEmbed response base fields. Those are every mandatory fields an oEmbed\n * response must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\ntype OEmbedBase<TType extends typeof OEmbedType[keyof typeof OEmbedType]> = {\n\t/**\n\t * oEmbed resource type.\n\t */\n\ttype: TType;\n\n\t/**\n\t * oEmbed version number, this must be \"1.0\".\n\t */\n\tversion: string;\n};\n\n/**\n * oEmbed response extra fields. Those are every non-mandatory and unknown\n * fields an oEmbed response can feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type OEmbedExtra = {\n\t/**\n\t * oEmbed text title, describing the resource.\n\t */\n\ttitle?: string | null;\n\n\t/**\n\t * oEmbed resource author/owner name.\n\t */\n\tauthor_name?: string | null;\n\n\t/**\n\t * oEmbed resource author/owner URL.\n\t */\n\tauthor_url?: string | null;\n\n\t/**\n\t * oEmbed resource provider name.\n\t */\n\tprovider_name?: string | null;\n\n\t/**\n\t * oEmbed resource provider URL.\n\t */\n\tprovider_url?: string | null;\n\n\t/**\n\t * oEmbed suggested cache lifetime for the resource, in seconds.\n\t */\n\tcache_age?: number | null;\n\n\t/**\n\t * oEmbed resource thumbnail URL.\n\t */\n\tthumbnail_url?: string | null;\n\n\t/**\n\t * oEmbed resource thumbnail width.\n\t */\n\tthumbnail_width?: number | null;\n\n\t/**\n\t * oEmbed resource thumbnail height.\n\t */\n\tthumbnail_height?: number | null;\n\n\t/**\n\t * Providers may optionally include any parameters not specified in this\n\t * document (so long as they use the same key-value format) and consumers may\n\t * choose to ignore these. Consumers must ignore parameters they do not\n\t * understand.\n\t *\n\t * @see oEmbed specification: {@link https://oembed.com}\n\t */\n\t[key: string]: unknown | null;\n};\n\n/**\n * oEmbed photo type. Those are every mandatory fields an oEmbed photo response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type PhotoOEmbed = OEmbedBase<typeof OEmbedType.Photo> & {\n\t/**\n\t * oEmbed source URL of the image.\n\t */\n\turl: string;\n\n\t/**\n\t * oEmbed width in pixels of the image.\n\t */\n\twidth: number;\n\n\t/**\n\t * oEmbed height in pixels of the image.\n\t */\n\theight: number;\n};\n\n/**\n * oEmbed video type. Those are every mandatory fields an oEmbed video response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type VideoOEmbed = OEmbedBase<typeof OEmbedType.Video> & {\n\t/**\n\t * oEmbed HTML required to embed a video player.\n\t */\n\thtml: string;\n\n\t/**\n\t * oEmbed width in pixels required to display the HTML.\n\t */\n\twidth: number;\n\n\t/**\n\t * oEmbed height in pixels required to display the HTML.\n\t */\n\theight: number;\n};\n\n/**\n * oEmbed link type. Those are every mandatory fields an oEmbed link response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type LinkOEmbed = OEmbedBase<typeof OEmbedType.Link>;\n\n/**\n * oEmbed rich type. Those are every mandatory fields an oEmbed rich response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type RichOEmbed = OEmbedBase<typeof OEmbedType.Rich> & {\n\t/**\n\t * oEmbed HTML required to display the resource.\n\t */\n\thtml: string;\n\n\t/**\n\t * oEmbed width in pixels required to display the HTML.\n\t */\n\twidth: number;\n\n\t/**\n\t * oEmbed height in pixels required to display the HTML.\n\t */\n\theight: number;\n};\n\n/**\n * Any of the possible types of oEmbed response. Those contains only mandatory\n * fields their respective oEmbed response type must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type AnyOEmbed = PhotoOEmbed | VideoOEmbed | LinkOEmbed | RichOEmbed;\n\n/**\n * An Embed field.\n *\n * @typeParam Data - Data provided by the URL's oEmbed provider.\n * @typeParam State - State of the field which determines its shape.\n * @see More details: {@link https://prismic.io/docs/core-concepts/embed}\n */\nexport type EmbedField<\n\tData extends AnyOEmbed = AnyOEmbed & OEmbedExtra,\n\tState extends FieldState = FieldState,\n> = State extends \"empty\"\n\t? EmptyObjectField\n\t: Data & {\n\t\t\tembed_url: string;\n\t\t\thtml: string | null;\n\t  };\n", "import type { CustomTypeModelContentRelationshipField } from \"./contentRelationship\";\nimport type { CustomTypeModelEmbedField } from \"./embed\";\nimport type { CustomTypeModelImageField } from \"./image\";\nimport type { CustomTypeModelLinkField } from \"./link\";\nimport type { CustomTypeModelLinkToMediaField } from \"./linkToMedia\";\nimport type { CustomTypeModelRichTextField } from \"./richText\";\nimport type { CustomTypeModelTitleField } from \"./title\";\n\nimport type { CustomTypeModelBooleanField } from \"./boolean\";\nimport type { CustomTypeModelColorField } from \"./color\";\nimport type { CustomTypeModelDateField } from \"./date\";\nimport type { CustomTypeModelKeyTextField } from \"./keyText\";\nimport type { CustomTypeModelNumberField } from \"./number\";\nimport type { CustomTypeModelSelectField } from \"./select\";\nimport type { CustomTypeModelTimestampField } from \"./timestamp\";\nimport type { CustomTypeModelGeoPointField } from \"./geoPoint\";\n\nimport type { CustomTypeModelIntegrationFieldsField } from \"./integrationFields\";\nimport type { CustomTypeModelGroupField } from \"./group\";\nimport type { CustomTypeModelSliceZoneField } from \"./sliceZone\";\n\nimport type { CustomTypeModelUIDField } from \"./uid\";\n\nimport type { CustomTypeModelRangeField } from \"./range\";\nimport type { CustomTypeModelSeparatorField } from \"./separator\";\n\n/**\n * Type identifier for a Custom Type field.\n */\nexport const CustomTypeModelFieldType = {\n\tBoolean: \"Boolean\",\n\tColor: \"Color\",\n\tDate: \"Date\",\n\tEmbed: \"Embed\",\n\tGeoPoint: \"GeoPoint\",\n\tGroup: \"Group\",\n\tImage: \"Image\",\n\tIntegrationFields: \"IntegrationFields\",\n\tLink: \"Link\",\n\tNumber: \"Number\",\n\tSelect: \"Select\",\n\tSlices: \"Slices\",\n\tStructuredText: \"StructuredText\",\n\tText: \"Text\",\n\tTimestamp: \"Timestamp\",\n\tUID: \"UID\",\n\t/**\n\t * @deprecated - Legacy field type. Use `Number` instead.\n\t */\n\tRange: \"Range\",\n\t/**\n\t * @deprecated - Legacy field type. Do not use.\n\t */\n\tSeparator: \"Separator\",\n\t/**\n\t * @deprecated - Legacy field type. Use `Slices` instead.\n\t */\n\tLegacySlices: \"Choice\",\n} as const;\n\n/**\n * A Custom Type field.\n */\nexport type CustomTypeModelField =\n\t| CustomTypeModelUIDField\n\t| CustomTypeModelGroupField\n\t| CustomTypeModelSliceZoneField\n\t| CustomTypeModelFieldForGroup;\n\n/**\n * Any Custom Type field that is valid for a Group field.\n */\nexport type CustomTypeModelFieldForGroup =\n\t| CustomTypeModelBooleanField\n\t| CustomTypeModelColorField\n\t| CustomTypeModelDateField\n\t| CustomTypeModelEmbedField\n\t| CustomTypeModelGeoPointField\n\t| CustomTypeModelImageField\n\t| CustomTypeModelIntegrationFieldsField\n\t| CustomTypeModelContentRelationshipField\n\t| CustomTypeModelLinkField\n\t| CustomTypeModelLinkToMediaField\n\t| CustomTypeModelNumberField\n\t| CustomTypeModelRangeField\n\t| CustomTypeModelSelectField\n\t| CustomTypeModelRichTextField\n\t| CustomTypeModelTitleField\n\t| CustomTypeModelKeyTextField\n\t| CustomTypeModelTimestampField\n\t| CustomTypeModelSeparatorField;\n", "import type { CustomTypeModelFieldType } from \"./types\";\n\n/**\n * A Link Custom Type field.\n *\n * More details:\n * {@link https://prismic.io/docs/core-concepts/link-content-relationship}\n */\nexport interface CustomTypeModelLinkField {\n\ttype: typeof CustomTypeModelFieldType.Link;\n\tconfig?: {\n\t\tlabel?: string | null;\n\t\tplaceholder?: string;\n\t\tselect?:\n\t\t\t| null\n\t\t\t| typeof CustomTypeModelLinkSelectType[keyof typeof CustomTypeModelLinkSelectType];\n\t\tallowTargetBlank?: boolean;\n\t};\n}\n\n/**\n * Type of a Link Custom Type field.\n *\n * More details:\n * {@link https://prismic.io/docs/core-concepts/link-content-relationship}\n */\nexport const CustomTypeModelLinkSelectType = {\n\tDocument: \"document\",\n\tMedia: \"media\",\n\tWeb: \"web\",\n} as const;\n", "import type { CustomTypeModelFieldType } from \"./types\";\nimport type { CustomTypeModelLegacySlice, CustomTypeModelSlice } from \"./slice\";\n\n/**\n * A Slice Zone Custom Type field.\n *\n * More details: {@link https://prismic.io/docs/core-concepts/slices}\n */\nexport interface CustomTypeModelSliceZoneField<\n\tSlices extends Record<\n\t\tstring,\n\t\t| CustomTypeModelSlice\n\t\t| CustomTypeModelSharedSlice\n\t\t| CustomTypeModelLegacySlice\n\t> = Record<\n\t\tstring,\n\t\t| CustomTypeModelSlice\n\t\t| CustomTypeModelSharedSlice\n\t\t| CustomTypeModelLegacySlice\n\t>,\n> {\n\ttype:\n\t\t| typeof CustomTypeModelFieldType.Slices\n\t\t| typeof CustomTypeModelFieldType.LegacySlices;\n\tfieldset?: string | null;\n\tconfig?: {\n\t\tlabels?: Record<string, readonly CustomTypeModelSliceLabel[]> | null;\n\t\tchoices?: Slices;\n\t};\n}\n\n/**\n * Label for a Slice.\n *\n * More details: {@link https://prismic.io/docs/core-concepts/slices}\n */\nexport interface CustomTypeModelSliceLabel {\n\tname: string;\n\tdisplay?: string;\n}\n\n/**\n * Type identifier for a Slice.\n *\n * More details: {@link https://prismic.io/docs/core-concepts/slices}\n */\nexport const CustomTypeModelSliceType = {\n\tSlice: \"Slice\",\n\tSharedSlice: \"SharedSlice\",\n} as const;\n\n/**\n * A Shared Slice for a Custom Type.\n *\n * More details:\n *\n * - {@link https://prismic.io/docs/core-concepts/slices}\n * - {@link https://prismic.io/docs/core-concepts/reusing-slices}\n */\nexport interface CustomTypeModelSharedSlice {\n\ttype: typeof CustomTypeModelSliceType.SharedSlice;\n}\n", "import type { CustomTypeModelGroupField } from \"./group\";\nimport type { CustomTypeModelSliceType } from \"./sliceZone\";\nimport type { CustomTypeModelFieldForGroup } from \"./types\";\n\n/**\n * A Slice for a Custom Type.\n *\n * More details: {@link https://prismic.io/docs/core-concepts/slices}\n *\n * @typeParam NonRepeatFields - A record of fields that cannnot be repeated.\n * @typeParam RepeatFields - A record of fields that can be repeated.\n */\nexport interface CustomTypeModelSlice<\n\tNonRepeatFields extends Record<string, CustomTypeModelFieldForGroup> = Record<\n\t\tstring,\n\t\tCustomTypeModelFieldForGroup\n\t>,\n\tRepeatFields extends Record<string, CustomTypeModelFieldForGroup> = Record<\n\t\tstring,\n\t\tCustomTypeModelFieldForGroup\n\t>,\n> {\n\ttype: typeof CustomTypeModelSliceType.Slice;\n\tfieldset?: string | null;\n\tdescription?: string;\n\ticon?: string;\n\tdisplay?:\n\t\t| typeof CustomTypeModelSliceDisplay[keyof typeof CustomTypeModelSliceDisplay]\n\t\t| string;\n\t\"non-repeat\"?: NonRepeatFields;\n\trepeat?: RepeatFields;\n}\n\n/**\n * Display type for a Slice.\n *\n * More details: {@link https://prismic.io/docs/core-concepts/slices}\n */\nexport const CustomTypeModelSliceDisplay = {\n\tList: \"list\",\n\tGrid: \"grid\",\n} as const;\n\n/**\n * @deprecated - Legacy slice type. Do not use.\n */\nexport type CustomTypeModelLegacySlice =\n\t| CustomTypeModelGroupField\n\t| CustomTypeModelFieldForGroup;\n", "import { WebhookBodyAPIUpdate } from \"./apiUpdate\";\nimport { WebhookBodyTestTrigger } from \"./testTrigger\";\n\nexport type WebhookBody = WebhookBodyAPIUpdate | WebhookBodyTestTrigger;\n\n/**\n * Types of Prismic Webhooks.\n *\n * @see More details: {@link https://prismic.io/docs/core-concepts/webhooks}\n */\nexport const WebhookType = {\n\tAPIUpdate: \"api-update\",\n\tTestTrigger: \"test-trigger\",\n} as const;\n\nexport interface WebhookBodyBase {\n\ttype: typeof WebhookType[keyof typeof WebhookType];\n\tdomain: string;\n\tapiUrl: string;\n\tsecret: string | null;\n}\n", "import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n} from \"@prismicio/types\";\nimport { Tree, TreeNode } from \"./types\";\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString();\n};\nuuid.i = 0;\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes);\n\n\tconst children: TreeNode[] = [];\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]));\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t};\n};\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t};\n};\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t});\n};\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0);\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i];\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t];\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode);\n\t\t\t\tmutNodes.splice(i, 1);\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes;\n};\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t);\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = [];\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]));\n\t\t}\n\n\t\treturn createTreeNode(node, children);\n\t}\n\n\treturn createTreeNode(node);\n};\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)];\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0);\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n\n\tconst children: TreeNode[] = [];\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i];\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0;\n\t\tconst spanStart = span.start - parentSpanStart;\n\t\tconst spanEnd = span.end - parentSpanStart;\n\t\tconst text = node.text.slice(spanStart, spanEnd);\n\n\t\tconst childSpans: RTInlineNode[] = [];\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j];\n\n\t\t\tif (\n\t\t\t\tsiblingSpan !== span &&\n\t\t\t\tsiblingSpan.start >= span.start &&\n\t\t\t\tsiblingSpan.end <= span.end\n\t\t\t) {\n\t\t\t\tchildSpans.push(siblingSpan);\n\t\t\t\tmutSpans.splice(j, 1);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)));\n\t\t}\n\n\t\tconst spanWithText = { ...span, text };\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspanWithText,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn children;\n};\n", "import { RichTextField, RTTextNode } from \"@prismicio/types\";\n\n/**\n * Serializes a rich text or title field to a plain text string\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param separator - Separator used to join each element, defaults to a space\n *\n * @returns Plain text equivalent of the provided rich text or title field\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const asText = (\n\trichTextField: RichTextField,\n\tseparator = \" \",\n): string => {\n\tlet result = \"\";\n\n\tfor (let i = 0; i < richTextField.length; i++) {\n\t\tif (\"text\" in richTextField[i]) {\n\t\t\tresult +=\n\t\t\t\t(result ? separator : \"\") + (richTextField[i] as RTTextNode).text;\n\t\t}\n\t}\n\n\treturn result;\n};\n", "import { RichTextField } from \"@prismicio/types\";\nimport { RichTextFunctionSerializer, TreeNode } from \"./types\";\nimport { asTree } from \"./asTree\";\n\n/**\n * Serializes a rich text or title field with a given serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of the serializer\n * @param richTextField - A rich text or title field from Prismic\n * @param serializer - A function serializer to apply\n *\n * @returns An array of serialized nodes\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const serialize = <SerializerReturnType>(\n\trichTextField: RichTextField,\n\tserializer: RichTextFunctionSerializer<SerializerReturnType>,\n): SerializerReturnType[] => {\n\treturn serializeTreeNodes<SerializerReturnType>(\n\t\tasTree(richTextField).children,\n\t\tserializer,\n\t);\n};\n\nconst serializeTreeNodes = <T>(\n\tnodes: TreeNode[],\n\tserializer: RichTextFunctionSerializer<T>,\n): T[] => {\n\tconst serializedTreeNodes: T[] = [];\n\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst treeNode = nodes[i];\n\t\tconst serializedTreeNode = serializer(\n\t\t\ttreeNode.type,\n\t\t\ttreeNode.node,\n\t\t\ttreeNode.text,\n\t\t\tserializeTreeNodes(treeNode.children, serializer),\n\t\t\ttreeNode.key,\n\t\t);\n\n\t\tif (serializedTreeNode != null) {\n\t\t\tserializedTreeNodes.push(serializedTreeNode);\n\t\t}\n\t}\n\n\treturn serializedTreeNodes;\n};\n", "import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTEmbedNode,\n\tRTEmNode,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTImageNode,\n\tRTLabelNode,\n\tRTLinkNode,\n\tRTListItemNode,\n\tRTListNode,\n\tRTOListItemNode,\n\tRTOListNode,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTSpanNode,\n\tRTStrongNode,\n} from \"@prismicio/types\";\n\n// Serializers\n\n/**\n * Serializes a node from a rich text or title field with a function\n *\n * @typeParam ReturnType - Return type of the function serializer\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextFunctionSerializer<ReturnType> = (\n\ttype: typeof RichTextNodeType[keyof typeof RichTextNodeType],\n\tnode: RTAnyNode,\n\ttext: string | undefined,\n\tchildren: ReturnType[],\n\tkey: string,\n) => ReturnType | null | undefined;\n\n/**\n * Map serializer's tag function serializer, can be helpful for typing those handlers\n *\n * @typeParam ReturnType - Return type of the tag serializer\n */\nexport type RichTextMapSerializerFunction<\n\tReturnType,\n\tNode extends RTAnyNode = RTAnyNode,\n\tTextType = string | undefined,\n> = (payload: {\n\ttype: Node[\"type\"];\n\tnode: Node;\n\ttext: TextType;\n\tchildren: ReturnType[];\n\tkey: string;\n}) => ReturnType | null | undefined;\n\n/**\n * Serializes a node from a rich text or title field with a map\n *\n * @remarks\n * This type of serializer needs to be processed through\n * {@link wrapMapSerializer} before being used with {@link serialize}\n * @typeParam ReturnType - Return type of the map serializer\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport type RichTextMapSerializer<ReturnType> = {\n\theading1?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading1Node,\n\t\tundefined\n\t>;\n\theading2?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading2Node,\n\t\tundefined\n\t>;\n\theading3?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading3Node,\n\t\tundefined\n\t>;\n\theading4?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading4Node,\n\t\tundefined\n\t>;\n\theading5?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading5Node,\n\t\tundefined\n\t>;\n\theading6?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading6Node,\n\t\tundefined\n\t>;\n\tparagraph?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTParagraphNode,\n\t\tundefined\n\t>;\n\tpreformatted?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTPreformattedNode,\n\t\tundefined\n\t>;\n\tstrong?: RichTextMapSerializerFunction<ReturnType, RTStrongNode, string>;\n\tem?: RichTextMapSerializerFunction<ReturnType, RTEmNode, string>;\n\tlistItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTListItemNode,\n\t\tundefined\n\t>;\n\toListItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTOListItemNode,\n\t\tundefined\n\t>;\n\tlist?: RichTextMapSerializerFunction<ReturnType, RTListNode, undefined>;\n\toList?: RichTextMapSerializerFunction<ReturnType, RTOListNode, undefined>;\n\timage?: RichTextMapSerializerFunction<ReturnType, RTImageNode, undefined>;\n\tembed?: RichTextMapSerializerFunction<ReturnType, RTEmbedNode, undefined>;\n\thyperlink?: RichTextMapSerializerFunction<ReturnType, RTLinkNode, string>;\n\tlabel?: RichTextMapSerializerFunction<ReturnType, RTLabelNode, string>;\n\tspan?: RichTextMapSerializerFunction<ReturnType, RTSpanNode, string>;\n};\n\n// Tree\nexport interface Tree {\n\tkey: string;\n\tchildren: TreeNode[];\n}\n\nexport interface TreeNode {\n\tkey: string;\n\ttype: typeof RichTextNodeType[keyof typeof RichTextNodeType];\n\ttext?: string;\n\tnode: RTAnyNode;\n\tchildren: TreeNode[];\n}\n\n// Helpers\nexport const RichTextReversedNodeType = {\n\t[RichTextNodeType.listItem]: \"listItem\",\n\t[RichTextNodeType.oListItem]: \"oListItem\",\n\t[RichTextNodeType.list]: \"list\",\n\t[RichTextNodeType.oList]: \"oList\",\n} as const;\n", "import {\n\tRichTextFunctionSerializer,\n\tRichTextMapSerializer,\n\tRichTextReversedNodeType,\n} from \"./types\";\n\n/**\n * Wraps a map serializer into a regular function serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of the map serializer\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nexport const wrapMapSerializer = <SerializerReturnType>(\n\tmapSerializer: RichTextMapSerializer<SerializerReturnType>,\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (type, node, text, children, key) => {\n\t\tconst tagSerializer: RichTextMapSerializer<SerializerReturnType>[keyof RichTextMapSerializer<SerializerReturnType>] =\n\t\t\tmapSerializer[\n\t\t\t\t(RichTextReversedNodeType[\n\t\t\t\t\ttype as keyof typeof RichTextReversedNodeType\n\t\t\t\t] || type) as keyof RichTextMapSerializer<SerializerReturnType>\n\t\t\t];\n\n\t\tif (tagSerializer) {\n\t\t\treturn tagSerializer({\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttype,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tnode,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttext,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tchildren,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tkey,\n\t\t\t});\n\t\t}\n\t};\n};\n", "import { RichTextFunctionSerializer } from \"./types\";\n\n/**\n * Takes an array of serializers and returns a serializer applying provided\n * serializers sequentially until a result is returned\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n * @typeParam SerializerReturnType - Return type of serializers\n * @param serializers - Serializers to compose\n *\n * @returns Composed serializer\n */\nexport const composeSerializers = <SerializerReturnType>(\n\t...serializers: (\n\t\t| RichTextFunctionSerializer<SerializerReturnType>\n\t\t| undefined\n\t)[]\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (...args) => {\n\t\tfor (let i = 0; i < serializers.length; i++) {\n\t\t\tconst serializer = serializers[i];\n\n\t\t\tif (serializer) {\n\t\t\t\tconst res = serializer(...args);\n\n\t\t\t\tif (res != null) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n", "import type { ImgixURLParams } from \"./types.generated\";\n\n/**\n * Converts a camel case string to a param case string.\n *\n * @example\n *\n * ```ts\n * camelCaseToParamCase(\"fooBar\");\n * // => 'foo-bar'\n * ```\n *\n * @param input - Camel case string to convert.\n *\n * @returns Param case version of `input`.\n */\nconst camelCaseToParamCase = (input: string): string => {\n\treturn input.replace(/[A-Z]/g, (match) => {\n\t\treturn `-${match.toLowerCase()}`;\n\t});\n};\n\n/**\n * Builds a URL to an Imgix image with Imgix URL API parameters.\n *\n * The given URL must be a full absolute URL containing the protocol and domain.\n *\n * URL parameters already applied to the image will be retained. To remove\n * existing parameters, set the parameter to `undefined` in the `params` argument.\n *\n * @example\n *\n * ```ts\n * const url = buildURL(\"https://example.imgix.net/image.png\", {\n * \twidth: 400,\n * });\n * // => https://example.imgix.net/image.png?width=400\n * ```\n *\n * @example\n *\n * ```ts\n * const url = buildURL(\"https://example.imgix.net/image.png?width=400\", {\n * \theight: 300,\n * });\n * // => https://example.imgix.net/image.png?width=400&height=300\n * ```\n *\n * @param url - Full absolute URL to the Imgix image.\n * @param params - An object of Imgix URL API parameters.\n *\n * @returns `url` with the given Imgix URL API parameters applied.\n *\n * @see Imgix URL API reference: https://docs.imgix.com/apis/rendering\n */\nexport const buildURL = (url: string, params: ImgixURLParams): string => {\n\tconst instance = new URL(url);\n\n\tfor (const camelCasedParamKey in params) {\n\t\tconst paramKey = camelCaseToParamCase(camelCasedParamKey);\n\t\tconst paramValue = params[camelCasedParamKey as keyof typeof params];\n\n\t\tif (paramValue === undefined) {\n\t\t\tinstance.searchParams.delete(paramKey);\n\t\t} else if (Array.isArray(paramValue)) {\n\t\t\tinstance.searchParams.set(paramKey, paramValue.join(\",\"));\n\t\t} else {\n\t\t\tinstance.searchParams.set(paramKey, `${paramValue}`);\n\t\t}\n\t}\n\n\t// Ensure the `s` parameter is the last parameter, if it exists.\n\t// @see https://github.com/imgix/imgix-blueprint#securing-urls\n\tconst s = instance.searchParams.get(\"s\");\n\tif (s) {\n\t\tinstance.searchParams.delete(\"s\");\n\t\tinstance.searchParams.append(\"s\", s);\n\t}\n\n\treturn instance.toString();\n};\n", "import type { ImgixURLParams } from \"./types.generated\";\nimport { buildURL } from \"./buildURL\";\n\n/**\n * Parameters for `buildPixelDensitySrcSet`.\n */\nexport type BuildPixelDensitySrcSetParams = Omit<ImgixURLParams, \"dpr\"> & {\n\t/**\n\t * The pixel densities to include in the resulting `srcset` value.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * [1, 2, 3];\n\t * ```\n\t */\n\tpixelDensities: number[];\n};\n\n/**\n * Builds an `<img>` `srcset` attribute value for a given set of pixel\n * densities. It can also optinally apply Imgix URL API parameters to the URLs.\n *\n * The `dpr` URL parameter will be applied for each `srcset` entry. If a `dpr`\n * parameter is provided to the `params` parameter, it will be ignored.\n *\n * @example\n *\n * ```ts\n * const srcset = buildPixelDensitySrcSet(\n * \t\"https://example.imgix.net/image.png\",\n * \t{ pixelDensities: [1, 2, 3] },\n * );\n * // => https://example.imgix.net/image.png?dpr=1 1x,\n * //    https://example.imgix.net/image.png?dpr=2 2x,\n * //    https://example.imgix.net/image.png?dpr=3 3x\n * ```\n *\n * @example\n *\n * ```ts\n * const srcset = buildPixelDensitySrcSet(\n * \t\"https://example.imgix.net/image.png\",\n * \t{\n * \t\tpixelDensities: [1, 2, 3],\n * \t\tsat: -100,\n * \t},\n * );\n * // => https://example.imgix.net/image.png?dpr=1&sat=-100 1x,\n * //    https://example.imgix.net/image.png?dpr=2&sat=-100 2x,\n * //    https://example.imgix.net/image.png?dpr=3&sat=-100 3x\n * ```\n *\n * @param url - Full absolute URL to the Imgix image.\n * @param params - An object of Imgix URL API parameters. The `pixelDensities`\n *   parameter defines the resulting `srcset` widths.\n *\n * @returns A `srcset` attribute value for `url` with the given Imgix URL API\n *   parameters applied.\n */\nexport const buildPixelDensitySrcSet = (\n\turl: string,\n\t{ pixelDensities, ...params }: BuildPixelDensitySrcSetParams,\n): string => {\n\treturn pixelDensities\n\t\t.map((dpr) => {\n\t\t\treturn `${buildURL(url, { ...params, dpr })} ${dpr}x`;\n\t\t})\n\t\t.join(\", \");\n};\n", "import type { ImgixURLParams } from \"./types.generated\";\nimport { buildURL } from \"./buildURL\";\n\n/**\n * Parameters for `buildWidthSrcSet`.\n */\nexport type BuildWidthSrcSetParams = Omit<ImgixURLParams, \"width\" | \"w\"> & {\n\t/**\n\t * The pixel widths to include in the resulting `srcset` value.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * [400, 800, 1600];\n\t * ```\n\t */\n\twidths: number[];\n};\n\n/**\n * Builds an `<img>` `srcset` attribute value for a given set of widths. It can\n * also optinally apply Imgix URL API parameters to the URLs.\n *\n * The `width` URL parameter will be applied for each `srcset` entry. If a\n * `width` or `w` parameter is provided to the `params` parameter, it will be ignored.\n *\n * @example\n *\n * ```ts\n * const srcset = buildWidthSrcSet(\"https://example.imgix.net/image.png\", {\n * \twidths: [400, 800, 1600],\n * });\n * // => https://example.imgix.net/image.png?width=400 400w,\n * //    https://example.imgix.net/image.png?width=800 800w,\n * //    https://example.imgix.net/image.png?width=1600 1600w\n * ```\n *\n * @example\n *\n * ```ts\n * const srcset = buildWidthSrcSet(\"https://example.imgix.net/image.png\", {\n * \twidths: [400, 800, 1600],\n * \tsat: -100,\n * });\n * // => https://example.imgix.net/image.png?width=400&sat=-100 400w,\n * //    https://example.imgix.net/image.png?width=800&sat=-100 800w,\n * //    https://example.imgix.net/image.png?width=1600&sat=-100 1600w\n * ```\n *\n * @param url - Full absolute URL to the Imgix image.\n * @param params - An object of Imgix URL API parameters. The `widths` parameter\n *   defines the resulting `srcset` widths.\n *\n * @returns A `srcset` attribute value for `url` with the given Imgix URL API\n *   parameters applied.\n */\nexport const buildWidthSrcSet = (\n\turl: string,\n\t{ widths, ...params }: BuildWidthSrcSetParams,\n): string => {\n\treturn widths\n\t\t.map((width) => {\n\t\t\treturn `${buildURL(url, { ...params, w: undefined, width })} ${width}w`;\n\t\t})\n\t\t.join(\", \");\n};\n", "import type { BuildPixelDensitySrcSetParams } from \"./buildPixelDensitySrcSet\";\nimport type { BuildWidthSrcSetParams } from \"./buildWidthSrcSet\";\nimport type { ImgixURLParams } from \"./types.generated\";\nimport { buildPixelDensitySrcSet } from \"./buildPixelDensitySrcSet\";\nimport { buildURL } from \"./buildURL\";\nimport { buildWidthSrcSet } from \"./buildWidthSrcSet\";\n\n/**\n * Options to instantiate a new client.\n */\nexport type ClientOptions = {\n\t/**\n\t * The base URL used to construct image URLs from a path. The base URL must\n\t * include the protocol, domain, and optionally a path.\n\t *\n\t * @example `https://example.imgix.net`\n\t *\n\t * @example `https://example.imgix.net/folder`\n\t */\n\tbaseURL: string;\n};\n\n/**\n * An Imgix Rendering API client. A client is paired to a single Imgix domain.\n */\nexport class Client {\n\tbaseURL: string;\n\n\t/**\n\t * Creates a new `Client` instance for an Imgix domain.\n\t *\n\t * @param options - Options to instantiate a new client.\n\t *\n\t * @returns A `Client` instance for the given Imgix domain.\n\t */\n\tconstructor(options: ClientOptions) {\n\t\tthis.baseURL = options.baseURL;\n\t}\n\n\t/**\n\t * Builds a URL to an Imgix image with Imgix URL API parameters for the\n\t * client's base URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({ baseURL: \"https://example.imgix.net\" });\n\t * const url = client.buildURLForPath(\"/image.png\", { width: 400 });\n\t * // => https://example.imgix.net/image.png?width=400\n\t * ```\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({\n\t * \tbaseURL: \"https://example.imgix.net/folder\",\n\t * });\n\t * const url = client.buildURLForPath(\"./image.png\", { width: 400 });\n\t * // => https://example.imgix.net/folder/image.png?width=400\n\t * ```\n\t *\n\t * @param path - Path to the image relative to the client's base URL.\n\t * @param params - An object of Imgix URL API parameters.\n\t *\n\t * @returns The full absolute URL to the image with the given Imgix URL API\n\t *   parameters applied.\n\t */\n\tbuildURLForPath(path: string, params: ImgixURLParams = {}) {\n\t\treturn buildURL(`${new URL(path, this.baseURL)}`, params);\n\t}\n\n\t/**\n\t * Builds an `<img>` `srcset` attribute value for a given set of widths for\n\t * the client's base URL. It can also optinally apply Imgix URL API parameters\n\t * to the URLs.\n\t *\n\t * The `width` URL parameter will be applied for each `srcset` entry. If a\n\t * `width` or `w` parameter is provided to the `params` parameter, it will be ignored.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({ baseURL: \"https://example.imgix.net\" });\n\t * const srcset = client.buildWidthSrcSetForPath(\"/image.png\", {\n\t * \twidths: [400, 800, 1600],\n\t * });\n\t * // => https://example.imgix.net/image.png?width=400 400w,\n\t * //    https://example.imgix.net/image.png?width=800 800w,\n\t * //    https://example.imgix.net/image.png?width=1600 1600w\n\t * ```\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({\n\t * \tbaseURL: \"https://example.imgix.net\",\n\t * });\n\t * const srcset = client.buildWidthSrcSetForPath(\"/image.png\", {\n\t * \twidths: [400, 800, 1600],\n\t * \tsat: -100,\n\t * });\n\t * // => https://example.imgix.net/image.png?width=400&sat=-100 400w,\n\t * //    https://example.imgix.net/image.png?width=800&sat=-100 800w,\n\t * //    https://example.imgix.net/image.png?width=1600&sat=-100 1600w\n\t * ```\n\t *\n\t * @param path - Path to the image relative to the client's base URL.\n\t * @param params - An object of Imgix URL API parameters. The `widths`\n\t *   parameter defines the resulting `srcset` widths.\n\t *\n\t * @returns A `srcset` attribute value for `url` with the given Imgix URL API\n\t *   parameters applied.\n\t */\n\tbuildWidthSrcSetForPath(path: string, params: BuildWidthSrcSetParams) {\n\t\treturn buildWidthSrcSet(`${new URL(path, this.baseURL)}`, params);\n\t}\n\n\t/**\n\t * Builds an `<img>` `srcset` attribute value for a given set of pixel\n\t * densities for the client's base URL. It can also optinally apply Imgix URL\n\t * API parameters to the URLs.\n\t *\n\t * The `dpr` URL parameter will be applied for each `srcset` entry. If a `dpr`\n\t * parameter is provided to the `params` parameter, it will be ignored.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({ baseURL: \"https://example.imgix.net\" });\n\t * const srcset = client.buildPixelDensitySrcSetForPath(\"/image.png\", {\n\t * \tpixelDensities: [1, 2, 3],\n\t * });\n\t * // => https://example.imgix.net/image.png?dpr=1 1x,\n\t * //    https://example.imgix.net/image.png?dpr=2 2x,\n\t * //    https://example.imgix.net/image.png?dpr=3 3x\n\t * ```\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const client = new Client({ baseURL: \"https://example.imgix.net\" });\n\t * const srcset = client.buildPixelDensitySrcSetForPath(\"/image.png\", {\n\t * \tpixelDensities: [1, 2, 3],\n\t * \tsat: -100,\n\t * });\n\t * // => https://example.imgix.net/image.png?dpr=1&sat=-100 1x,\n\t * //    https://example.imgix.net/image.png?dpr=2&sat=-100 2x,\n\t * //    https://example.imgix.net/image.png?dpr=3&sat=-100 3x\n\t * ```\n\t *\n\t * @param path - Path to the image relative to the client's base URL.\n\t * @param params - An object of Imgix URL API parameters. The `pixelDensities`\n\t *   parameter defines the resulting `srcset` widths.\n\t *\n\t * @returns A `srcset` attribute value for `url` with the given Imgix URL API\n\t *   parameters applied.\n\t */\n\tbuildPixelDensitySrcSetForPath(\n\t\tpath: string,\n\t\tparams: BuildPixelDensitySrcSetParams,\n\t) {\n\t\treturn buildPixelDensitySrcSet(`${new URL(path, this.baseURL)}`, params);\n\t}\n}\n", "import type { DateField, TimestampField } from \"@prismicio/types\";\n\n/**\n * The return type of `asDate()`.\n */\ntype AsDateReturnType<\n\tField extends DateField | TimestampField | null | undefined,\n> = Field extends DateField<\"filled\"> | TimestampField<\"filled\"> ? Date : null;\n\n/**\n * Transforms a date or timestamp field into a JavaScript Date object\n *\n * @param dateOrTimestampField - A date or timestamp field from Prismic\n *\n * @returns A Date object, null if provided date is falsy\n * @see Templating date field from Prismic {@link https://prismic.io/docs/technologies/templating-date-field-javascript}\n */\nexport const asDate = <\n\tField extends DateField | TimestampField | null | undefined,\n>(\n\tdateOrTimestampField: Field,\n): AsDateReturnType<Field> => {\n\tif (!dateOrTimestampField) {\n\t\treturn null as AsDateReturnType<Field>;\n\t}\n\n\t// If field is a timestamp field...\n\tif (dateOrTimestampField.length === 24) {\n\t\t/**\n\t\t * Converts basic ISO 8601 to ECMAScript simplified ISO 8601 format for\n\t\t * browser compatibility issues\n\t\t *\n\t\t * From: YYYY-MM-DDTHH:mm:ssZ To: YYYY-MM-DDTHH:mm:ss.sssZ\n\t\t *\n\t\t * @see MDN documentation: {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date#timestamp_string}\n\t\t * @see ECMAScript 2020 language specification: {@link https://262.ecma-international.org/11.0/#sec-date-time-string-format}\n\t\t * @see Related forum issue: {@link https://community.prismic.io/t/prismics-date-api/2520}\n\t\t * @see Regex101 expression: {@link https://regex101.com/r/jxyETT/1}\n\t\t */\n\t\treturn new Date(\n\t\t\tdateOrTimestampField.replace(/(\\+|-)(\\d{2})(\\d{2})$/, \".000$1$2:$3\"),\n\t\t) as AsDateReturnType<Field>;\n\t} else {\n\t\t// ...else field is a date field\n\t\treturn new Date(dateOrTimestampField) as AsDateReturnType<Field>;\n\t}\n};\n", "import {\n\tFilledLinkToDocumentField,\n\tLinkType,\n\tPrismicDocument,\n} from \"@prismicio/types\";\n\ntype SetOptional<T, Keys extends keyof T> = Omit<T, Keys> &\n\tPartial<Pick<T, Keys>>;\n\n/**\n * Converts a document into a link field, this is useful when crawling the API\n * for document links\n *\n * @typeParam TDocument - Specific interface of the provided document\n * @param prismicDocument - A document coming from Prismic\n *\n * @returns The equivalent link field to use with `asLink()`\n * @internal\n */\nexport const documentToLinkField = <\n\tTDocument extends SetOptional<PrismicDocument, \"slugs\">,\n>(\n\tprismicDocument: TDocument,\n): FilledLinkToDocumentField<\n\tTDocument[\"type\"],\n\tTDocument[\"lang\"],\n\tTDocument[\"data\"]\n> => {\n\treturn {\n\t\tlink_type: LinkType.Document,\n\t\tid: prismicDocument.id,\n\t\tuid: prismicDocument.uid ?? undefined,\n\t\ttype: prismicDocument.type,\n\t\ttags: prismicDocument.tags,\n\t\tlang: prismicDocument.lang,\n\t\turl: prismicDocument.url ?? undefined,\n\t\tslug: prismicDocument.slugs?.[0], // Slug field is not available with GraphQl\n\t\t// The REST API does not include a `data` property if the data\n\t\t// object is empty.\n\t\t//\n\t\t// A presence check for `prismicDocument.data` is done to\n\t\t// support partial documents. While `documentToLinkField` is\n\t\t// not typed to accept partial documents, passing a partial\n\t\t// document can happen in untyped projects.\n\t\t...(prismicDocument.data && Object.keys(prismicDocument.data).length > 0\n\t\t\t? { data: prismicDocument.data }\n\t\t\t: {}),\n\t};\n};\n", "import {\n\tFilledLinkToDocumentField,\n\tFilledLinkToMediaField,\n\tFilledLinkToWebField,\n\tLinkField,\n\tLinkType,\n\tPrismicDocument,\n} from \"@prismicio/types\";\n\nimport { documentToLinkField } from \"./documentToLinkField\";\nimport { LinkResolverFunction } from \"./types\";\n\n/**\n * The return type of `asLink()`.\n */\ntype AsLinkReturnType<\n\tLinkResolverFunctionReturnType = string,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = Field extends\n\t| FilledLinkToWebField\n\t| FilledLinkToMediaField\n\t| FilledLinkToDocumentField\n\t| PrismicDocument\n\t? LinkResolverFunctionReturnType | string | null\n\t: null;\n\n/**\n * Resolves any type of link field or document to a URL\n *\n * @typeParam LinkResolverFunctionReturnType - Link resolver function return\n *   type\n * @param linkFieldOrDocument - Any kind of link field or a document to resolve\n * @param linkResolver - An optional link resolver function, without it you're\n *   expected to use the `routes` options from the API\n *\n * @returns Resolved URL, null if provided link is empty\n * @see Prismic link resolver documentation: {@link https://prismic.io/docs/technologies/link-resolver-javascript}\n * @see Prismic API `routes` options documentation: {@link https://prismic.io/docs/technologies/route-resolver-nuxtjs}\n */\nexport const asLink = <\n\tLinkResolverFunctionReturnType = string,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n>(\n\tlinkFieldOrDocument: Field,\n\tlinkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType> | null,\n): AsLinkReturnType<LinkResolverFunctionReturnType, Field> => {\n\tif (!linkFieldOrDocument) {\n\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>;\n\t}\n\n\t// Converts document to link field if needed\n\tconst linkField =\n\t\t// prettier-ignore\n\t\t(\n\t\t\t// @ts-expect-error - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501\n\t\t\t// TODO: Remove the `prettier-ignore` comment when this bug is fixed.\n\t\t\t\"link_type\" in linkFieldOrDocument\n\t\t\t\t? linkFieldOrDocument\n\t\t\t\t: documentToLinkField(linkFieldOrDocument)\n\t\t) as LinkField;\n\n\tswitch (linkField.link_type) {\n\t\tcase LinkType.Media:\n\t\tcase LinkType.Web:\n\t\t\treturn (\"url\" in linkField ? linkField.url : null) as AsLinkReturnType<\n\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\tField\n\t\t\t>;\n\n\t\tcase LinkType.Document: {\n\t\t\tif (\"id\" in linkField && linkResolver) {\n\t\t\t\t// When using Link Resolver...\n\t\t\t\tconst resolvedURL = linkResolver(linkField);\n\n\t\t\t\tif (resolvedURL != null) {\n\t\t\t\t\treturn resolvedURL as AsLinkReturnType<\n\t\t\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\t\t\tField\n\t\t\t\t\t>;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\"url\" in linkField && linkField.url) {\n\t\t\t\t// When using Route Resolver...\n\t\t\t\treturn linkField.url as AsLinkReturnType<\n\t\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\t\tField\n\t\t\t\t>;\n\t\t\t}\n\n\t\t\t// When empty or Link Resolver and Route Resolver are not used...\n\t\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>;\n\t\t}\n\n\t\tcase LinkType.Any:\n\t\tdefault:\n\t\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>;\n\t}\n};\n", "import { asText as baseAsText } from \"@prismicio/richtext\";\nimport { RichTextField } from \"@prismicio/types\";\n\n/**\n * The return type of `asText()`.\n */\ntype AsTextReturnType<Field extends RichTextField | null | undefined> =\n\tField extends RichTextField ? string : null;\n\n/**\n * Serializes a rich text or title field to a plain text string\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param separator - Separator used to join each element, defaults to a space\n *\n * @returns Plain text equivalent of the provided rich text or title field\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const asText = <Field extends RichTextField | null | undefined>(\n\trichTextField: Field,\n\tseparator?: string,\n): AsTextReturnType<Field> => {\n\tif (richTextField) {\n\t\treturn baseAsText(richTextField, separator) as AsTextReturnType<Field>;\n\t} else {\n\t\treturn null as AsTextReturnType<Field>;\n\t}\n};\n", "import escapeHtml from \"escape-html\";\nimport {\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTPreformattedNode,\n\tRTImageNode,\n\tRTEmbedNode,\n\tRTLinkNode,\n\tLinkType,\n\tRichTextNodeType,\n} from \"@prismicio/types\";\n\nimport { asLink } from \"../asLink\";\nimport { LinkResolverFunction } from \"../types\";\n\nexport const getLabel = (node: RTBlockNode | RTInlineNode): string => {\n\treturn \"data\" in node && \"label\" in node.data\n\t\t? ` class=\"${node.data.label}\"`\n\t\t: \"\";\n};\n\nexport const serializeStandardTag = (\n\ttag: string,\n\tnode: RTBlockNode | RTInlineNode,\n\tchildren: string[],\n): string => {\n\treturn `<${tag}${getLabel(node)}>${children.join(\"\")}</${tag}>`;\n};\n\nexport const serializePreFormatted = (node: RTPreformattedNode): string => {\n\treturn `<pre${getLabel(node)}>${escapeHtml(node.text)}</pre>`;\n};\n\nexport const serializeImage = (\n\tlinkResolver: LinkResolverFunction<string> | undefined | null,\n\tnode: RTImageNode,\n): string => {\n\tlet imageTag = `<img src=\"${node.url}\" alt=\"${escapeHtml(node.alt)}\"${\n\t\tnode.copyright ? ` copyright=\"${escapeHtml(node.copyright)}\"` : \"\"\n\t} />`;\n\n\t// If the image has a link, we wrap it with an anchor tag\n\tif (node.linkTo) {\n\t\timageTag = serializeHyperlink(\n\t\t\tlinkResolver,\n\t\t\t{\n\t\t\t\ttype: RichTextNodeType.hyperlink,\n\t\t\t\tdata: node.linkTo,\n\t\t\t\tstart: 0,\n\t\t\t\tend: 0,\n\t\t\t},\n\t\t\t[imageTag],\n\t\t);\n\t}\n\n\treturn `<p class=\"block-img\">${imageTag}</p>`;\n};\n\nexport const serializeEmbed = (node: RTEmbedNode): string => {\n\treturn `<div data-oembed=\"${node.oembed.embed_url}\" data-oembed-type=\"${\n\t\tnode.oembed.type\n\t}\" data-oembed-provider=\"${node.oembed.provider_name}\"${getLabel(node)}>${\n\t\tnode.oembed.html\n\t}</div>`;\n};\n\nexport const serializeHyperlink = (\n\tlinkResolver: LinkResolverFunction | undefined | null,\n\tnode: RTLinkNode,\n\tchildren: string[],\n): string => {\n\tswitch (node.data.link_type) {\n\t\tcase LinkType.Web: {\n\t\t\treturn `<a href=\"${escapeHtml(node.data.url)}\" ${\n\t\t\t\tnode.data.target ? `target=\"${node.data.target}\" ` : \"\"\n\t\t\t}rel=\"noopener noreferrer\"${getLabel(node)}>${children.join(\"\")}</a>`;\n\t\t}\n\n\t\tcase LinkType.Document: {\n\t\t\treturn `<a href=\"${asLink(node.data, linkResolver)}\"${getLabel(\n\t\t\t\tnode,\n\t\t\t)}>${children.join(\"\")}</a>`;\n\t\t}\n\n\t\tcase LinkType.Media: {\n\t\t\treturn `<a href=\"${node.data.url}\"${getLabel(node)}>${children.join(\n\t\t\t\t\"\",\n\t\t\t)}</a>`;\n\t\t}\n\t}\n};\n\nexport const serializeSpan = (content?: string): string => {\n\treturn content ? escapeHtml(content).replace(/\\n/g, \"<br />\") : \"\";\n};\n", "import {\n\tserialize,\n\tElement,\n\tcomposeSerializers,\n\tRichTextFunctionSerializer,\n\tRichTextMapSerializer,\n\twrapMapSerializer,\n} from \"@prismicio/richtext\";\nimport { RichTextField } from \"@prismicio/types\";\n\nimport {\n\tserializeStandardTag,\n\tserializePreFormatted,\n\tserializeImage,\n\tserializeEmbed,\n\tserializeHyperlink,\n\tserializeSpan,\n} from \"./lib/serializerHelpers\";\nimport {\n\tHTMLFunctionSerializer,\n\tHTMLMapSerializer,\n\tLinkResolverFunction,\n} from \"./types\";\n\n/**\n * Creates a default HTML serializer with a given Link Resolver providing\n * sensible and safe defaults for every node type\n *\n * @internal\n */\nconst createDefaultHTMLSerializer = (\n\tlinkResolver: LinkResolverFunction<string> | undefined | null,\n): RichTextFunctionSerializer<string> => {\n\treturn (_type, node, text, children, _key) => {\n\t\tswitch (node.type) {\n\t\t\tcase Element.heading1:\n\t\t\t\treturn serializeStandardTag(\"h1\", node, children);\n\t\t\tcase Element.heading2:\n\t\t\t\treturn serializeStandardTag(\"h2\", node, children);\n\t\t\tcase Element.heading3:\n\t\t\t\treturn serializeStandardTag(\"h3\", node, children);\n\t\t\tcase Element.heading4:\n\t\t\t\treturn serializeStandardTag(\"h4\", node, children);\n\t\t\tcase Element.heading5:\n\t\t\t\treturn serializeStandardTag(\"h5\", node, children);\n\t\t\tcase Element.heading6:\n\t\t\t\treturn serializeStandardTag(\"h6\", node, children);\n\t\t\tcase Element.paragraph:\n\t\t\t\treturn serializeStandardTag(\"p\", node, children);\n\t\t\tcase Element.preformatted:\n\t\t\t\treturn serializePreFormatted(node);\n\t\t\tcase Element.strong:\n\t\t\t\treturn serializeStandardTag(\"strong\", node, children);\n\t\t\tcase Element.em:\n\t\t\t\treturn serializeStandardTag(\"em\", node, children);\n\t\t\tcase Element.listItem:\n\t\t\t\treturn serializeStandardTag(\"li\", node, children);\n\t\t\tcase Element.oListItem:\n\t\t\t\treturn serializeStandardTag(\"li\", node, children);\n\t\t\tcase Element.list:\n\t\t\t\treturn serializeStandardTag(\"ul\", node, children);\n\t\t\tcase Element.oList:\n\t\t\t\treturn serializeStandardTag(\"ol\", node, children);\n\t\t\tcase Element.image:\n\t\t\t\treturn serializeImage(linkResolver, node);\n\t\t\tcase Element.embed:\n\t\t\t\treturn serializeEmbed(node);\n\t\t\tcase Element.hyperlink:\n\t\t\t\treturn serializeHyperlink(linkResolver, node, children);\n\t\t\tcase Element.label:\n\t\t\t\treturn serializeStandardTag(\"span\", node, children);\n\t\t\tcase Element.span:\n\t\t\tdefault:\n\t\t\t\treturn serializeSpan(text);\n\t\t}\n\t};\n};\n\n/**\n * Wraps a map serializer into a regular function serializer. The given map\n * serializer should accept children as a string, not as an array of strings\n * like `@prismicio/richtext`'s `wrapMapSerializer`.\n *\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nconst wrapMapSerializerWithStringChildren = (\n\tmapSerializer: HTMLMapSerializer,\n): RichTextFunctionSerializer<string> => {\n\tconst modifiedMapSerializer = {} as RichTextMapSerializer<string>;\n\n\tfor (const tag in mapSerializer) {\n\t\tconst tagSerializer = mapSerializer[tag as keyof typeof mapSerializer];\n\n\t\tif (tagSerializer) {\n\t\t\tmodifiedMapSerializer[tag as keyof typeof mapSerializer] = (payload) => {\n\t\t\t\treturn tagSerializer({\n\t\t\t\t\t...payload,\n\t\t\t\t\t// @ts-expect-error - merging blockSerializer types causes TS to bail to a never type\n\t\t\t\t\tchildren: payload.children.join(\"\"),\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t}\n\n\treturn wrapMapSerializer(modifiedMapSerializer);\n};\n\n/**\n * The return type of `asHTML()`.\n */\ntype AsHTMLReturnType<Field extends RichTextField | null | undefined> =\n\tField extends RichTextField ? string : null;\n\n/**\n * Serializes a rich text or title field to an HTML string\n *\n * @param richTextField - A rich text or title field from Prismic\n * @param linkResolver - An optional link resolver function to resolve links,\n *   without it you're expected to use the `routes` options from the API\n * @param htmlSerializer - An optional serializer, unhandled cases will fallback\n *   to the default serializer\n *\n * @returns HTML equivalent of the provided rich text or title field\n * @see Templating rich text and title fields from Prismic {@link https://prismic.io/docs/technologies/templating-rich-text-and-title-fields-javascript}\n */\nexport const asHTML = <Field extends RichTextField | null | undefined>(\n\trichTextField: Field,\n\tlinkResolver?: LinkResolverFunction<string> | null,\n\thtmlSerializer?: HTMLFunctionSerializer | HTMLMapSerializer | null,\n): AsHTMLReturnType<Field> => {\n\tif (richTextField) {\n\t\tlet serializer: RichTextFunctionSerializer<string>;\n\t\tif (htmlSerializer) {\n\t\t\tserializer = composeSerializers(\n\t\t\t\ttypeof htmlSerializer === \"object\"\n\t\t\t\t\t? wrapMapSerializerWithStringChildren(htmlSerializer)\n\t\t\t\t\t: (type, node, text, children, key) =>\n\t\t\t\t\t\t\thtmlSerializer(type, node, text, children.join(\"\"), key),\n\t\t\t\tcreateDefaultHTMLSerializer(linkResolver),\n\t\t\t);\n\t\t} else {\n\t\t\tserializer = createDefaultHTMLSerializer(linkResolver);\n\t\t}\n\n\t\treturn serialize(richTextField, serializer).join(\n\t\t\t\"\",\n\t\t) as AsHTMLReturnType<Field>;\n\t} else {\n\t\treturn null as AsHTMLReturnType<Field>;\n\t}\n};\n", "import type {\n\tAnyOEmbed,\n\tAnyRegularField,\n\tColorField,\n\tDateField,\n\tEmbedField,\n\tGeoPointField,\n\tGroupField,\n\tImageField,\n\tImageFieldImage,\n\tIntegrationFields,\n\tKeyTextField,\n\tLinkField,\n\tLinkToMediaField,\n\tNumberField,\n\tRelationField,\n\tRichTextField,\n\tSelectField,\n\tSharedSlice,\n\tSlice,\n\tSliceZone,\n\tTimestampField,\n\tTitleField,\n} from \"@prismicio/types\";\n\n/**\n * Determines if a value is not nullish (i.e. not `null` or `undefined`). This\n * is used to check if nullable field values are filled.\n *\n * @param input - The value to check.\n *\n * @returns `true` if `input` is not nullish, `false` otherwise.\n */\nconst isNonNullish = <T>(input: T): input is NonNullable<T> => {\n\treturn input != null;\n};\n\n/**\n * Determines if an array is not empty. This is used to check if array-based\n * fields are filled.\n *\n * @param input - The array to check.\n *\n * @returns `true` if `input` has at least one element, `false` otherwise.\n */\nconst isNonEmptyArray = <T>(input: T[]): input is [T, ...T[]] => {\n\treturn !!input.length;\n};\n\n/**\n * Determines if a Rich Text field is filled.\n *\n * @param field - Rich Text field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const richText = (\n\tfield: RichTextField | null | undefined,\n): field is RichTextField<\"filled\"> => {\n\tif (!isNonNullish(field)) {\n\t\treturn false;\n\t} else if (field.length === 1 && \"text\" in field[0]) {\n\t\treturn !!field[0].text;\n\t} else {\n\t\treturn !!field.length;\n\t}\n};\n\n/**\n * Determines if a Title field is filled.\n *\n * @param field - Title field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const title = richText as (\n\tfield: TitleField | null | undefined,\n) => field is TitleField<\"filled\">;\n\n/**\n * Determines if an Image thumbnail is filled.\n *\n * @param thumbnail - Image thumbnail to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const imageThumbnail = (\n\tthumbnail: ImageFieldImage | null | undefined,\n): thumbnail is ImageFieldImage<\"filled\"> => {\n\treturn isNonNullish(thumbnail) && !!thumbnail.url;\n};\n\n/**\n * Determines if an Image field is filled.\n *\n * @param field - Image field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const image = imageThumbnail as <\n\tThumbnailNames extends string | null = never,\n>(\n\tfield: ImageField<ThumbnailNames> | null | undefined,\n) => field is ImageField<ThumbnailNames, \"filled\">;\n\n/**\n * Determines if a Link field is filled.\n *\n * @param field - Link field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const link = <\n\tTypeEnum,\n\tLangEnum,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown,\n>(\n\tfield: LinkField<TypeEnum, LangEnum, DataInterface> | null | undefined,\n): field is LinkField<TypeEnum, LangEnum, DataInterface, \"filled\"> => {\n\treturn isNonNullish(field) && (\"id\" in field || \"url\" in field);\n};\n\n/**\n * Determines if a Link to Media field is filled.\n *\n * @param field - Link to Media field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const linkToMedia = link as (\n\tfield: LinkToMediaField | null | undefined,\n) => field is LinkToMediaField<\"filled\">;\n\n/**\n * Determines if a Content Relationship field is filled.\n *\n * @param field - Content Relationship field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const contentRelationship = link as <\n\tTypeEnum,\n\tLangEnum,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown,\n>(\n\tfield: RelationField<TypeEnum, LangEnum, DataInterface> | null | undefined,\n) => field is RelationField<TypeEnum, LangEnum, DataInterface, \"filled\">;\n\n/**\n * Determines if a Date field is filled.\n *\n * @param field - Date field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const date = isNonNullish as (\n\tfield: DateField | null | undefined,\n) => field is DateField<\"filled\">;\n\n/**\n * Determines if a Timestamp field is filled.\n *\n * @param field - Timestamp field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const timestamp = isNonNullish as (\n\tfield: TimestampField | null | undefined,\n) => field is TimestampField<\"filled\">;\n\n/**\n * Determines if a Color field is filled.\n *\n * @param field - Color field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const color = isNonNullish as (\n\tfield: ColorField | null | undefined,\n) => field is ColorField<\"filled\">;\n\n/**\n * Determines if a Number field is filled.\n *\n * @param field - Number field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const number = isNonNullish as (\n\tfield: NumberField | null | undefined,\n) => field is NumberField<\"filled\">;\n\n/**\n * Determines if a Key Text field is filled.\n *\n * @param field - Key Text field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const keyText = (\n\tfield: KeyTextField | null | undefined,\n): field is KeyTextField<\"filled\"> => {\n\treturn isNonNullish(keyText) && !!field;\n};\n\n/**\n * Determines if a Select field is filled.\n *\n * @param field - Select field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const select = isNonNullish as <Enum extends string>(\n\tfield: SelectField<Enum> | null | undefined,\n) => field is SelectField<Enum, \"filled\">;\n\n/**\n * Determines if an Embed field is filled.\n *\n * @param field - Embed field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const embed = <Field extends EmbedField<AnyOEmbed>>(\n\tfield: Field | null | undefined,\n): field is Extract<Field, EmbedField<AnyOEmbed, \"filled\">> => {\n\treturn isNonNullish(field) && !!field.embed_url;\n};\n\n/**\n * Determines if a GeoPoint field is filled.\n *\n * @param field - GeoPoint field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const geoPoint = (\n\tfield: GeoPointField | null | undefined,\n): field is GeoPointField<\"filled\"> => {\n\treturn isNonNullish(field) && \"longitude\" in field;\n};\n\n/**\n * Determines if an Integration Fields field is filled.\n *\n * @param field - Integration Fields field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const integrationFields = isNonNullish as <\n\tData extends Record<string, unknown>,\n>(\n\tfield: IntegrationFields<Data> | null | undefined,\n) => field is IntegrationFields<Data, \"filled\">;\n\n/**\n * Determines if a Group has at least one item.\n *\n * @param group - Group to check.\n *\n * @returns `true` if `group` contains at least one item, `false` otherwise.\n */\nexport const group = <Fields extends Record<string, AnyRegularField>>(\n\tgroup: GroupField<Fields> | null | undefined,\n): group is GroupField<Fields, \"filled\"> => {\n\treturn isNonNullish(group) && isNonEmptyArray(group);\n};\n\n/**\n * Determines if a Slice Zone has at least one Slice.\n *\n * @param slices - Slice Zone to check.\n *\n * @returns `true` if `slices` contains at least one Slice, `false` otherwise.\n */\nexport const sliceZone = <Slices extends Slice | SharedSlice>(\n\tslices: SliceZone<Slices> | null | undefined,\n): slices is SliceZone<Slices, \"filled\"> => {\n\treturn isNonNullish(slices) && isNonEmptyArray(slices);\n};\n", "import { ImageFieldImage } from \"@prismicio/types\";\nimport { buildURL, ImgixURLParams } from \"imgix-url-builder\";\n\nimport { imageThumbnail as isImageThumbnailFilled } from \"./isFilled\";\n\n/**\n * The return type of `asImageSrc()`.\n */\ntype AsImageSrcReturnType<Field extends ImageFieldImage | null | undefined> =\n\tField extends ImageFieldImage<\"filled\"> ? string : null;\n\n/**\n * Returns the URL of an Image field with optional image transformations (via\n * Imgix URL parameters).\n *\n * @example\n *\n * ```ts\n * const src = asImageSrc(document.data.imageField, { sat: -100 });\n * // => https://images.prismic.io/repo/image.png?sat=-100\n * ```\n *\n * @param field - Image field (or one of its responsive views) from which to get\n *   an image URL.\n * @param params - An object of Imgix URL API parameters to transform the image.\n *\n * @returns The Image field's image URL with transformations applied (if given).\n *   If the Image field is empty, `null` is returned.\n * @see Imgix URL parameters reference: https://docs.imgix.com/apis/rendering\n */\nexport const asImageSrc = <Field extends ImageFieldImage | null | undefined>(\n\tfield: Field,\n\tparams: ImgixURLParams = {},\n): AsImageSrcReturnType<Field> => {\n\tif (field && isImageThumbnailFilled(field)) {\n\t\treturn buildURL(field.url, params) as AsImageSrcReturnType<Field>;\n\t} else {\n\t\treturn null as AsImageSrcReturnType<Field>;\n\t}\n};\n", "import { ImageFieldImage } from \"@prismicio/types\";\nimport {\n\tbuildURL,\n\tbuildWidthSrcSet,\n\tBuildWidthSrcSetParams,\n} from \"imgix-url-builder\";\n\nimport { imageThumbnail as isImageThumbnailFilled } from \"./isFilled\";\n\n/**\n * The default widths used to generate a `srcset` value.\n */\nconst DEFAULT_WIDTHS = [640, 828, 1200, 2048, 3840];\n\n/**\n * The return type of `asImageWidthSrcSet()`.\n */\ntype AsImageWidthSrcSetReturnType<\n\tField extends ImageFieldImage | null | undefined,\n> = Field extends ImageFieldImage<\"filled\">\n\t? {\n\t\t\t/**\n\t\t\t * The Image field's image URL with Imgix URL parameters (if given).\n\t\t\t */\n\t\t\tsrc: string;\n\n\t\t\t/**\n\t\t\t * A width-based `srcset` attribute value for the Image field's image with\n\t\t\t * Imgix URL parameters (if given).\n\t\t\t */\n\t\t\tsrcset: string;\n\t  }\n\t: null;\n\n/**\n * Configuration for `asImageWidthSrcSet()`.\n */\ntype AsImageWidthSrcSetConfig = Omit<BuildWidthSrcSetParams, \"widths\"> & {\n\twidths?: \"thumbnails\" | BuildWidthSrcSetParams[\"widths\"];\n};\n\n/**\n * Creates a width-based `srcset` from an Image field with optional image\n * transformations (via Imgix URL parameters).\n *\n * If a `widths` parameter is not given, the following widths will be used by\n * default: 640, 750, 828, 1080, 1200, 1920, 2048, 3840.\n *\n * If the Image field contains responsive views, each responsive view can be\n * used as a width in the resulting `srcset` by passing `\"thumbnails\"` as the\n * `widths` parameter.\n *\n * @example\n *\n * ```ts\n * const srcset = asImageWidthSrcSet(document.data.imageField, {\n * \twidths: [400, 800, 1600],\n * \tsat: -100,\n * });\n * // => {\n * //   src:    'https://images.prismic.io/repo/image.png?sat=-100',\n * //   srcset: 'https://images.prismic.io/repo/image.png?sat=-100&width=400 400w, ' +\n * //           'https://images.prismic.io/repo/image.png?sat=-100&width=800 800w,' +\n * //           'https://images.prismic.io/repo/image.png?sat=-100&width=1600 1600w'\n * // }\n * ```\n *\n * @param field - Image field (or one of its responsive views) from which to get\n *   an image URL.\n * @param params - An object of Imgix URL API parameters. The `widths` parameter\n *   defines the resulting `srcset` widths. Pass `\"thumbnails\"` to automatically\n *   use the field's responsive views.\n *\n * @returns A `srcset` attribute value for the Image field with Imgix URL\n *   parameters (if given). If the Image field is empty, `null` is returned.\n * @see Imgix URL parameters reference: https://docs.imgix.com/apis/rendering\n */\nexport const asImageWidthSrcSet = <\n\tField extends ImageFieldImage | null | undefined,\n>(\n\tfield: Field,\n\tparams: AsImageWidthSrcSetConfig = {},\n): AsImageWidthSrcSetReturnType<Field> => {\n\tif (field && isImageThumbnailFilled(field)) {\n\t\t// We are using destructuring to omit `widths` from the object\n\t\t// we will pass to `buildURL()`.\n\t\tlet {\n\t\t\twidths = DEFAULT_WIDTHS,\n\t\t\t// eslint-disable-next-line prefer-const\n\t\t\t...imgixParams\n\t\t} = params;\n\t\tconst {\n\t\t\turl,\n\t\t\tdimensions,\n\t\t\talt: _alt,\n\t\t\tcopyright: _copyright,\n\t\t\t...responsiveViews\n\t\t} = field;\n\n\t\t// The Prismic Rest API will always return thumbnail values if\n\t\t// the base size is filled.\n\t\tconst responsiveViewObjects: ImageFieldImage<\"filled\">[] =\n\t\t\tObject.values(responsiveViews);\n\n\t\t// If this `asImageWidthSrcSet()` call is configured to use\n\t\t// thumbnail widths, but the field does not have thumbnails, we\n\t\t// fall back to the default set of widths.\n\t\tif (widths === \"thumbnails\" && responsiveViewObjects.length < 1) {\n\t\t\twidths = DEFAULT_WIDTHS;\n\t\t}\n\n\t\treturn {\n\t\t\tsrc: buildURL(url, imgixParams),\n\t\t\tsrcset:\n\t\t\t\t// By this point, we know `widths` can only be\n\t\t\t\t// `\"thubmanils\"` if the field has thumbnails.\n\t\t\t\twidths === \"thumbnails\"\n\t\t\t\t\t? [\n\t\t\t\t\t\t\tbuildWidthSrcSet(url, {\n\t\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\t\twidths: [dimensions.width],\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t...responsiveViewObjects.map((thumbnail) => {\n\t\t\t\t\t\t\t\treturn buildWidthSrcSet(thumbnail.url, {\n\t\t\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\t\t\twidths: [thumbnail.dimensions.width],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t  ].join(\", \")\n\t\t\t\t\t: buildWidthSrcSet(field.url, {\n\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\twidths,\n\t\t\t\t\t  }),\n\t\t} as AsImageWidthSrcSetReturnType<Field>;\n\t} else {\n\t\treturn null as AsImageWidthSrcSetReturnType<Field>;\n\t}\n};\n", "import { ImageFieldImage } from \"@prismicio/types\";\nimport {\n\tbuildPixelDensitySrcSet,\n\tBuildPixelDensitySrcSetParams,\n\tbuildURL,\n} from \"imgix-url-builder\";\n\nimport { imageThumbnail as isImageThumbnailFilled } from \"./isFilled\";\n\n/**\n * The default pixel densities used to generate a `srcset` value.\n */\nconst DEFAULT_PIXEL_DENSITIES = [1, 2, 3];\n\n/**\n * Configuration for `asImagePixelDensitySrcSet()`.\n */\ntype AsImagePixelDensitySrcSetConfig = Omit<\n\tBuildPixelDensitySrcSetParams,\n\t\"pixelDensities\"\n> &\n\tPartial<Pick<BuildPixelDensitySrcSetParams, \"pixelDensities\">>;\n\n/**\n * The return type of `asImagePixelDensitySrcSet()`.\n */\ntype AsImagePixelDensitySrcSetReturnType<\n\tField extends ImageFieldImage | null | undefined,\n> = Field extends ImageFieldImage<\"filled\">\n\t? {\n\t\t\t/**\n\t\t\t * The Image field's image URL with Imgix URL parameters (if given).\n\t\t\t */\n\t\t\tsrc: string;\n\n\t\t\t/**\n\t\t\t * A pixel-densitye-based `srcset` attribute value for the Image field's\n\t\t\t * image with Imgix URL parameters (if given).\n\t\t\t */\n\t\t\tsrcset: string;\n\t  }\n\t: null;\n\n/**\n * Creates a pixel-density-based `srcset` from an Image field with optional\n * image transformations (via Imgix URL parameters).\n *\n * If a `pixelDensities` parameter is not given, the following pixel densities\n * will be used by default: 1, 2, 3.\n *\n * @example\n *\n * ```ts\n * const srcset = asImagePixelDensitySrcSet(document.data.imageField, {\n * \tpixelDensities: [1, 2],\n * \tsat: -100,\n * });\n * // => {\n * //   src:    'https://images.prismic.io/repo/image.png?sat=-100',\n * //   srcset: 'https://images.prismic.io/repo/image.png?sat=-100&dpr=1 1x, ' +\n * //           'https://images.prismic.io/repo/image.png?sat=-100&dpr=2 2x'\n * // }\n * ```\n *\n * @param field - Image field (or one of its responsive views) from which to get\n *   an image URL.\n * @param params - An object of Imgix URL API parameters. The `pixelDensities`\n *   parameter defines the resulting `srcset` widths.\n *\n * @returns A `srcset` attribute value for the Image field with Imgix URL\n *   parameters (if given). If the Image field is empty, `null` is returned.\n * @see Imgix URL parameters reference: https://docs.imgix.com/apis/rendering\n */\nexport const asImagePixelDensitySrcSet = <\n\tField extends ImageFieldImage | null | undefined,\n>(\n\tfield: Field,\n\tparams: AsImagePixelDensitySrcSetConfig = {},\n): AsImagePixelDensitySrcSetReturnType<Field> => {\n\tif (field && isImageThumbnailFilled(field)) {\n\t\t// We are using destructuring to omit `pixelDensities` from the\n\t\t// object we will pass to `buildURL()`.\n\t\tconst { pixelDensities = DEFAULT_PIXEL_DENSITIES, ...imgixParams } = params;\n\n\t\treturn {\n\t\t\tsrc: buildURL(field.url, imgixParams),\n\t\t\tsrcset: buildPixelDensitySrcSet(field.url, {\n\t\t\t\t...imgixParams,\n\t\t\t\tpixelDensities,\n\t\t\t}),\n\t\t} as AsImagePixelDensitySrcSetReturnType<Field>;\n\t} else {\n\t\treturn null as AsImagePixelDensitySrcSetReturnType<Field>;\n\t}\n};\n", "export { asDate } from \"./asDate\";\nexport { asLink } from \"./asLink\";\nexport { asText } from \"./asText\";\nexport { asHTML } from \"./asHTML\";\nexport { asImageSrc } from \"./asImageSrc\";\nexport { asImageWidthSrcSet } from \"./asImageWidthSrcSet\";\nexport { asImagePixelDensitySrcSet } from \"./asImagePixelDensitySrcSet\";\nexport * as isFilled from \"./isFilled\";\n\nexport { documentToLinkField } from \"./documentToLinkField\";\n\nimport { Element } from \"@prismicio/richtext\";\nexport { Element };\n/**\n * @deprecated Renamed to `Element` (without an \"s\").\n */\n// TODO: Remove in v3.\nexport const Elements = Element;\n\nexport type {\n\tLinkResolverFunction,\n\tHTMLFunctionSerializer,\n\tHTMLMapSerializer,\n} from \"./types\";\n", "/**\n * Determines if an input is a valid Prismic repository name.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic repository name, `false` otherwise.\n */\nexport const isRepositoryName = (input: string): boolean => {\n\treturn /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(input);\n};\n", "export class PrismicError<Response> extends Error {\n\turl?: string;\n\tresponse: Response;\n\n\tconstructor(\n\t\tmessage = \"An invalid API response was returned\",\n\t\turl: string | undefined,\n\t\tresponse: Response,\n\t) {\n\t\tsuper(message);\n\n\t\tthis.url = url;\n\t\tthis.response = response;\n\t}\n}\n", "import { isRepositoryName } from \"./isRepositoryName\";\nimport { PrismicError } from \"./PrismicError\";\n\n/**\n * Get a repository's Prismic Rest API V2 endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic Rest API V2 endpoint\n * @throws {@link Error} Thrown if an invalid repository name is provided.\n */\nexport const getRepositoryEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/api/v2` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/api/v2` as const;\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t}\n};\n", "import { PrismicError } from \"./PrismicError\";\n\n/**\n * Get a Prismic repository's name from its standard Prismic Rest API V2 or\n * GraphQL endpoint.\n *\n * @typeParam RepositoryEndpoint - Prismic Rest API V2 endpoint for the repository.\n * @param repositoryEndpoint - Prismic Rest API V2 endpoint for the repository.\n *\n * @returns The Prismic repository's name.\n * @throws {@link Error} Thrown if an invalid Prismic Rest API V2 endpoint is provided.\n */\nexport const getRepositoryName = (repositoryEndpoint: string): string => {\n\ttry {\n\t\treturn new URL(repositoryEndpoint).hostname.split(\".\")[0];\n\t} catch {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic Rest API V2 endpoint was provided: ${repositoryEndpoint}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t}\n};\n", "import { isRepositoryName } from \"./isRepositoryName\";\nimport { PrismicError } from \"./PrismicError\";\n\n/**\n * Get a repository's Prismic GraphQL endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic REST API V2 endpoint\n */\nexport const getGraphQLEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/graphql` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/graphql` as const;\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t}\n};\n", "/**\n * Determines if a string if a Prismic Rest API V2 endpoint. Note that any valid\n * URL is a valid endpoint to support network proxies.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic Rest API V2 endpoint, `false` otherwise.\n */\nexport const isRepositoryEndpoint = (input: string): boolean => {\n\ttry {\n\t\tnew URL(input);\n\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n};\n", "/**\n * Ensures that a value is an array. If it is already an array, it is returned\n * as is. If it is not an array, it is converted to an array with itself as its\n * only element.\n *\n * @typeParam A - Element of the array.\n * @param a - Value to ensure is an array.\n *\n * @returns `a` as an array.\n */\nexport const castArray = <A>(a: A | A[]): A[] => (Array.isArray(a) ? a : [a]);\n", "import { castArray } from \"./lib/castArray\";\n\nimport { ValueOf, Ordering, Route } from \"./types\";\n\n/**\n * Parameters for the Prismic REST API V2.\n *\n * {@link https://prismic.io/docs/technologies/introduction-to-the-content-query-api}\n */\nexport interface QueryParams {\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * The `pageSize` parameter defines the maximum number of documents that the\n\t * API will return for your query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#pagesize}\n\t */\n\tpageSize?: number;\n\n\t/**\n\t * The `page` parameter defines the pagination for the result of your query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#page}\n\t */\n\tpage?: number;\n\n\t/**\n\t * The `after` parameter can be used along with the orderings option. It will\n\t * remove all the documents except for those after the specified document in the list.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#after}\n\t */\n\tafter?: string;\n\n\t/**\n\t * The `fetch` parameter is used to make queries faster by only retrieving the\n\t * specified field(s).\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#fetch}\n\t */\n\tfetch?: string | string[];\n\n\t/**\n\t * The `fetchLinks` parameter allows you to retrieve a specific content field\n\t * from a linked document and add it to the document response object.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#fetchlinks}\n\t */\n\tfetchLinks?: string | string[];\n\n\t/**\n\t * The `graphQuery` parameter allows you to specify which fields to retrieve\n\t * and what content to retrieve from Linked Documents / Content Relationships.\n\t *\n\t * {@link https://prismic.io/docs/technologies/graphquery-rest-api}\n\t */\n\tgraphQuery?: string;\n\n\t/**\n\t * The `lang` option defines the language code for the results of your query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#lang}\n\t */\n\tlang?: string;\n\n\t/**\n\t * The `orderings` parameter orders the results by the specified field(s). You\n\t * can specify as many fields as you want.\n\t *\n\t * {@link https://prismic.io/docs/technologies/search-parameters-reference-rest-api#orderings}\n\t */\n\torderings?: Ordering | string | (Ordering | string)[];\n\n\t/**\n\t * The `routes` option allows you to define how a document's `url` field is resolved.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\troutes?: Route | string | (Route | string)[];\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken Link or Content Relationship fields. A broken\n\t * link is a Link or Content Relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\tbrokenRoute?: string;\n}\n\n/**\n * Arguments for `buildQueryURL` to construct a Query URL.\n */\ntype BuildQueryURLParams = {\n\t/**\n\t * Ref used to query documents.\n\t *\n\t * {@link https://prismic.io/docs/technologies/introduction-to-the-content-query-api#prismic-api-ref}\n\t */\n\tref: string;\n\n\t/**\n\t * Ref used to populate Integration Fields with the latest content.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/integration-fields}\n\t */\n\tintegrationFieldsRef?: string;\n\n\t/**\n\t * One or more predicates to filter documents for the query.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api}\n\t */\n\tpredicates?: string | string[];\n};\n\n/**\n * Parameters in this map have been renamed from the official Prismic REST API\n * V2 specification for better developer ergonomics.\n *\n * These parameters are renamed to their mapped value.\n */\nconst RENAMED_PARAMS = {\n\taccessToken: \"access_token\",\n} as const;\n\n/**\n * A valid parameter name for the Prismic REST API V2.\n */\ntype ValidParamName =\n\t| Exclude<\n\t\t\tkeyof QueryParams,\n\t\t\tkeyof typeof RENAMED_PARAMS | keyof BuildQueryURLParams\n\t  >\n\t| ValueOf<typeof RENAMED_PARAMS>;\n\n/**\n * Converts an Ordering to a string that is compatible with Prismic's REST API.\n * If the value provided is already a string, no conversion is performed.\n *\n * @param ordering - Ordering to convert.\n *\n * @returns String representation of the Ordering.\n */\nconst castOrderingToString = (ordering: Ordering | string): string =>\n\ttypeof ordering === \"string\"\n\t\t? ordering\n\t\t: [\n\t\t\t\tordering.field,\n\t\t\t\tordering.direction === \"desc\" ? ordering.direction : undefined,\n\t\t  ]\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.join(\" \");\n\nexport type BuildQueryURLArgs = QueryParams & BuildQueryURLParams;\n\n/**\n * Build a Prismic REST API V2 URL to request documents from a repository. The\n * paginated response for this URL includes documents matching the parameters.\n *\n * A ref is required to make a request. Request the `endpoint` URL to retrieve a\n * list of available refs.\n *\n * Type the JSON response with `Query`.\n *\n * {@link https://prismic.io/docs/technologies/introduction-to-the-content-query-api#prismic-api-ref}\n * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api}\n *\n * @param endpoint - URL to the repository's REST API V2.\n * @param args - Arguments to filter and scope the query.\n *\n * @returns URL that can be used to request documents from the repository.\n */\nexport const buildQueryURL = (\n\tendpoint: string,\n\targs: BuildQueryURLArgs,\n): string => {\n\tconst { predicates, ...params } = args;\n\n\tconst url = new URL(`documents/search`, `${endpoint}/`);\n\n\tif (predicates) {\n\t\tfor (const predicate of castArray(predicates)) {\n\t\t\turl.searchParams.append(\"q\", `[${predicate}]`);\n\t\t}\n\t}\n\n\t// Iterate over each parameter and add it to the URL. In some cases, the\n\t// parameter value needs to be transformed to fit the REST API.\n\tfor (const k in params) {\n\t\tconst name = (RENAMED_PARAMS[k as keyof typeof RENAMED_PARAMS] ??\n\t\t\tk) as ValidParamName;\n\n\t\tlet value = params[k as keyof typeof params];\n\n\t\tif (name === \"orderings\") {\n\t\t\tconst scopedValue = params[name];\n\n\t\t\tif (scopedValue != null) {\n\t\t\t\tconst v = castArray(scopedValue)\n\t\t\t\t\t.map((ordering) => castOrderingToString(ordering))\n\t\t\t\t\t.join(\",\");\n\n\t\t\t\tvalue = `[${v}]`;\n\t\t\t}\n\t\t} else if (name === \"routes\") {\n\t\t\tif (typeof params[name] === \"object\") {\n\t\t\t\tvalue = JSON.stringify(castArray(params[name]));\n\t\t\t}\n\t\t}\n\n\t\tif (value != null) {\n\t\t\turl.searchParams.set(name, castArray(value).join(\",\"));\n\t\t}\n\t}\n\n\treturn url.toString();\n};\n", "import { castArray } from \"./castArray\";\n\ninterface WithPredicates {\n\tpredicates?: string | string[];\n}\n\n/**\n * Adds one or more predicates to an object with a `predicates` property.\n * Appended predicates are added to the end of the existing list.\n *\n * @typeParam T - Object to which predicates will be append.\n * @param objWithPredicates - Object to append predicates on the `predicates` property.\n * @param predicates - One or more predicates to append.\n *\n * @returns The object with the appended predicates.\n */\nexport const appendPredicates = <T extends WithPredicates>(\n\tobjWithPredicates: T = {} as T,\n\tpredicates: string | string[],\n) => {\n\treturn {\n\t\t...objWithPredicates,\n\t\tpredicates: [\n\t\t\t...(objWithPredicates.predicates || []),\n\t\t\t...castArray(predicates),\n\t\t],\n\t};\n};\n", "/**\n * Ensures that a value is a thunk. If it is already a thunk, it is returned as\n * is. If it is not a thunk, it is converted to a thunk.\n *\n * @typeParam A - Value returned by the thunk.\n * @param a - Value to ensure is a thunk.\n *\n * @returns `a` as a a thunk.\n */\nexport const castThunk = <A>(a: A | (() => A)): (() => A) =>\n\ttypeof a === \"function\" ? (a as () => A) : () => a;\n", "import * as prismicT from \"@prismicio/types\";\n\nimport { PrismicError } from \"../PrismicError\";\n\n/**\n * Returns the first ref from a list that passes a predicate (a function that\n * returns true).\n *\n * @param refs - A list of refs to search.\n * @param predicate - A function that determines if a ref from the list matches\n *   the criteria.\n *\n * @returns The first matching ref.\n * @throws If a matching ref cannot be found.\n */\nexport const findRef = (\n\trefs: prismicT.Ref[],\n\tpredicate: (ref: prismicT.Ref) => boolean,\n): prismicT.Ref => {\n\tconst ref = refs.find((ref) => predicate(ref));\n\n\tif (!ref) {\n\t\tthrow new PrismicError(\"Ref could not be found.\", undefined, undefined);\n\t}\n\n\treturn ref;\n};\n", "import * as prismicT from \"@prismicio/types\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the master ref from a list of given refs.\n *\n * @param refs - A list of refs to search.\n *\n * @returns The master ref from the list.\n * @throws If a matching ref cannot be found.\n */\nexport const findMasterRef = (refs: prismicT.Ref[]): prismicT.Ref => {\n\treturn findRef(refs, (ref) => ref.isMasterRef);\n};\n", "import * as prismicT from \"@prismicio/types\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the ref from a list of given refs with a matching ID.\n *\n * @param refs - A list of refs to search.\n * @param id - The ID of the ref to find.\n *\n * @returns The ref with a matching ID from the list.\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByID = (refs: prismicT.Ref[], id: string): prismicT.Ref => {\n\treturn findRef(refs, (ref) => ref.id === id);\n};\n", "import * as prismicT from \"@prismicio/types\";\n\nimport { findRef } from \"./findRef\";\n\n/**\n * Returns the ref from a list of given refs with a matching label.\n *\n * @param refs - A list of refs to search.\n * @param id - The label of the ref to find.\n *\n * @returns The ref with a matching label from the list.\n * @throws If a matching ref cannot be found.\n */\nexport const findRefByLabel = (\n\trefs: prismicT.Ref[],\n\tlabel: string,\n): prismicT.Ref => {\n\treturn findRef(refs, (ref) => ref.label === label);\n};\n", "/**\n * The well-known name of the cookie used to store a Prismic preview session's ref.\n */\nexport const preview = \"io.prismic.preview\";\n", "import { preview as previewCookieName } from \"../cookie\";\n\nconst readValue = (value: string): string => {\n\treturn value.replace(/%3B/g, \";\");\n};\n\n/**\n * Returns the value of a cookie from a given cookie store.\n *\n * @param cookieJar - The stringified cookie store from which to read the cookie.\n *\n * @returns The value of the cookie, if it exists.\n */\nexport const getPreviewCookie = (cookieJar: string): string | undefined => {\n\tconst cookies = cookieJar.split(\"; \");\n\n\tlet value: string | undefined;\n\n\tfor (const cookie of cookies) {\n\t\tconst parts = cookie.split(\"=\");\n\t\tconst name = readValue(parts[0]).replace(/%3D/g, \"=\");\n\n\t\tif (name === previewCookieName) {\n\t\t\tvalue = readValue(parts.slice(1).join(\"=\"));\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn value;\n};\n", "/**\n * Minifies a GraphQL query by removing whitespace where possible.\n *\n * @param query - GraphQL query to minify.\n *\n * @returns A minified version of `query`.\n */\nexport const minifyGraphQLQuery = (query: string): string => {\n\treturn query.replace(\n\t\t/(\\n| )*( |{|})(\\n| )*/gm,\n\t\t(_chars, _spaces, brackets) => brackets,\n\t);\n};\n", "import { PrismicError } from \"./PrismicError\";\n\ntype ForbiddenErrorRepositoryAPIResponse = {\n\ttype: string;\n\tmessage: string;\n};\n\ntype ForbiddenErrorQueryAPIResponse = {\n\terror: string;\n};\n\nexport class ForbiddenError extends PrismicError<\n\tForbiddenErrorRepositoryAPIResponse | ForbiddenErrorQueryAPIResponse\n> {}\n", "import { PrismicError } from \"./PrismicError\";\n\nexport class NotFoundError extends PrismicError<undefined> {}\n", "import { PrismicError } from \"./PrismicError\";\n\ntype ParsingErrorAPIResponse = {\n\ttype: \"parsing-error\";\n\tmessage: string;\n\tline: number;\n\tcolumn: number;\n\tid: number;\n\tlocation: string;\n};\n\nexport class ParsingError extends PrismicError<ParsingErrorAPIResponse> {}\n", "/**\n * Formats the value of a predicate element to a stringified version accepted by\n * the Prismic REST API.\n *\n * @param value - Value to format.\n *\n * @returns `value` formatted for the Prismic REST API.\n */\nconst formatValue = (\n\tvalue:\n\t\t| string\n\t\t| number\n\t\t| Date\n\t\t| unknown\n\t\t| (string | number | Date | unknown)[],\n): string => {\n\tif (Array.isArray(value)) {\n\t\treturn `[${value.map(formatValue).join(\", \")}]`;\n\t}\n\n\tif (typeof value === \"string\") {\n\t\treturn `\"${value}\"`;\n\t}\n\n\tif (value instanceof Date) {\n\t\treturn `${value.getTime()}`;\n\t}\n\n\treturn `${value}`;\n};\n\n/**\n * Creates a predicate builder function for predicates with a path and arguments.\n *\n * @typeParam Args - Arguments for the predicate.\n * @param name - Name of the predicate used in the resulting string.\n *\n * @returns Predicate builder function for the given name.\n */\nconst pathWithArgsPredicate = <Args extends unknown[]>(name: string) => {\n\t/**\n\t * @param path - Path to the value to be compared.\n\t */\n\tconst fn = (path: string, ...args: Args): string => {\n\t\tconst formattedArgs = args.map(formatValue).join(\", \");\n\t\tconst joiner = path && args.length ? \", \" : \"\";\n\n\t\treturn `[${name}(${path}${joiner}${formattedArgs})]`;\n\t};\n\n\treturn fn;\n};\n\n/**\n * Creates a predicate builder function for predicates with only a path.\n *\n * @param name - Name of the predicate used in the resulting string.\n *\n * @returns Predicate builder function for the given name.\n */\nconst pathPredicate = (name: string) => {\n\tconst predicateFn = pathWithArgsPredicate(name);\n\n\t/**\n\t * @param path - Path for the predicate.\n\t */\n\tconst fn = (path: string): string => {\n\t\treturn predicateFn(path);\n\t};\n\n\treturn fn;\n};\n\n/**\n * Creates a predicate builder function for predicates with only arguments and no path.\n *\n * @param name - Name of the predicate used in the resulting string.\n *\n * @returns Predicate builder function for the given name.\n */\nconst argsPredicate = <Args extends unknown[]>(name: string) => {\n\tconst predicateFn = pathWithArgsPredicate<Args>(name);\n\n\t/**\n\t * @param args - Arguments for the predicate.\n\t */\n\tconst fn = (...args: Args): string => {\n\t\treturn predicateFn(\"\", ...args);\n\t};\n\n\treturn fn;\n};\n\nexport const predicate = {\n\t/**\n\t * The `at` predicate checks that the path matches the described value\n\t * exactly. It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#at}\n\t */\n\tat: pathWithArgsPredicate<\n\t\t[value: string | number | boolean | Date | string[]]\n\t>(\"at\"),\n\n\t/**\n\t * The `not` predicate checks that the path doesn't match the provided value\n\t * exactly. It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#not}\n\t */\n\tnot: pathWithArgsPredicate<\n\t\t[value: string | number | boolean | Date | string[]]\n\t>(\"not\"),\n\n\t/**\n\t * The `any` predicate takes an array of values. It works exactly the same way\n\t * as the `at` operator, but checks whether the fragment matches any of the\n\t * values in the array.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#any}\n\t */\n\tany: pathWithArgsPredicate<[values: (string | number | boolean | Date)[]]>(\n\t\t\"any\",\n\t),\n\n\t/**\n\t * The `in` predicate is used specifically to retrieve an array of documents\n\t * by their IDs or UIDs. This predicate is much more efficient at this than\n\t * the any predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#in}\n\t */\n\tin: pathWithArgsPredicate<[values: string[]]>(\"in\"),\n\n\t/**\n\t * The `fulltext` predicate provides two capabilities:\n\t *\n\t * 1. Checking if a certain string is anywhere inside a document (this is what\n\t *    you should use to make your project's search engine feature)\n\t * 2. Checking if the string is contained inside a specific custom types Rich\n\t *    Text or Key Text fragment.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#fulltext}\n\t */\n\tfulltext: pathWithArgsPredicate<[searchTerms: string]>(\"fulltext\"),\n\n\t/**\n\t * The `has` predicate checks whether a fragment has a value. It will return\n\t * all the documents of the specified type that contain a value for the\n\t * specified field.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#has}\n\t */\n\thas: pathPredicate(\"has\"),\n\n\t/**\n\t * The `missing` predicate checks if a fragment doesn't have a value. It will\n\t * return all the documents of the specified type that do not contain a value\n\t * for the specified field.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#missing}\n\t */\n\tmissing: pathPredicate(\"missing\"),\n\n\t/**\n\t * The `similar` predicate takes the ID of a document, and returns a list of\n\t * documents with similar content. This allows you to build an automated\n\t * content discovery feature (for example, a \"Related posts\" section).\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#similar}\n\t */\n\tsimilar: argsPredicate<[id: string, value: number]>(\"similar\"),\n\n\t/**\n\t * The `geopoint.near` predicate checks that the value in the path is within\n\t * the radius of the given coordinates.\n\t *\n\t * This predicate will only work for a GeoPoint field.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#near}\n\t */\n\tgeopointNear:\n\t\tpathWithArgsPredicate<\n\t\t\t[latitude: number, longitude: number, radius: number]\n\t\t>(\"geopoint.near\"),\n\n\t/**\n\t * The `number.lt` predicate checks that the value in the number field is less\n\t * than the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#lt-less-than}\n\t */\n\tnumberLessThan: pathWithArgsPredicate<[value: number]>(\"number.lt\"),\n\n\t/**\n\t * The `number.gt` predicate checks that the value in the number field is\n\t * greater than the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#gt-greater-than}\n\t */\n\tnumberGreaterThan: pathWithArgsPredicate<[value: number]>(\"number.gt\"),\n\n\t/**\n\t * The `number.inRange` predicate checks that the value in the path is within\n\t * the two values passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/query-predicates-reference-rest-api#inrange}\n\t */\n\tnumberInRange:\n\t\tpathWithArgsPredicate<[lowerLimit: number, upperLimit: number]>(\n\t\t\t\"number.inRange\",\n\t\t),\n\n\t/**\n\t * The `date.after` predicate checks that the value in the path is after the\n\t * date value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#after}\n\t */\n\tdateAfter:\n\t\tpathWithArgsPredicate<[date: string | number | Date]>(\"date.after\"),\n\n\t/**\n\t * The `date.before` predicate checks that the value in the path is before the\n\t * date value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#before}\n\t */\n\tdateBefore:\n\t\tpathWithArgsPredicate<[date: string | number | Date]>(\"date.before\"),\n\n\t/**\n\t * The `date.between` predicate checks that the value in the path is within\n\t * the date values passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#between}\n\t */\n\tdateBetween:\n\t\tpathWithArgsPredicate<\n\t\t\t[startDate: string | number | Date, endDate: string | number | Date]\n\t\t>(\"date.between\"),\n\n\t/**\n\t * The `date.day-of-month` predicate checks that the value in the path is\n\t * equal to the day of the month passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofmonth}\n\t */\n\tdateDayOfMonth: pathWithArgsPredicate<[day: number]>(\"date.day-of-month\"),\n\n\t/**\n\t * The `date.day-of-month-after` predicate checks that the value in the path\n\t * is after the day of the month passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofmonthafter}\n\t */\n\tdateDayOfMonthAfter: pathWithArgsPredicate<[day: number]>(\n\t\t\"date.day-of-month-after\",\n\t),\n\n\t/**\n\t * The `date.day-of-month-before` predicate checks that the value in the path\n\t * is before the day of the month passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofmonthbefore}\n\t */\n\tdateDayOfMonthBefore: pathWithArgsPredicate<[day: number]>(\n\t\t\"date.day-of-month-before\",\n\t),\n\n\t/**\n\t * The `date.day-of-week` predicate checks that the value in the path is equal\n\t * to the day of the week passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofweek}\n\t */\n\tdateDayOfWeek:\n\t\tpathWithArgsPredicate<[day: string | number]>(\"date.day-of-week\"),\n\n\t/**\n\t * The `date.day-of-week-after` predicate checks that the value in the path is\n\t * after the day of the week passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofweekafter}\n\t */\n\tdateDayOfWeekAfter: pathWithArgsPredicate<[day: string | number]>(\n\t\t\"date.day-of-week-after\",\n\t),\n\n\t/**\n\t * The date.day-of-week-before predicate checks that the value in the path is\n\t * before the day of the week passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#dayofweekbefore}\n\t */\n\tdateDayOfWeekBefore: pathWithArgsPredicate<[day: string | number]>(\n\t\t\"date.day-of-week-before\",\n\t),\n\n\t/**\n\t * The `date.month` predicate checks that the value in the path occurs in the\n\t * month value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#month}\n\t */\n\tdateMonth: pathWithArgsPredicate<[month: string | number]>(\"date.month\"),\n\n\t/**\n\t * The `date.month-after` predicate checks that the value in the path occurs\n\t * in any month after the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#monthafter}\n\t */\n\tdateMonthAfter:\n\t\tpathWithArgsPredicate<[month: string | number]>(\"date.month-after\"),\n\n\t/**\n\t * The `date.month-before` predicate checks that the value in the path occurs\n\t * in any month before the value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#monthbefore}\n\t */\n\tdateMonthBefore:\n\t\tpathWithArgsPredicate<[month: string | number]>(\"date.month-before\"),\n\n\t/**\n\t * The `date.year` predicate checks that the value in the path occurs in the\n\t * year value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#year}\n\t */\n\tdateYear: pathWithArgsPredicate<[year: number]>(\"date.year\"),\n\n\t/**\n\t * The `date.hour` predicate checks that the value in the path occurs within\n\t * the hour value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#hour}\n\t */\n\tdateHour: pathWithArgsPredicate<[hour: number]>(\"date.hour\"),\n\n\t/**\n\t * The `date.hour-after` predicate checks that the value in the path occurs\n\t * after the hour value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#hourafter}\n\t */\n\tdateHourAfter: pathWithArgsPredicate<[hour: number]>(\"date.hour-after\"),\n\n\t/**\n\t * The `date.hour-before` predicate checks that the value in the path occurs\n\t * before the hour value passed into the predicate.\n\t *\n\t * {@link https://prismic.io/docs/technologies/date-and-time-based-predicate-reference-rest-api#hourbefore}\n\t */\n\tdateHourBefore: pathWithArgsPredicate<[hour: number]>(\"date.hour-before\"),\n};\n", "import * as prismicT from \"@prismicio/types\";\nimport * as prismicH from \"@prismicio/helpers\";\n\nimport { appendPredicates } from \"./lib/appendPredicates\";\nimport { castArray } from \"./lib/castArray\";\nimport { castThunk } from \"./lib/castThunk\";\nimport { findMasterRef } from \"./lib/findMasterRef\";\nimport { findRefByID } from \"./lib/findRefByID\";\nimport { findRefByLabel } from \"./lib/findRefByLabel\";\nimport { getPreviewCookie } from \"./lib/getPreviewCookie\";\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery\";\n\nimport {\n\tAbortSignalLike,\n\tFetchLike,\n\tHttpRequestLike,\n\tExtractDocumentType,\n} from \"./types\";\nimport { ForbiddenError } from \"./ForbiddenError\";\nimport { NotFoundError } from \"./NotFoundError\";\nimport { ParsingError } from \"./ParsingError\";\nimport { PrismicError } from \"./PrismicError\";\nimport { buildQueryURL, BuildQueryURLArgs } from \"./buildQueryURL\";\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\";\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\";\nimport { predicate } from \"./predicate\";\n\n/**\n * The largest page size allowed by the Prismic REST API V2. This value is used\n * to minimize the number of requests required to query content.\n */\nconst MAX_PAGE_SIZE = 100;\n\n/**\n * The number of milliseconds in which repository metadata is considered valid.\n * A ref can be invalidated quickly depending on how frequently content is\n * updated in the Prismic repository. As such, repository's metadata can only be\n * considered valid for a short amount of time.\n */\nexport const REPOSITORY_CACHE_TTL = 5000;\n\n/**\n * The number of milliseconds in which a multi-page `getAll` (e.g. `getAll`,\n * `getAllByType`, `getAllByTag`) will wait between individual page requests.\n *\n * This is done to ensure API performance is sustainable and reduces the chance\n * of a failed API request due to overloading.\n */\nexport const GET_ALL_QUERY_DELAY = 500;\n\n/**\n * Modes for client ref management.\n */\nenum RefStateMode {\n\t/**\n\t * Use the repository's master ref.\n\t */\n\tMaster = \"Master\",\n\n\t/**\n\t * Use a given Release identified by its ID.\n\t */\n\tReleaseID = \"ReleaseID\",\n\n\t/**\n\t * Use a given Release identified by its label.\n\t */\n\tReleaseLabel = \"ReleaseLabel\",\n\n\t/**\n\t * Use a given ref.\n\t */\n\tManual = \"Manual\",\n}\n\n/**\n * An object containing stateful information about a client's ref strategy.\n */\ntype RefState = {\n\t/**\n\t * Determines if automatic preview support is enabled.\n\t */\n\tautoPreviewsEnabled: boolean;\n\n\t/**\n\t * An optional HTTP server request object used during previews if automatic\n\t * previews are enabled.\n\t */\n\thttpRequest?: HttpRequestLike;\n} & (\n\t| {\n\t\t\tmode: RefStateMode.Master;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseID;\n\t\t\treleaseID: string;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseLabel;\n\t\t\treleaseLabel: string;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.Manual;\n\t\t\tref: RefStringOrThunk;\n\t  }\n);\n\n/**\n * A ref or a function that returns a ref. If a static ref is known, one can be\n * given. If the ref must be fetched on-demand, a function can be provided. This\n * function can optionally be asynchronous.\n */\ntype RefStringOrThunk =\n\t| string\n\t| (() => string | undefined | Promise<string | undefined>);\n\n/**\n * Configuration for clients that determine how content is queried.\n */\nexport type ClientConfig = {\n\t/**\n\t * The secure token for accessing the Prismic repository. This is only\n\t * required if the repository is set to private.\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * A string representing a version of the Prismic repository's content. This\n\t * may point to the latest version (called the \"master ref\"), or a preview\n\t * with draft content.\n\t */\n\tref?: RefStringOrThunk;\n\n\t/**\n\t * A list of Route Resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>;\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken Link or Content Relationship fields. A broken\n\t * link is a Link or Content Relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>;\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\" | \"brokenRoute\"\n\t>;\n\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetch?: FetchLike;\n};\n\n/**\n * Parameters for any client method that use `fetch()`. Only a subset of\n * `fetch()` parameters are exposed.\n */\ntype FetchParams = {\n\t/**\n\t * An `AbortSignal` provided by an `AbortController`. This allows the network\n\t * request to be cancelled if necessary.\n\t *\n\t * {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}\n\t */\n\tsignal?: AbortSignalLike;\n};\n\n/**\n * Parameters specific to client methods that fetch all documents. These methods\n * start with `getAll` (for example, `getAllByType`).\n */\ntype GetAllParams = {\n\t/**\n\t * Limit the number of documents queried. If a number is not provided, there\n\t * will be no limit and all matching documents will be returned.\n\t */\n\tlimit?: number;\n};\n\n/**\n * Arguments to determine how the URL for a preview session is resolved.\n */\ntype ResolvePreviewArgs<LinkResolverReturnType> = {\n\t/**\n\t * A function that maps a Prismic document to a URL within your app.\n\t */\n\tlinkResolver?: prismicH.LinkResolverFunction<LinkResolverReturnType>;\n\n\t/**\n\t * A fallback URL if the Link Resolver does not return a value.\n\t */\n\tdefaultURL: string;\n\n\t/**\n\t * The preview token (also known as a ref) that will be used to query preview\n\t * content from the Prismic repository.\n\t */\n\tpreviewToken?: string;\n\n\t/**\n\t * The previewed document that will be used to determine the destination URL.\n\t */\n\tdocumentID?: string;\n};\n\n/**\n * Creates a predicate to filter content by document type.\n *\n * @param documentType - The document type to filter queried content.\n *\n * @returns A predicate that can be used in a Prismic REST API V2 request.\n */\nconst typePredicate = (documentType: string): string =>\n\tpredicate.at(\"document.type\", documentType);\n\n/**\n * Creates a predicate to filter content by document tags. All tags are required\n * on the document.\n *\n * @param tags - Document tags to filter queried content.\n *\n * @returns A predicate that can be used in a Prismic REST API V2 request.\n */\nconst everyTagPredicate = (tags: string | string[]): string =>\n\tpredicate.at(\"document.tags\", castArray(tags));\n\n/**\n * Creates a predicate to filter content by document tags. At least one matching\n * tag is required on the document.\n *\n * @param tags - Document tags to filter queried content.\n *\n * @returns A predicate that can be used in a Prismic REST API V2 request.\n */\nconst someTagsPredicate = (tags: string | string[]): string =>\n\tpredicate.any(\"document.tags\", castArray(tags));\n\n/**\n * Type definitions for the `createClient()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateClient {\n\t<TDocuments extends prismicT.PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof Client>\n\t): Client<TDocuments>;\n}\n\n/**\n * Creates a Prismic client that can be used to query a repository.\n *\n * @example\n *\n * ```ts\n * // With a repository name.\n * createClient(\"qwerty\");\n *\n * // Or with a full Prismic Rest API V2 endpoint.\n * createClient(\"https://qwerty.cdn.prismic.io/api/v2\");\n * ```\n *\n * @typeParam TDocuments - A map of Prismic document type IDs mapped to their\n *   TypeScript type.\n * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n *   API V2 endpoint for the repository.\n * @param options - Configuration that determines how content will be queried\n *   from the Prismic repository.\n *\n * @returns A client that can query content from the repository.\n */\nexport const createClient: CreateClient = <\n\tTDocuments extends prismicT.PrismicDocument,\n>(\n\trepositoryNameOrEndpoint: string,\n\toptions?: ClientConfig,\n) => new Client<TDocuments>(repositoryNameOrEndpoint, options);\n\n/**\n * A client that allows querying content from a Prismic repository.\n *\n * If used in an environment where a global `fetch` function is unavailable,\n * such as Node.js, the `fetch` option must be provided as part of the `options`\n * parameter.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class Client<\n\tTDocuments extends prismicT.PrismicDocument = prismicT.PrismicDocument,\n> {\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t */\n\tendpoint: string;\n\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * A list of Route Resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>;\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken Link or Content Relationship fields. A broken\n\t * link is a Link or Content Relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>;\n\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetchFn: FetchLike;\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>;\n\n\t/**\n\t * The client's ref mode state. This determines which ref is used during queries.\n\t */\n\tprivate refState: RefState = {\n\t\tmode: RefStateMode.Master,\n\t\tautoPreviewsEnabled: true,\n\t};\n\n\t/**\n\t * Cached repository value.\n\t */\n\tprivate cachedRepository: prismicT.Repository | undefined;\n\n\t/**\n\t * Timestamp at which the cached repository data is considered stale.\n\t */\n\tprivate cachedRepositoryExpiration = 0;\n\n\t/**\n\t * Creates a Prismic client that can be used to query a repository.\n\t *\n\t * If used in an environment where a global `fetch` function is unavailable,\n\t * such as Node.js, the `fetch` option must be provided as part of the\n\t * `options` parameter.\n\t *\n\t * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n\t *   API V2 endpoint for the repository.\n\t * @param options - Configuration that determines how content will be queried\n\t *   from the Prismic repository.\n\t *\n\t * @returns A client that can query content from the repository.\n\t */\n\tconstructor(repositoryNameOrEndpoint: string, options: ClientConfig = {}) {\n\t\tif (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n\t\t\tif (\n\t\t\t\tprocess.env.NODE_ENV === \"development\" &&\n\t\t\t\t/\\.prismic\\.io\\/(?!api\\/v2\\/?)/.test(repositoryNameOrEndpoint)\n\t\t\t) {\n\t\t\t\tthrow new PrismicError(\n\t\t\t\t\t\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\",\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.endpoint = repositoryNameOrEndpoint;\n\t\t} else {\n\t\t\tthis.endpoint = getRepositoryEndpoint(repositoryNameOrEndpoint);\n\t\t}\n\n\t\tthis.accessToken = options.accessToken;\n\t\tthis.routes = options.routes;\n\t\tthis.brokenRoute = options.brokenRoute;\n\t\tthis.defaultParams = options.defaultParams;\n\n\t\tif (options.ref) {\n\t\t\tthis.queryContentFromRef(options.ref);\n\t\t}\n\n\t\tif (typeof options.fetch === \"function\") {\n\t\t\tthis.fetchFn = options.fetch;\n\t\t} else if (typeof globalThis.fetch === \"function\") {\n\t\t\tthis.fetchFn = globalThis.fetch as FetchLike;\n\t\t} else {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\t// If the global fetch function is used, we must bind it to the global scope.\n\t\tif (this.fetchFn === globalThis.fetch) {\n\t\t\tthis.fetchFn = this.fetchFn.bind(globalThis);\n\t\t}\n\n\t\tthis.graphQLFetch = this.graphQLFetch.bind(this);\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in browser environments. This is enabled by default in the browser.\n\t *\n\t * For server environments, use `enableAutoPreviewsFromReq`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.enableAutoPreviews();\n\t * ```\n\t *\n\t * @see enableAutoPreviewsFromReq\n\t */\n\tenableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = true;\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in server environments. This is disabled by default on the server.\n\t *\n\t * For browser environments, use `enableAutoPreviews`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // In an express app\n\t * app.get(\"/\", function (req, res) {\n\t * \tclient.enableAutoPreviewsFromReq(req);\n\t * });\n\t * ```\n\t *\n\t * @param req - An HTTP server request object containing the request's cookies.\n\t */\n\tenableAutoPreviewsFromReq<R extends HttpRequestLike>(req: R): void {\n\t\tthis.refState.httpRequest = req;\n\t\tthis.refState.autoPreviewsEnabled = true;\n\t}\n\n\t/**\n\t * Disables the client from automatically querying content from a preview\n\t * session if one is active.\n\t *\n\t * Automatic preview content querying is enabled by default unless this method\n\t * is called.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.disableAutoPreviews();\n\t * ```\n\t */\n\tdisableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = false;\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @deprecated Use `get` instead.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.query(\n\t * \tprismic.predicate.at(\"document.type\", \"page\"),\n\t * );\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync query<TDocument extends TDocuments>(\n\t\tpredicates: NonNullable<BuildQueryURLArgs[\"predicates\"]>,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"predicates\">> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\tconst url = await this.buildQueryURL({ ...params, predicates });\n\n\t\treturn await this.fetch<prismicT.Query<TDocument>>(url, params);\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.get();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\tconst url = await this.buildQueryURL(params);\n\n\t\treturn await this.fetch<prismicT.Query<TDocument>>(url, params);\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository and returns only the first\n\t * result, if any.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getFirst();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param params - Parameters to filter, sort, and paginate results. @returns\n\t *   The first result of the query, if any.\n\t */\n\tasync getFirst<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\tconst actualParams = { ...params };\n\t\tif (!(params && params.page) && !params?.pageSize) {\n\t\t\tactualParams.pageSize = this.defaultParams?.pageSize ?? 1;\n\t\t}\n\t\tconst url = await this.buildQueryURL(actualParams);\n\t\tconst result = await this.fetch<prismicT.Query<TDocument>>(url, params);\n\n\t\tconst firstResult = result.results[0];\n\n\t\tif (firstResult) {\n\t\t\treturn firstResult;\n\t\t}\n\n\t\tthrow new PrismicError(\"No documents were returned\", url, undefined);\n\t}\n\n\t/**\n\t * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n\t * require more resources than other methods. Prefer using other methods that\n\t * filter by predicates such as `getAllByType`.\n\t *\n\t * Queries content from the Prismic repository and returns all matching\n\t * content. If no predicates are provided, all documents will be fetched.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.dangerouslyGetAll();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A list of documents matching the query.\n\t */\n\tasync dangerouslyGetAll<TDocument extends TDocuments>(\n\t\tparams: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams = {},\n\t): Promise<TDocument[]> {\n\t\tconst { limit = Infinity, ...actualParams } = params;\n\t\tconst resolvedParams = {\n\t\t\t...actualParams,\n\t\t\tpageSize: Math.min(\n\t\t\t\tlimit,\n\t\t\t\tactualParams.pageSize || this.defaultParams?.pageSize || MAX_PAGE_SIZE,\n\t\t\t),\n\t\t};\n\n\t\tconst documents: TDocument[] = [];\n\t\tlet latestResult: prismicT.Query<TDocument> | undefined;\n\n\t\twhile (\n\t\t\t(!latestResult || latestResult.next_page) &&\n\t\t\tdocuments.length < limit\n\t\t) {\n\t\t\tconst page = latestResult ? latestResult.page + 1 : undefined;\n\n\t\t\tlatestResult = await this.get<TDocument>({ ...resolvedParams, page });\n\t\t\tdocuments.push(...latestResult.results);\n\n\t\t\tif (latestResult.next_page) {\n\t\t\t\tawait new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));\n\t\t\t}\n\t\t}\n\n\t\treturn documents.slice(0, limit);\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific ID.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @typeParam TDocument- Type of the Prismic document returned.\n\t * @param id - ID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with an ID matching the `id` parameter, if a matching\n\t *   document exists.\n\t */\n\tasync getByID<TDocument extends TDocuments>(\n\t\tid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendPredicates(params, predicate.at(\"document.id\", id)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific IDs.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with IDs matching the\n\t *   `ids` parameter.\n\t */\n\tasync getByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, predicate.in(\"document.id\", ids)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific IDs.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with IDs matching the `ids` parameter.\n\t */\n\tasync getAllByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, predicate.in(\"document.id\", ids)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific UID and Custom Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUID(\"blog_post\", \"my-first-post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param documentType - The API ID of the document's Custom Type.\n\t * @param uid - UID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with a UID matching the `uid` parameter, if a\n\t *   matching document exists.\n\t */\n\tasync getByUID<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendPredicates(params, [\n\t\t\t\ttypePredicate(documentType),\n\t\t\t\tpredicate.at(`my.${documentType}.uid`, uid),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries document from the Prismic repository with specific UIDs and Custom Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUIDs(\"blog_post\", [\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param documentType - The API ID of the document's Custom Type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with UIDs matching the\n\t *   `uids` parameter.\n\t */\n\tasync getByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendPredicates(params, [\n\t\t\t\ttypePredicate(documentType),\n\t\t\t\tpredicate.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific UIDs and Custom Type.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its Custom Type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByUIDs([\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param documentType - The API ID of the document's Custom Type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with UIDs matching the `uids` parameter.\n\t */\n\tasync getAllByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(\n\t\t\tappendPredicates(params, [\n\t\t\t\ttypePredicate(documentType),\n\t\t\t\tpredicate.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries a singleton document from the Prismic repository for a specific Custom Type.\n\t *\n\t * @remarks\n\t * A singleton document is one that is configured in Prismic to only allow one\n\t * instance. For example, a repository may be configured to contain just one\n\t * Settings document. This is in contrast to a repeatable Custom Type which\n\t * allows multiple instances of itself.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getSingle(\"settings\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t * @param documentType - The API ID of the singleton Custom Type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The singleton document for the Custom Type, if a matching document exists.\n\t */\n\tasync getSingle<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendPredicates(params, typePredicate(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository for a specific Custom Type.\n\t *\n\t * Use `getAllByType` instead if you need to query all documents for a\n\t * specific Custom Type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param documentType - The API ID of the Custom Type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents of the Custom Type.\n\t */\n\tasync getByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendPredicates(params, typePredicate(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository for a specific Custom Type.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param documentType - The API ID of the Custom Type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents of the Custom Type.\n\t */\n\tasync getAllByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(appendPredicates(params, typePredicate(documentType)));\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with a specific tag.\n\t *\n\t * Use `getAllByTag` instead if you need to query all documents with a specific tag.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByTag(\"food\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tag.\n\t */\n\tasync getByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tag)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with a specific tag.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByTag(\"food\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tag.\n\t */\n\tasync getAllByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tag)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tags.\n\t */\n\tasync getByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, everyTagPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tags.\n\t */\n\tasync getAllByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, everyTagPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with at least one of the tags.\n\t */\n\tasync getBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<prismicT.Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with at least one of the tags.\n\t */\n\tasync getAllBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendPredicates(params, someTagsPredicate(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Returns metadata about the Prismic repository, such as its refs, releases,\n\t * and custom types.\n\t *\n\t * @returns Repository metadata.\n\t */\n\tasync getRepository(params?: FetchParams): Promise<prismicT.Repository> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// return await this.fetch<prismicT.Repository>(this.endpoint);\n\n\t\tconst url = new URL(this.endpoint);\n\n\t\tif (this.accessToken) {\n\t\t\turl.searchParams.set(\"access_token\", this.accessToken);\n\t\t}\n\n\t\treturn await this.fetch<prismicT.Repository>(url.toString(), params);\n\t}\n\n\t/**\n\t * Returns a list of all refs for the Prismic repository.\n\t *\n\t * Refs are used to identify which version of the repository's content should\n\t * be queried. All repositories will have at least one ref pointing to the\n\t * latest published content called the \"master ref\".\n\t *\n\t * @returns A list of all refs for the Prismic repository.\n\t */\n\tasync getRefs(params?: FetchParams): Promise<prismicT.Ref[]> {\n\t\tconst repository = await this.getRepository(params);\n\n\t\treturn repository.refs;\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the ref.\n\t *\n\t * @returns The ref with a matching ID, if it exists.\n\t */\n\tasync getRefByID(id: string, params?: FetchParams): Promise<prismicT.Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findRefByID(refs, id);\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getRefByLabel(\n\t\tlabel: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findRefByLabel(refs, label);\n\t}\n\n\t/**\n\t * Returns the master ref for the Prismic repository. The master ref points to\n\t * the repository's latest published content.\n\t *\n\t * @returns The repository's master ref.\n\t */\n\tasync getMasterRef(params?: FetchParams): Promise<prismicT.Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findMasterRef(refs);\n\t}\n\n\t/**\n\t * Returns a list of all Releases for the Prismic repository. Releases are\n\t * used to group content changes before publishing.\n\t *\n\t * @returns A list of all Releases for the Prismic repository.\n\t */\n\tasync getReleases(params?: FetchParams): Promise<prismicT.Ref[]> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn refs.filter((ref) => !ref.isMasterRef);\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the Release.\n\t *\n\t * @returns The Release with a matching ID, if it exists.\n\t */\n\tasync getReleaseByID(\n\t\tid: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Ref> {\n\t\tconst releases = await this.getReleases(params);\n\n\t\treturn findRefByID(releases, id);\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getReleaseByLabel(\n\t\tlabel: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Ref> {\n\t\tconst releases = await this.getReleases(params);\n\n\t\treturn findRefByLabel(releases, label);\n\t}\n\n\t/**\n\t * Returns a list of all tags used in the Prismic repository.\n\t *\n\t * @returns A list of all tags used in the repository.\n\t */\n\tasync getTags(params?: FetchParams): Promise<string[]> {\n\t\ttry {\n\t\t\tconst tagsForm = await this.getCachedRepositoryForm(\"tags\", params);\n\n\t\t\tconst url = new URL(tagsForm.action);\n\n\t\t\tif (this.accessToken) {\n\t\t\t\turl.searchParams.set(\"access_token\", this.accessToken);\n\t\t\t}\n\n\t\t\treturn await this.fetch<string[]>(url.toString(), params);\n\t\t} catch {\n\t\t\tconst repository = await this.getRepository(params);\n\n\t\t\treturn repository.tags;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a URL used to query content from the Prismic repository.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A URL string that can be requested to query content.\n\t */\n\tasync buildQueryURL({\n\t\tsignal,\n\t\t...params\n\t}: Partial<BuildQueryURLArgs> & FetchParams = {}): Promise<string> {\n\t\tconst ref = params.ref || (await this.getResolvedRefString());\n\t\tconst integrationFieldsRef =\n\t\t\tparams.integrationFieldsRef ||\n\t\t\t(await this.getCachedRepository({ signal })).integrationFieldsRef ||\n\t\t\tundefined;\n\n\t\treturn buildQueryURL(this.endpoint, {\n\t\t\t...this.defaultParams,\n\t\t\t...params,\n\t\t\tref,\n\t\t\tintegrationFieldsRef,\n\t\t\troutes: params.routes || this.routes,\n\t\t\tbrokenRoute: params.brokenRoute || this.brokenRoute,\n\t\t\taccessToken: params.accessToken || this.accessToken,\n\t\t});\n\t}\n\n\t/**\n\t * Determines the URL for a previewed document during an active preview\n\t * session. The result of this method should be used to redirect the user to\n\t * the document's URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * \tconst url = client.resolvePreviewURL({\n\t * \tlinkResolver: (document) => `/${document.uid}`\n\t * \tdefaultURL: '/'\n\t * \t})\n\t * ```\n\t *\n\t * @param args - Arguments to configure the URL resolving.\n\t *\n\t * @returns The URL for the previewed document during an active preview\n\t *   session. The user should be redirected to this URL.\n\t */\n\tasync resolvePreviewURL<LinkResolverReturnType>(\n\t\targs: ResolvePreviewArgs<LinkResolverReturnType> & FetchParams,\n\t): Promise<string> {\n\t\tlet documentID: string | undefined | null = args.documentID;\n\t\tlet previewToken: string | undefined | null = args.previewToken;\n\n\t\tif (typeof globalThis.location !== \"undefined\") {\n\t\t\tconst searchParams = new URLSearchParams(globalThis.location.search);\n\n\t\t\tdocumentID = documentID || searchParams.get(\"documentId\");\n\t\t\tpreviewToken = previewToken || searchParams.get(\"token\");\n\t\t} else if (this.refState.httpRequest) {\n\t\t\tif (\"query\" in this.refState.httpRequest) {\n\t\t\t\tdocumentID =\n\t\t\t\t\tdocumentID || (this.refState.httpRequest.query?.documentId as string);\n\t\t\t\tpreviewToken =\n\t\t\t\t\tpreviewToken || (this.refState.httpRequest.query?.token as string);\n\t\t\t} else if (\n\t\t\t\t\"url\" in this.refState.httpRequest &&\n\t\t\t\tthis.refState.httpRequest.url\n\t\t\t) {\n\t\t\t\tconst searchParams = new URL(this.refState.httpRequest.url)\n\t\t\t\t\t.searchParams;\n\n\t\t\t\tdocumentID = documentID || searchParams.get(\"documentId\");\n\t\t\t\tpreviewToken = previewToken || searchParams.get(\"token\");\n\t\t\t}\n\t\t}\n\n\t\tif (documentID != null && previewToken != null) {\n\t\t\tconst document = await this.getByID(documentID, {\n\t\t\t\tsignal: args.signal,\n\t\t\t\tref: previewToken,\n\t\t\t\tlang: \"*\",\n\t\t\t});\n\n\t\t\tconst url = prismicH.asLink(document, args.linkResolver);\n\n\t\t\tif (typeof url === \"string\") {\n\t\t\t\treturn url;\n\t\t\t}\n\t\t}\n\n\t\treturn args.defaultURL;\n\t}\n\n\t/**\n\t * Configures the client to query the latest published content for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryLatestContent();\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t */\n\tqueryLatestContent(): void {\n\t\tthis.refState.mode = RefStateMode.Master;\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its ID for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param releaseID - The ID of the Release.\n\t */\n\tqueryContentFromReleaseByID(releaseID: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseID,\n\t\t\treleaseID,\n\t\t};\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its label for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByLabel(\"My Release\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param releaseLabel - The label of the Release.\n\t */\n\tqueryContentFromReleaseByLabel(releaseLabel: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseLabel,\n\t\t\treleaseLabel,\n\t\t};\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific ref. The ref can be\n\t * provided as a string or a function.\n\t *\n\t * If a function is provided, the ref is fetched lazily before each query. The\n\t * function may also be asynchronous.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromRef(\"my-ref\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param ref - The ref or a function that returns the ref from which to query content.\n\t */\n\tqueryContentFromRef(ref: RefStringOrThunk): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.Manual,\n\t\t\tref,\n\t\t};\n\t}\n\n\t/**\n\t * @deprecated Renamed to `graphQLFetch()` (note the capitalization of \"QL\").\n\t */\n\t// TODO: Remove in v7\n\tgraphqlFetch = this.graphQLFetch.bind(this);\n\n\t/**\n\t * A `fetch()` function to be used with GraphQL clients configured for\n\t * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n\t * and Authorization headers. Queries will automatically be minified by\n\t * removing whitespace where possible.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const graphqlClient = new ApolloClient({\n\t * \tlink: new HttpLink({\n\t * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n\t * \t\t// Provide `client.graphqlFetch` as the fetch implementation.\n\t * \t\tfetch: client.graphqlFetch,\n\t * \t\t// Using GET is required.\n\t * \t\tuseGETForQueries: true,\n\t * \t}),\n\t * \tcache: new InMemoryCache(),\n\t * });\n\t * ```\n\t *\n\t * @param input - The `fetch()` `input` parameter. Only strings are supported.\n\t * @param init - The `fetch()` `init` parameter. Only plain objects are supported.\n\t *\n\t * @returns The `fetch()` Response for the request.\n\t * @experimental\n\t */\n\tasync graphQLFetch(\n\t\tinput: RequestInfo,\n\t\tinit?: Omit<RequestInit, \"signal\"> & { signal?: AbortSignalLike },\n\t): Promise<Response> {\n\t\tconst cachedRepository = await this.getCachedRepository();\n\t\tconst ref = await this.getResolvedRefString();\n\n\t\tconst unsanitizedHeaders: Record<string, string> = {\n\t\t\t\"Prismic-ref\": ref,\n\t\t\tAuthorization: this.accessToken ? `Token ${this.accessToken}` : \"\",\n\t\t\t// Asserting `init.headers` is a Record since popular GraphQL\n\t\t\t// libraries pass this as a Record. Header objects as input\n\t\t\t// are unsupported.\n\t\t\t...(init ? (init.headers as Record<string, string>) : {}),\n\t\t};\n\n\t\tif (cachedRepository.integrationFieldsRef) {\n\t\t\tunsanitizedHeaders[\"Prismic-integration-field-ref\"] =\n\t\t\t\tcachedRepository.integrationFieldsRef;\n\t\t}\n\n\t\t// Normalize header keys to lowercase. This prevents header\n\t\t// conflicts between the Prismic client and the GraphQL\n\t\t// client.\n\t\tconst headers: Record<string, string> = {};\n\t\tfor (const key in unsanitizedHeaders) {\n\t\t\tif (unsanitizedHeaders[key]) {\n\t\t\t\theaders[key.toLowerCase()] =\n\t\t\t\t\tunsanitizedHeaders[key as keyof typeof unsanitizedHeaders];\n\t\t\t}\n\t\t}\n\n\t\tconst url = new URL(\n\t\t\t// Asserting `input` is a string since popular GraphQL\n\t\t\t// libraries pass this as a string. Request objects as\n\t\t\t// input are unsupported.\n\t\t\tinput as string,\n\t\t);\n\n\t\t// This prevents the request from being cached unnecessarily.\n\t\t// Without adding this `ref` param, re-running a query\n\t\t// could return a locally cached response, even if the\n\t\t// `ref` changed. This happens because the URL is\n\t\t// identical when the `ref` is not included. Caches may ignore\n\t\t// headers.\n\t\t//\n\t\t// The Prismic GraphQL API ignores the `ref` param.\n\t\turl.searchParams.set(\"ref\", ref);\n\n\t\tconst query = url.searchParams.get(\"query\");\n\t\tif (query) {\n\t\t\turl.searchParams.set(\n\t\t\t\t\"query\",\n\t\t\t\t// Compress the GraphQL query (if it exists) by\n\t\t\t\t// removing whitespace. This is done to\n\t\t\t\t// optimize the query size and avoid\n\t\t\t\t// hitting the upper limit of GET requests\n\t\t\t\t// (2048 characters).\n\t\t\t\tminifyGraphQLQuery(query),\n\t\t\t);\n\t\t}\n\n\t\treturn (await this.fetchFn(url.toString(), {\n\t\t\t...init,\n\t\t\theaders,\n\t\t})) as Response;\n\t}\n\n\t/**\n\t * Returns a cached version of `getRepository` with a TTL.\n\t *\n\t * @returns Cached repository metadata.\n\t */\n\tprivate async getCachedRepository(\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Repository> {\n\t\tif (\n\t\t\t!this.cachedRepository ||\n\t\t\tDate.now() >= this.cachedRepositoryExpiration\n\t\t) {\n\t\t\tthis.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;\n\t\t\tthis.cachedRepository = await this.getRepository(params);\n\t\t}\n\n\t\treturn this.cachedRepository;\n\t}\n\n\t/**\n\t * Returns a cached Prismic repository form. Forms are used to determine API\n\t * endpoints for types of repository data.\n\t *\n\t * @param name - Name of the form.\n\t *\n\t * @returns The repository form.\n\t * @throws If a matching form cannot be found.\n\t */\n\tprivate async getCachedRepositoryForm(\n\t\tname: string,\n\t\tparams?: FetchParams,\n\t): Promise<prismicT.Form> {\n\t\tconst cachedRepository = await this.getCachedRepository(params);\n\t\tconst form = cachedRepository.forms[name];\n\n\t\tif (!form) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Form with name \"${name}\" could not be found`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\treturn form;\n\t}\n\n\t/**\n\t * Returns the ref needed to query based on the client's current state. This\n\t * method may make a network request to fetch a ref or resolve the user's ref thunk.\n\t *\n\t * If auto previews are enabled, the preview ref takes priority if available.\n\t *\n\t * The following strategies are used depending on the client's state:\n\t *\n\t * - If the user called `queryLatestContent`: Use the repository's master ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is fetched.\n\t * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n\t *   to the master ref if the ref is not a string.\n\t *\n\t * @returns The ref to use during a query.\n\t */\n\tprivate async getResolvedRefString(params?: FetchParams): Promise<string> {\n\t\tif (this.refState.autoPreviewsEnabled) {\n\t\t\tlet previewRef: string | undefined;\n\n\t\t\tlet cookieJar: string | null | undefined;\n\n\t\t\tif (this.refState.httpRequest?.headers) {\n\t\t\t\tif (\n\t\t\t\t\t\"get\" in this.refState.httpRequest.headers &&\n\t\t\t\t\ttypeof this.refState.httpRequest.headers.get === \"function\"\n\t\t\t\t) {\n\t\t\t\t\t// Web API Headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.get(\"cookie\");\n\t\t\t\t} else if (\"cookie\" in this.refState.httpRequest.headers) {\n\t\t\t\t\t// Express-style headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.cookie;\n\t\t\t\t}\n\t\t\t} else if (globalThis.document?.cookie) {\n\t\t\t\tcookieJar = globalThis.document.cookie;\n\t\t\t}\n\n\t\t\tif (cookieJar) {\n\t\t\t\tpreviewRef = getPreviewCookie(cookieJar);\n\t\t\t}\n\n\t\t\tif (previewRef) {\n\t\t\t\treturn previewRef;\n\t\t\t}\n\t\t}\n\n\t\tconst cachedRepository = await this.getCachedRepository(params);\n\n\t\tconst refModeType = this.refState.mode;\n\t\tif (refModeType === RefStateMode.ReleaseID) {\n\t\t\treturn findRefByID(cachedRepository.refs, this.refState.releaseID).ref;\n\t\t} else if (refModeType === RefStateMode.ReleaseLabel) {\n\t\t\treturn findRefByLabel(cachedRepository.refs, this.refState.releaseLabel)\n\t\t\t\t.ref;\n\t\t} else if (refModeType === RefStateMode.Manual) {\n\t\t\tconst res = await castThunk(this.refState.ref)();\n\n\t\t\tif (typeof res === \"string\") {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\treturn findMasterRef(cachedRepository.refs).ref;\n\t}\n\n\t/**\n\t * Performs a network request using the configured `fetch` function. It\n\t * assumes all successful responses will have a JSON content type. It also\n\t * normalizes unsuccessful network requests.\n\t *\n\t * @typeParam T - The JSON response.\n\t * @param url - URL to the resource to fetch.\n\t * @param params - Prismic REST API parameters for the network request.\n\t *\n\t * @returns The JSON response from the network request.\n\t */\n\tprivate async fetch<T = unknown>(\n\t\turl: string,\n\t\t// TODO: Change to `params` when Authorization header support works in browsers with CORS.\n\t\t// _params?: Partial<BuildQueryURLArgs>,\n\t\tparams: FetchParams = {},\n\t): Promise<T> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// const accessToken = (params && params.accessToken) || this.accessToken;\n\t\t// const options = accessToken\n\t\t// \t? { headers: { Authorization: `Token ${accessToken}` } }\n\t\t// \t: {};\n\n\t\tconst res = await this.fetchFn(url, {\n\t\t\tsignal: params.signal,\n\t\t});\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\tlet json: any;\n\t\ttry {\n\t\t\t// We can assume Prismic REST API responses will have a `application/json`\n\t\t\t// Content Type. If not, this will throw, signaling an invalid response.\n\t\t\tjson = await res.json();\n\t\t} catch {\n\t\t\t// Not Found (this response has an empty body and throws on `.json()`)\n\t\t\t// - Incorrect repository name\n\t\t\tif (res.status === 404) {\n\t\t\t\tthrow new NotFoundError(\n\t\t\t\t\t`Prismic repository not found. Check that \"${this.endpoint}\" is pointing to the correct repository.`,\n\t\t\t\t\turl,\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthrow new PrismicError(undefined, url, undefined);\n\t\t\t}\n\t\t}\n\n\t\tswitch (res.status) {\n\t\t\t// Successful\n\t\t\tcase 200: {\n\t\t\t\treturn json;\n\t\t\t}\n\n\t\t\t// Bad Request\n\t\t\t// - Invalid predicate syntax\n\t\t\t// - Ref not provided (ignored)\n\t\t\tcase 400: {\n\t\t\t\tthrow new ParsingError(json.message, url, json);\n\t\t\t}\n\n\t\t\t// Unauthorized\n\t\t\t// - Missing access token for repository endpoint\n\t\t\t// - Incorrect access token for repository endpoint\n\t\t\tcase 401:\n\t\t\t// Forbidden\n\t\t\t// - Missing access token for query endpoint\n\t\t\t// - Incorrect access token for query endpoint\n\t\t\tcase 403: {\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\t\"error\" in json ? json.error : json.message,\n\t\t\t\t\turl,\n\t\t\t\t\tjson,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthrow new PrismicError(undefined, url, json);\n\t}\n}\n", "// Primary library API.\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\";\nexport { getRepositoryEndpoint };\n/**\n * @deprecated Renamed to `getRepositoryEndpoint`.\n */\n// TODO: Remove in v3.\nexport const getEndpoint = getRepositoryEndpoint;\nexport { getRepositoryName } from \"./getRepositoryName\";\nexport { getGraphQLEndpoint } from \"./getGraphQLEndpoint\";\nexport { isRepositoryName } from \"./isRepositoryName\";\nexport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\";\nexport { buildQueryURL } from \"./buildQueryURL\";\nexport { createClient, Client } from \"./client\";\n\n// Predicates API.\nimport { predicate } from \"./predicate\";\nexport { predicate };\n/**\n * @deprecated Renamed to `predicate` (without an \"s\").\n */\n// TODO: Remove in v3.\nexport const predicates = predicate;\n/**\n * @deprecated Renamed to `predicate` (lowercase and without an \"s\").\n */\n// TODO: Remove in v3.\nexport const Predicates = predicate;\n\n// Custom errors used by Client.\nexport { PrismicError } from \"./PrismicError\";\nexport { ForbiddenError } from \"./ForbiddenError\";\nexport { ParsingError } from \"./ParsingError\";\nexport { NotFoundError } from \"./NotFoundError\";\n\n// A collection of well-known cookie names shared between Prismic libraries and systems.\nexport * as cookie from \"./cookie\";\n\n// General types used throughout the project. These are made public to allow users to better type their projects.\nexport type { CreateClient, ClientConfig } from \"./client\";\nexport type { QueryParams, BuildQueryURLArgs } from \"./buildQueryURL\";\nexport type {\n\tAbortSignalLike,\n\tFetchLike,\n\tHttpRequestLike,\n\tOrdering,\n\tRequestInitLike,\n\tResponseLike,\n\tRoute,\n} from \"./types\";\n", "import { ConcreteComponent, resolveDynamicComponent, VNode } from \"vue\";\n\n/**\n * A stricter version of {@link resolveDynamicComponent} that resolves only type\n * {@link VNode} for existing components or provided `string`.\n *\n * @param component - An HTML tag name, a component, or a functional component\n *\n * @returns Resolved component as a {@link VNode} or provided `string`.\n *\n * @internal\n */\nexport const simplyResolveComponent = (\n\tcomponent: string | ConcreteComponent,\n): string | VNode => {\n\treturn resolveDynamicComponent(component) as string | VNode;\n};\n", "import {\n\tAllowedComponentProps,\n\tComponentCustomProps,\n\tConcreteComponent,\n\tdefineComponent,\n\th,\n\tPropType,\n\tVNodeProps,\n} from \"vue\";\n\nimport { EmbedField } from \"@prismicio/types\";\nimport { simplyResolveComponent } from \"../lib/simplyResolveComponent\";\n\n/**\n * The default component rendered to wrap the embed.\n */\nconst defaultWrapper = \"div\";\n\n/**\n * Props for `<PrismicEmbed />`.\n */\nexport type PrismicEmbedProps = {\n\t/**\n\t * The Prismic embed field to render.\n\t */\n\tfield: EmbedField;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to wrap the\n\t * output.\n\t *\n\t * @defaultValue `\"div\"`\n\t */\n\twrapper?: string | ConcreteComponent;\n};\n\n/**\n * `<PrismicEmbed />` implementation.\n *\n * @internal\n */\nexport const PrismicEmbedImpl = /*#__PURE__*/ defineComponent({\n\tname: \"PrismicEmbed\",\n\tprops: {\n\t\tfield: {\n\t\t\ttype: Object as PropType<EmbedField>,\n\t\t\trequired: true,\n\t\t},\n\t\twrapper: {\n\t\t\ttype: [String, Object, Function] as PropType<string | ConcreteComponent>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t},\n\tsetup(props) {\n\t\t// Prevent fatal if user didn't check for field, throws `Invalid prop` warn\n\t\tif (!props.field) {\n\t\t\treturn () => null;\n\t\t}\n\n\t\treturn () => {\n\t\t\treturn h(simplyResolveComponent(props.wrapper || defaultWrapper), {\n\t\t\t\t\"data-oembed\": props.field.embed_url,\n\t\t\t\t\"data-oembed-type\": props.field.type,\n\t\t\t\t\"data-oembed-provider\": props.field.provider_name,\n\t\t\t\tinnerHTML: props.field.html || null,\n\t\t\t});\n\t\t};\n\t},\n});\n\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to render a Prismic embed field.\n *\n * @see Component props {@link PrismicEmbedProps}\n * @see Templating embed fields {@link https://prismic.io/docs/technologies/vue-template-content#embeds}\n */\nexport const PrismicEmbed = PrismicEmbedImpl as unknown as {\n\tnew (): {\n\t\t$props: AllowedComponentProps &\n\t\t\tComponentCustomProps &\n\t\t\tVNodeProps &\n\t\t\tPrismicEmbedProps;\n\t};\n};\n", "// We need to polyfill process if it doesn't exist, such as in the browser.\nif (typeof process === \"undefined\") {\n\tglobalThis.process = { env: {} } as typeof process;\n}\n\n/**\n * `true` if in the production environment, `false` otherwise.\n *\n * This boolean can be used to perform actions only in development environments,\n * such as logging.\n */\nexport const __PRODUCTION__ = process.env.NODE_ENV === \"production\";\n", "import type { InjectionKey } from \"vue\";\n\nimport type { PrismicPlugin } from \"./types\";\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// Imports for @link references:\n\nimport type { usePrismic } from \"./usePrismic\";\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n\n/**\n * `@prismicio/vue` plugin interface interface location used for\n * {@link usePrismic}.\n *\n * @internal\n */\nexport const prismicKey = Symbol(\"prismic\") as InjectionKey<PrismicPlugin>;\n", "import { inject } from \"vue\";\n\nimport { prismicKey } from \"./injectionSymbols\";\nimport { PrismicPlugin } from \"./types\";\n\n/**\n * Accesses `@prismicio/vue` plugin interface.\n *\n * @example With the composition API:\n *\n * ```javascript\n * import { usePrismic } from \"@prismicio/vue\";\n *\n * export default {\n * \tsetup() {\n * \t\tconst prismic = usePrismic();\n *\n * \t\treturn {};\n * \t},\n * };\n * ```\n *\n * @returns The interface {@link PrismicPlugin}\n */\nexport const usePrismic = (): PrismicPlugin => {\n\treturn inject(prismicKey, { options: { endpoint: \"\" } } as PrismicPlugin);\n};\n", "import {\n\tAllowedComponentProps,\n\tComponentCustomProps,\n\tcomputed,\n\tConcreteComponent,\n\tComputedRef,\n\tdefineComponent,\n\th,\n\tPropType,\n\tVNodeProps,\n\tunref,\n} from \"vue\";\n\nimport { ImageField } from \"@prismicio/types\";\nimport {\n\tasImageSrc,\n\tasImageWidthSrcSet,\n\tasImagePixelDensitySrcSet,\n\tisFilled,\n} from \"@prismicio/helpers\";\n\nimport { simplyResolveComponent } from \"../lib/simplyResolveComponent\";\nimport { __PRODUCTION__ } from \"../lib/__PRODUCTION__\";\nimport { usePrismic } from \"../usePrismic\";\nimport { VueUseOptions } from \"../types\";\n\n/**\n * The default component rendered for images.\n */\nconst defaultImageComponent = \"img\";\n\n/**\n * Props for `<PrismicImage />`.\n */\nexport type PrismicImageProps = {\n\t/**\n\t * The Prismic image field to render.\n\t */\n\tfield: ImageField;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to render\n\t * images.\n\t *\n\t * @remarks\n\t * HTML tag names and components will be rendered using the `img` tag\n\t * interface (`src`, `srcset`, and `alt` attribute). Components will also\n\t * receive an additional `copyright` props.\n\t * @defaultValue The one provided to `@prismicio/vue` plugin if configured, `\"img\"` otherwise.\n\t */\n\timageComponent?: string | ConcreteComponent;\n\n\t/**\n\t * An object of Imgix URL API parameters.\n\t *\n\t * @see Imgix URL parameters reference: https://docs.imgix.com/apis/rendering\n\t */\n\timgixParams?: Parameters<typeof asImageSrc>[1];\n\n\t/**\n\t * Adds an additional `srcset` attribute to the image following given widths.\n\t *\n\t * @remarks\n\t * A special value of `\"thumbnails\"` is accepted to automatically use image\n\t * widths coming from the API.\n\t * @remarks\n\t * A special value of `\"defaults\"` is accepted to automatically use image\n\t * widths coming from the plugin configuration.\n\t * @remarks\n\t * This prop is not compatible with the `pixelDensities` prop. When both are\n\t * used the `pixelDensities` prop will be ignored.\n\t */\n\twidths?:\n\t\t| NonNullable<Parameters<typeof asImageWidthSrcSet>[1]>[\"widths\"]\n\t\t| \"thumbnails\"\n\t\t| \"defaults\";\n\n\t/**\n\t * Adds an additional `srcset` attribute to the image following giving pixel\n\t * densities.\n\t *\n\t * @remarks\n\t * A special value of `\"defaults\"` is accepted to automatically use image\n\t * pixel densities coming from the plugin configuration.\n\t * @remarks\n\t * This prop is not compatible with the `widths` prop. When both are used, the\n\t * `pixelDensities` prop will be ignored.\n\t */\n\tpixelDensities?:\n\t\t| NonNullable<\n\t\t\t\tParameters<typeof asImagePixelDensitySrcSet>[1]\n\t\t  >[\"pixelDensities\"]\n\t\t| \"defaults\";\n};\n\n/**\n * Options for {@link usePrismicImage}.\n */\nexport type UsePrismicImageOptions = VueUseOptions<\n\tOmit<PrismicImageProps, \"imageComponent\">\n>;\n\n/**\n * Return type of {@link usePrismicImage}.\n */\nexport type UsePrismicImageReturnType = {\n\t/**\n\t * Resolved image `src` value.\n\t */\n\tsrc: ComputedRef<string | null>;\n\n\t/**\n\t * Resolved image `srcset` value.\n\t */\n\tsrcset: ComputedRef<string | null>;\n\n\t/**\n\t * Resolved image `alt` value.\n\t */\n\talt: ComputedRef<string>;\n\n\t/**\n\t * Resolved image `copyright` value.\n\t */\n\tcopyright: ComputedRef<string | null>;\n};\n\n/**\n * A low level composable that returns a resolved information about a Prismic\n * image field.\n *\n * @param props - {@link UsePrismicImageOptions}\n *\n * @returns - Resolved image information {@link UsePrismicImageReturnType}\n */\nexport const usePrismicImage = (\n\tprops: UsePrismicImageOptions,\n): UsePrismicImageReturnType => {\n\tconst { options } = usePrismic();\n\n\tconst asImage = computed(() => {\n\t\tconst field = unref(props.field);\n\n\t\tif (!isFilled.image(field)) {\n\t\t\treturn {\n\t\t\t\tsrc: null,\n\t\t\t\tsrcset: null,\n\t\t\t};\n\t\t}\n\n\t\tconst imgixParams = unref(props.imgixParams);\n\t\tconst widths = unref(props.widths);\n\t\tconst pixelDensities = unref(props.pixelDensities);\n\n\t\tif (widths) {\n\t\t\tif (!__PRODUCTION__ && pixelDensities) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"[PrismicImage] Only one of `widths` or `pixelDensities` props can be provided. You can resolve this warning by removing either the `widths` or `pixelDensities` prop. `widths` will be used in this case.\",\n\t\t\t\t\tprops,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn asImageWidthSrcSet(field, {\n\t\t\t\t...imgixParams,\n\t\t\t\twidths:\n\t\t\t\t\twidths === \"defaults\"\n\t\t\t\t\t\t? options.components?.imageWidthSrcSetDefaults\n\t\t\t\t\t\t: widths,\n\t\t\t});\n\t\t} else if (pixelDensities) {\n\t\t\treturn asImagePixelDensitySrcSet(field, {\n\t\t\t\t...imgixParams,\n\t\t\t\tpixelDensities:\n\t\t\t\t\tpixelDensities === \"defaults\"\n\t\t\t\t\t\t? options.components?.imagePixelDensitySrcSetDefaults\n\t\t\t\t\t\t: pixelDensities,\n\t\t\t});\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tsrc: asImageSrc(field, imgixParams),\n\t\t\t\tsrcset: null,\n\t\t\t};\n\t\t}\n\t});\n\n\tconst src = computed(() => {\n\t\treturn asImage.value.src;\n\t});\n\tconst srcset = computed(() => {\n\t\treturn asImage.value.srcset;\n\t});\n\tconst alt = computed(() => {\n\t\treturn unref(props.field).alt || \"\";\n\t});\n\tconst copyright = computed(() => {\n\t\treturn unref(props.field).copyright || null;\n\t});\n\n\treturn {\n\t\tsrc,\n\t\tsrcset,\n\t\talt,\n\t\tcopyright,\n\t};\n};\n\n/**\n * `<PrismicImage />` implementation.\n *\n * @internal\n */\nexport const PrismicImageImpl = /*#__PURE__*/ defineComponent({\n\tname: \"PrismicImage\",\n\tprops: {\n\t\tfield: {\n\t\t\ttype: Object as PropType<ImageField>,\n\t\t\trequired: true,\n\t\t},\n\t\timageComponent: {\n\t\t\ttype: [String, Object] as PropType<string | ConcreteComponent>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\timgixParams: {\n\t\t\ttype: Object as PropType<Parameters<typeof asImageSrc>[1]>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\twidths: {\n\t\t\ttype: [String, Object] as PropType<\n\t\t\t\t| NonNullable<Parameters<typeof asImageWidthSrcSet>[1]>[\"widths\"]\n\t\t\t\t| \"thumbnails\"\n\t\t\t\t| \"defaults\"\n\t\t\t>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tpixelDensities: {\n\t\t\ttype: [String, Object] as PropType<\n\t\t\t\t| NonNullable<\n\t\t\t\t\t\tParameters<typeof asImagePixelDensitySrcSet>[1]\n\t\t\t\t  >[\"pixelDensities\"]\n\t\t\t\t| \"defaults\"\n\t\t\t>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t},\n\tsetup(props) {\n\t\t// Prevent fatal if user didn't check for field, throws `Invalid prop` warn\n\t\tif (!props.field) {\n\t\t\treturn () => null;\n\t\t}\n\n\t\tconst { options } = usePrismic();\n\n\t\tconst type = computed(() => {\n\t\t\treturn (\n\t\t\t\tprops.imageComponent ||\n\t\t\t\toptions.components?.imageComponent ||\n\t\t\t\tdefaultImageComponent\n\t\t\t);\n\t\t});\n\n\t\tconst { src, srcset, alt, copyright } = usePrismicImage(props);\n\n\t\treturn () => {\n\t\t\tconst attributes = {\n\t\t\t\tsrc: src.value,\n\t\t\t\tsrcset: srcset.value,\n\t\t\t\talt: alt.value,\n\t\t\t};\n\n\t\t\tswitch (type.value) {\n\t\t\t\tcase \"img\":\n\t\t\t\t\t// Fitting img tag interface\n\t\t\t\t\treturn h(\"img\", attributes);\n\n\t\t\t\tdefault:\n\t\t\t\t\treturn h(simplyResolveComponent(type.value), {\n\t\t\t\t\t\t...attributes,\n\t\t\t\t\t\tcopyright: copyright.value,\n\t\t\t\t\t});\n\t\t\t}\n\t\t};\n\t},\n});\n\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to render a Prismic image field.\n *\n * @see Component props {@link PrismicImageProps}\n * @see Templating image fields {@link https://prismic.io/docs/technologies/vue-template-content#images}\n */\nexport const PrismicImage = PrismicImageImpl as unknown as {\n\tnew (): {\n\t\t$props: AllowedComponentProps &\n\t\t\tComponentCustomProps &\n\t\t\tVNodeProps &\n\t\t\tPrismicImageProps;\n\t};\n};\n", "/**\n * Determines if a URL is internal or external.\n *\n * @param url - The URL to check if internal or external\n *\n * @returns `true` if `url` is internal, `false` otherwise\n */\n// TODO: This does not detect all relative URLs as internal, such as `about` or `./about`. This function assumes relative URLs start with a \"/\"`.\nexport const isInternalURL = (url: string): boolean => {\n\t/**\n\t * @see Regex101 expression: {@link https://regex101.com/r/1y7iod/1}\n\t */\n\tconst isInternal = /^\\/(?!\\/)/.test(url);\n\t/**\n\t * @see Regex101 expression: {@link https://regex101.com/r/RnUseS/1}\n\t */\n\tconst isSpecialLink = !isInternal && !/^https?:\\/\\//i.test(url);\n\n\treturn isInternal && !isSpecialLink;\n};\n", "import { ConcreteComponent, Slots, VNode } from \"vue\";\n\n/**\n * Get the appropriate `slots` object/array according to the provided parent,\n * fixing `Non-function value encountered for default slot.` warnings.\n *\n * @param parent - The parent inheriting slots\n * @param slots - The `slots` to transform for parent\n * @param defaultParams - The parameters to provide to the default slot\n *\n * @returns The appropriate slots object/array\n *\n * @internal\n */\nexport const getSlots = (\n\tparent: string | ConcreteComponent,\n\tslots: Slots,\n\tdefaultPayload?: unknown,\n): VNode[] | undefined | Slots => {\n\tif (typeof parent === \"string\") {\n\t\treturn slots.default && slots.default(defaultPayload);\n\t} else {\n\t\tif (slots.default) {\n\t\t\tconst content = slots.default(defaultPayload);\n\n\t\t\treturn {\n\t\t\t\t...slots,\n\t\t\t\tdefault: () => content,\n\t\t\t};\n\t\t} else {\n\t\t\treturn slots;\n\t\t}\n\t}\n};\n", "import {\n\tAllowedComponentProps,\n\tComponentCustomProps,\n\tdefineComponent,\n\th,\n\tPropType,\n\tVNodeProps,\n\tunref,\n\treactive,\n\tConcreteComponent,\n\tcomputed,\n\tComputedRef,\n} from \"vue\";\n\nimport { asLink, LinkResolverFunction } from \"@prismicio/helpers\";\nimport { LinkField, PrismicDocument } from \"@prismicio/types\";\n\nimport { isInternalURL } from \"../lib/isInternalURL\";\nimport { usePrismic } from \"../usePrismic\";\nimport { VueUseOptions } from \"../types\";\nimport { simplyResolveComponent } from \"../lib/simplyResolveComponent\";\nimport { getSlots } from \"../lib/getSlots\";\n\n/**\n * The default component rendered for internal URLs.\n */\nconst defaultInternalComponent = \"router-link\";\n\n/**\n * The default component rendered for external URLs.\n */\nconst defaultExternalComponent = \"a\";\n\n/**\n * The default rel attribute rendered for blank target URLs.\n */\nconst defaultBlankTargetRelAttribute = \"noopener noreferrer\";\n\n/**\n * Props for `<PrismicLink />`.\n */\nexport type PrismicLinkProps = {\n\t/**\n\t * The Prismic link field or document to render.\n\t */\n\tfield: LinkField | PrismicDocument;\n\n\t/**\n\t * A link resolver function used to resolve links when not using the route\n\t * resolver parameter with `@prismicio/client`.\n\t *\n\t * @defaultValue The link resolver provided to `@prismicio/vue` plugin if configured.\n\t *\n\t * @see Link resolver documentation {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#link-resolver}\n\t */\n\tlinkResolver?: LinkResolverFunction;\n\n\t/**\n\t * An explicit `target` attribute to apply to the rendered link.\n\t */\n\ttarget?: string | null;\n\n\t/**\n\t * An explicit `rel` attribute to apply to the rendered link.\n\t */\n\trel?: string | null;\n\n\t/**\n\t * Value of the `rel` attribute to use on links rendered with\n\t * `target=\"_blank\"`.\n\t *\n\t * @defaultValue The one provided to `@prismicio/vue` plugin if configured, `\"noopener noreferrer\"` otherwise.\n\t */\n\tblankTargetRelAttribute?: string | null;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to render\n\t * internal links.\n\t *\n\t * @remarks\n\t * HTML tag names will be rendered using the anchor tag interface (`href`,\n\t * `target`, and `rel` attributes).\n\t * @remarks\n\t * Components will be rendered using Vue Router {@link RouterLink} interface\n\t * (`to` props).\n\t * @defaultValue The one provided to `@prismicio/vue` plugin if configured, {@link RouterLink} otherwise.\n\t */\n\tinternalComponent?: string | ConcreteComponent;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to render\n\t * external links.\n\t *\n\t * @remarks\n\t * HTML tag names will be rendered using the anchor tag interface (`href`,\n\t * `target`, and `rel` attributes).\n\t * @remarks\n\t * Components will be rendered using Vue Router {@link RouterLink} interface\n\t * (`to` props).\n\t * @defaultValue The one provided to `@prismicio/vue` plugin if configured, `\"a\"` otherwise.\n\t */\n\texternalComponent?: string | ConcreteComponent;\n};\n\n/**\n * Options for {@link usePrismicLink}.\n */\nexport type UsePrismicLinkOptions = VueUseOptions<PrismicLinkProps>;\n\n/**\n * Return type of {@link usePrismicLink}.\n */\nexport type UsePrismicLinkReturnType = {\n\t/**\n\t * Suggested component to render for provided link field.\n\t */\n\ttype: ComputedRef<string | ConcreteComponent>;\n\n\t/**\n\t * Resolved anchor `href` value.\n\t */\n\thref: ComputedRef<string>;\n\n\t/**\n\t * Resolved anchor `target` value.\n\t */\n\ttarget: ComputedRef<string | null>;\n\n\t/**\n\t * Resolved anchor `rel` value.\n\t */\n\trel: ComputedRef<string | null>;\n};\n\n/**\n * A low level composable that returns resolved information about a Prismic link\n * field.\n *\n * @param props - {@link UsePrismicLinkOptions}\n *\n * @returns - Resolved link information {@link UsePrismicLinkReturnType}\n */\nexport const usePrismicLink = (\n\tprops: UsePrismicLinkOptions,\n): UsePrismicLinkReturnType => {\n\tconst { options } = usePrismic();\n\n\tconst type = computed(() => {\n\t\tconst internalComponent =\n\t\t\tunref(props.internalComponent) ||\n\t\t\toptions.components?.linkInternalComponent ||\n\t\t\tdefaultInternalComponent;\n\n\t\tconst externalComponent =\n\t\t\tunref(props.externalComponent) ||\n\t\t\toptions.components?.linkExternalComponent ||\n\t\t\tdefaultExternalComponent;\n\n\t\treturn href.value && isInternalURL(href.value) && !target.value\n\t\t\t? internalComponent\n\t\t\t: externalComponent;\n\t});\n\tconst href = computed(() => {\n\t\tconst field = unref(props.field);\n\t\tconst linkResolver = unref(props.linkResolver) ?? options.linkResolver;\n\n\t\treturn asLink(field, linkResolver) ?? \"\";\n\t});\n\tconst target = computed(() => {\n\t\tconst field = unref(props.field);\n\t\tconst target = unref(props.target);\n\n\t\tif (typeof target !== \"undefined\") {\n\t\t\treturn target;\n\t\t} else {\n\t\t\treturn field && \"target\" in field && field.target ? field.target : null;\n\t\t}\n\t});\n\tconst rel = computed(() => {\n\t\tconst rel = unref(props.rel);\n\n\t\tif (typeof rel !== \"undefined\") {\n\t\t\treturn rel;\n\t\t} else if (target.value === \"_blank\") {\n\t\t\tconst blankTargetRelAttribute = unref(props.blankTargetRelAttribute);\n\n\t\t\tif (typeof blankTargetRelAttribute !== \"undefined\") {\n\t\t\t\treturn blankTargetRelAttribute;\n\t\t\t} else {\n\t\t\t\treturn typeof options.components?.linkBlankTargetRelAttribute !==\n\t\t\t\t\t\"undefined\"\n\t\t\t\t\t? options.components.linkBlankTargetRelAttribute\n\t\t\t\t\t: defaultBlankTargetRelAttribute;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t});\n\n\treturn {\n\t\ttype,\n\t\thref,\n\t\ttarget,\n\t\trel,\n\t};\n};\n\n/**\n * `<PrismicLink />` implementation.\n *\n * @internal\n */\nexport const PrismicLinkImpl = /*#__PURE__*/ defineComponent({\n\tname: \"PrismicLink\",\n\tprops: {\n\t\tfield: {\n\t\t\ttype: Object as PropType<LinkField | PrismicDocument>,\n\t\t\trequired: true,\n\t\t},\n\t\tlinkResolver: {\n\t\t\ttype: Function as PropType<LinkResolverFunction>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\ttarget: {\n\t\t\ttype: String as PropType<string | null>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\trel: {\n\t\t\ttype: String as PropType<string | null>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tblankTargetRelAttribute: {\n\t\t\ttype: String as PropType<string | null>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tinternalComponent: {\n\t\t\ttype: [String, Object, Function] as PropType<string | ConcreteComponent>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\texternalComponent: {\n\t\t\ttype: [String, Object, Function] as PropType<string | ConcreteComponent>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t},\n\tsetup(props, { slots }) {\n\t\t// Prevent fatal if user didn't check for field, throws `Invalid prop` warn\n\t\tif (!props.field) {\n\t\t\treturn () => null;\n\t\t}\n\n\t\tconst { type, href, target, rel } = usePrismicLink(props);\n\n\t\treturn () => {\n\t\t\tconst parent =\n\t\t\t\ttype.value === \"a\" ? \"a\" : simplyResolveComponent(type.value);\n\t\t\tconst computedSlots = getSlots(\n\t\t\t\tparent,\n\t\t\t\tslots,\n\t\t\t\treactive({ href: href.value }),\n\t\t\t);\n\n\t\t\tif (typeof parent === \"string\") {\n\t\t\t\t// Fitting anchor tag interface\n\t\t\t\treturn h(\n\t\t\t\t\tparent,\n\t\t\t\t\t{ href: href.value, target: target.value, rel: rel.value },\n\t\t\t\t\tcomputedSlots,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// Fitting Vue Router Link interface\n\t\t\t\treturn h(parent, { to: href.value }, computedSlots);\n\t\t\t}\n\t\t};\n\t},\n});\n\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to render a Prismic link field.\n *\n * @see Component props {@link PrismicLinkProps}\n * @see Templating link fields {@link https://prismic.io/docs/technologies/vue-template-content#links-and-content-relationships}\n */\nexport const PrismicLink = PrismicLinkImpl as unknown as {\n\tnew (): {\n\t\t$props: AllowedComponentProps &\n\t\t\tComponentCustomProps &\n\t\t\tVNodeProps &\n\t\t\tPrismicLinkProps;\n\t};\n};\n", "import {\n\tAllowedComponentProps,\n\tComponentCustomProps,\n\tcomputed,\n\tComputedRef,\n\tConcreteComponent,\n\tdefineComponent,\n\th,\n\tPropType,\n\tunref,\n\tVNode,\n\tVNodeProps,\n} from \"vue\";\n\nimport { asText, isFilled } from \"@prismicio/helpers\";\nimport { RichTextField } from \"@prismicio/types\";\n\nimport { VueUseOptions } from \"../types\";\nimport { simplyResolveComponent } from \"../lib/simplyResolveComponent\";\n\n/**\n * The default component rendered to wrap the text output.\n */\nconst defaultWrapper = \"div\";\n/**\n * Props for `<PrismicText />`.\n */\nexport type PrismicTextProps = {\n\t/**\n\t * The Prismic rich text or title field to render.\n\t */\n\tfield: RichTextField | null | undefined;\n\n\t/**\n\t * Separator used to join each element.\n\t *\n\t * @defaultValue `\" \"` (a space)\n\t */\n\tseparator?: string;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to wrap the\n\t * output.\n\t *\n\t * @defaultValue `\"div\"`\n\t */\n\twrapper?: string | ConcreteComponent;\n\n\t/**\n\t * The string value to be rendered when the field is empty. If a fallback is\n\t * not given, `\"\"` (nothing) will be rendered.\n\t */\n\tfallback?: string;\n};\n\n/**\n * Options for {@link usePrismicText}.\n */\nexport type UsePrismicTextOptions = VueUseOptions<\n\tOmit<PrismicTextProps, \"wrapper\">\n>;\n\n/**\n * Return type of {@link usePrismicText}.\n */\nexport type UsePrismicTextReturnType = {\n\t/**\n\t * Serialized rich text field as plain text.\n\t */\n\ttext: ComputedRef<string>;\n};\n\n/**\n * A low level composable that returns a serialized rich text field as plain\n * text.\n *\n * @param props - {@link UsePrismicTextOptions}\n *\n * @returns - Serialized rich text field as plain text\n *   {@link UsePrismicTextReturnType}\n */\nexport const usePrismicText = (\n\tprops: UsePrismicTextOptions,\n): UsePrismicTextReturnType => {\n\tconst text = computed(() => {\n\t\tconst field = unref(props.field);\n\n\t\tif (!isFilled.richText(field)) {\n\t\t\treturn unref(props.fallback) ?? \"\";\n\t\t}\n\n\t\treturn asText(unref(field), unref(props.separator));\n\t});\n\n\treturn {\n\t\ttext,\n\t};\n};\n\n/**\n * `<PrismicText />` implementation.\n *\n * @internal\n */\nexport const PrismicTextImpl = /*#__PURE__*/ defineComponent({\n\tname: \"PrismicText\",\n\tprops: {\n\t\tfield: {\n\t\t\ttype: Array as unknown as PropType<RichTextField | null | undefined>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tseparator: {\n\t\t\ttype: String as PropType<string>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\twrapper: {\n\t\t\ttype: [String, Object, Function] as PropType<string | ConcreteComponent>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tfallback: {\n\t\t\ttype: String as PropType<string>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t},\n\tsetup(props) {\n\t\tconst { text } = usePrismicText(props);\n\n\t\treturn () => {\n\t\t\tconst parent = simplyResolveComponent(props.wrapper || defaultWrapper);\n\n\t\t\t// This works but is absurd\n\t\t\t// if (typeof parent === \"string\") {\n\t\t\t// \treturn h(parent, null, { default: () => text.value });\n\t\t\t// } else {\n\t\t\t// \treturn h(parent, null, { default: () => text.value });\n\t\t\t// }\n\n\t\t\treturn h(parent as VNode, null, {\n\t\t\t\tdefault: () => text.value,\n\t\t\t});\n\t\t};\n\t},\n});\n\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to render a Prismic rich text field as plain text.\n *\n * @see Component props {@link PrismicTextProps}\n * @see Templating rich text and title fields {@link https://prismic.io/docs/technologies/vue-template-content#rich-text-and-titles}\n */\nexport const PrismicText = PrismicTextImpl as unknown as {\n\tnew (): {\n\t\t$props: AllowedComponentProps &\n\t\t\tComponentCustomProps &\n\t\t\tVNodeProps &\n\t\t\tPrismicTextProps;\n\t};\n};\n", "import {\n\tAllowedComponentProps,\n\tComponent,\n\tComponentCustomProps,\n\tcomputed,\n\tComputedRef,\n\tConcreteComponent,\n\tdefineComponent,\n\th,\n\tinject,\n\tnextTick,\n\tonBeforeUnmount,\n\tPropType,\n\tref,\n\tunref,\n\tVNodeProps,\n\twatch,\n} from \"vue\";\nimport { routerKey } from \"vue-router\";\n\nimport {\n\tasHTML,\n\tHTMLFunctionSerializer,\n\tHTMLMapSerializer,\n\tisFilled,\n\tLinkResolverFunction,\n} from \"@prismicio/helpers\";\nimport { RichTextField } from \"@prismicio/types\";\n\nimport { VueUseOptions } from \"../types\";\nimport { usePrismic } from \"../usePrismic\";\nimport { simplyResolveComponent } from \"../lib/simplyResolveComponent\";\nimport { isInternalURL } from \"../lib/isInternalURL\";\n\n/**\n * The default component rendered to wrap the HTML output.\n */\nconst defaultWrapper = \"div\";\n\n/**\n * Props for `<PrismicRichText />`.\n */\nexport type PrismicRichTextProps = {\n\t/**\n\t * The Prismic rich text or title field to render.\n\t */\n\tfield: RichTextField | null | undefined;\n\n\t/**\n\t * A link resolver function used to resolve link when not using the route\n\t * resolver parameter with `@prismicio/client`.\n\t *\n\t * @defaultValue The link resolver provided to `@prismicio/vue` plugin if configured.\n\t *\n\t * @see Link resolver documentation {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#link-resolver}\n\t */\n\tlinkResolver?: LinkResolverFunction;\n\n\t/**\n\t * An HTML serializer to customize the way rich text fields are rendered.\n\t *\n\t * @defaultValue The HTML serializer provided to `@prismicio/vue` plugin if configured.\n\t *\n\t * @see HTML serializer documentation {@link https://prismic.io/docs/core-concepts/html-serializer}\n\t */\n\thtmlSerializer?: HTMLFunctionSerializer | HTMLMapSerializer;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to wrap the\n\t * output.\n\t *\n\t * @defaultValue `\"div\"`\n\t */\n\twrapper?: string | ConcreteComponent;\n\n\t/**\n\t * The HTML value to be rendered when the field is empty. If a fallback is not\n\t * given, `\"\"` (nothing) will be rendered.\n\t */\n\tfallback?: string;\n};\n\n/**\n * Options for {@link usePrismicRichText}.\n */\nexport type UsePrismicRichTextOptions = VueUseOptions<\n\tOmit<PrismicRichTextProps, \"wrapper\">\n>;\n\n/**\n * Return type of {@link usePrismicRichText}.\n */\nexport type UsePrismicRichTextReturnType = {\n\t/**\n\t * Serialized rich text field as HTML.\n\t */\n\thtml: ComputedRef<string>;\n};\n\n/**\n * A low level composable that returns a serialized rich text field as HTML.\n *\n * @param props - {@link UsePrismicRichTextOptions}\n *\n * @returns - Serialized rich text field as HTML\n *   {@link UsePrismicRichTextReturnType}\n */\nexport const usePrismicRichText = (\n\tprops: UsePrismicRichTextOptions,\n): UsePrismicRichTextReturnType => {\n\tconst { options } = usePrismic();\n\n\tconst html = computed(() => {\n\t\tconst field = unref(props.field);\n\n\t\tif (!isFilled.richText(field)) {\n\t\t\treturn unref(props.fallback) ?? \"\";\n\t\t}\n\n\t\tconst linkResolver = unref(props.linkResolver) ?? options.linkResolver;\n\t\tconst htmlSerializer =\n\t\t\tunref(props.htmlSerializer) ?? options.htmlSerializer;\n\n\t\treturn asHTML(unref(field), linkResolver, htmlSerializer);\n\t});\n\n\treturn {\n\t\thtml,\n\t};\n};\n\n/**\n * `<PrismicRichText />` implementation.\n *\n * @internal\n */\nexport const PrismicRichTextImpl = /*#__PURE__*/ defineComponent({\n\tname: \"PrismicRichText\",\n\tprops: {\n\t\tfield: {\n\t\t\ttype: Array as unknown as PropType<RichTextField | null | undefined>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tlinkResolver: {\n\t\t\ttype: Function as PropType<LinkResolverFunction>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\thtmlSerializer: {\n\t\t\ttype: [Function, Object] as PropType<\n\t\t\t\tHTMLFunctionSerializer | HTMLMapSerializer\n\t\t\t>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\twrapper: {\n\t\t\ttype: [String, Object, Function] as PropType<string | ConcreteComponent>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tfallback: {\n\t\t\ttype: String as PropType<string>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t},\n\tsetup(props) {\n\t\tconst { html } = usePrismicRichText(props);\n\n\t\tconst root = ref<HTMLElement | Comment | Component | null>(null);\n\n\t\tconst maybeRouter = inject(routerKey, null);\n\t\tif (maybeRouter) {\n\t\t\ttype InternalLink = {\n\t\t\t\telement: HTMLAnchorElement;\n\t\t\t\tlistener: EventListener;\n\t\t\t};\n\t\t\tlet links: InternalLink[] = [];\n\n\t\t\tconst navigate: EventListener = function (\n\t\t\t\tthis: { href: string },\n\t\t\t\tevent: Event,\n\t\t\t) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tmaybeRouter.push(this.href);\n\t\t\t};\n\n\t\t\tconst addListeners = () => {\n\t\t\t\tconst node: HTMLElement | Comment | null =\n\t\t\t\t\troot.value && \"$el\" in root.value ? root.value.$el : root.value;\n\t\t\t\tif (node && \"querySelectorAll\" in node) {\n\t\t\t\t\t// Get all internal link tags and add listeners on them\n\t\t\t\t\tlinks = Array.from(node.querySelectorAll(\"a\"))\n\t\t\t\t\t\t.map((element) => {\n\t\t\t\t\t\t\tconst href = element.getAttribute(\"href\");\n\n\t\t\t\t\t\t\tif (href && isInternalURL(href)) {\n\t\t\t\t\t\t\t\tconst listener = navigate.bind({ href });\n\t\t\t\t\t\t\t\telement.addEventListener(\"click\", listener);\n\n\t\t\t\t\t\t\t\treturn { element, listener };\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.filter((link): link is InternalLink => link as boolean);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst removeListeners = () => {\n\t\t\t\tlinks.forEach(({ element, listener }) =>\n\t\t\t\t\telement.removeEventListener(\"click\", listener),\n\t\t\t\t);\n\t\t\t\tlinks = [];\n\t\t\t};\n\n\t\t\twatch(\n\t\t\t\thtml,\n\t\t\t\t() => {\n\t\t\t\t\tremoveListeners();\n\t\t\t\t\tnextTick(addListeners);\n\t\t\t\t},\n\t\t\t\t{ immediate: true },\n\t\t\t);\n\n\t\t\tonBeforeUnmount(() => {\n\t\t\t\tremoveListeners();\n\t\t\t});\n\t\t}\n\n\t\treturn () => {\n\t\t\treturn h(simplyResolveComponent(props.wrapper || defaultWrapper), {\n\t\t\t\tinnerHTML: html.value,\n\t\t\t\tref: root,\n\t\t\t});\n\t\t};\n\t},\n});\n\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to render a Prismic rich text field as HTML.\n *\n * @see Component props {@link PrismicRichTextProps}\n * @see Templating rich text and title fields {@link https://prismic.io/docs/technologies/vue-template-content#rich-text-and-titles}\n */\nexport const PrismicRichText = PrismicRichTextImpl as unknown as {\n\tnew (): {\n\t\t$props: AllowedComponentProps &\n\t\t\tComponentCustomProps &\n\t\t\tVNodeProps &\n\t\t\tPrismicRichTextProps;\n\t};\n};\n", "import {\n\tAllowedComponentProps,\n\tComponentCustomProps,\n\tcomputed,\n\tConcreteComponent,\n\tDefineComponent,\n\tdefineComponent,\n\tFunctionalComponent,\n\th,\n\tmarkRaw,\n\tPropType,\n\tVNodeProps,\n\twatchEffect,\n} from \"vue\";\n\nimport { Slice } from \"@prismicio/types\";\n\nimport { simplyResolveComponent } from \"../lib/simplyResolveComponent\";\nimport { __PRODUCTION__ } from \"../lib/__PRODUCTION__\";\nimport { usePrismic } from \"../usePrismic\";\n\n/**\n * Returns the type of a `SliceLike` type.\n *\n * @typeParam TSlice - The Slice from which the type will be extracted.\n */\ntype ExtractSliceType<TSlice extends SliceLike> = TSlice extends SliceLikeRestV2\n\t? TSlice[\"slice_type\"]\n\t: TSlice extends SliceLikeGraphQL\n\t? TSlice[\"type\"]\n\t: never;\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * Rest API V2 for the `<SliceZone>` component.\n *\n * If using Prismic's Rest API V2, use the `Slice` export from\n * `@prismicio/types` for a full interface.\n *\n * @typeParam TSliceType - Type name of the Slice.\n */\nexport type SliceLikeRestV2<TSliceType extends string = string> = {\n\tslice_type: Slice<TSliceType>[\"slice_type\"];\n\tid?: string;\n};\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * GraphQL API for the `<SliceZone>` component.\n *\n * @typeParam TSliceType - Type name of the Slice.\n */\nexport type SliceLikeGraphQL<TSliceType extends string = string> = {\n\ttype: Slice<TSliceType>[\"slice_type\"];\n};\n\n/**\n * The minimum required properties to represent a Prismic Slice for the\n * `<SliceZone />` component.\n *\n * If using Prismic's REST API, use the `Slice` export from `@prismicio/types`\n * for a full interface.\n *\n * @typeParam TSliceType - Type name of the Slice\n */\nexport type SliceLike<TSliceType extends string = string> =\n\t| SliceLikeRestV2<TSliceType>\n\t| SliceLikeGraphQL<TSliceType>;\n\n/**\n * A looser version of the `SliceZone` type from `@prismicio/types` using\n * `SliceLike`.\n *\n * If using Prismic's REST API, use the `SliceZone` export from\n * `@prismicio/types` for the full type.\n *\n * @typeParam TSlice - The type(s) of slices in the Slice Zone\n */\nexport type SliceZoneLike<TSlice extends SliceLike = SliceLike> =\n\treadonly TSlice[];\n\n/**\n * Vue props for a component rendering content from a Prismic Slice using the\n * `<SliceZone />` component.\n *\n * @typeParam TSlice - The type(s) of slices in the Slice Zone\n * @typeParam TContext - Arbitrary data passed to `<SliceZone />` and made\n *   available to all Slice components\n */\nexport type SliceComponentProps<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n> = {\n\t/**\n\t * Slice data for this component.\n\t */\n\tslice: TSlice;\n\n\t/**\n\t * The index of the Slice in the Slice Zone.\n\t */\n\tindex: number;\n\n\t/**\n\t * All Slices from the Slice Zone to which the Slice belongs.\n\t */\n\t// TODO: We have to keep this list of Slices general due to circular\n\t// reference limtiations. If we had another generic to determine the full\n\t// union of Slice types, it would include TSlice. This causes TypeScript to\n\t// throw a compilation error.\n\tslices: SliceZoneLike<SliceLike>;\n\n\t/**\n\t * Arbitrary data passed to `<SliceZone />` and made available to all Slice\n\t * components.\n\t */\n\tcontext: TContext;\n};\n\n/**\n * Native Vue props for a component rendering content from a Prismic Slice using\n * the `<SliceZone />` component.\n *\n * @typeParam TSlice - The Slice type\n * @typeParam TContext - Arbitrary data passed to `<SliceZone />` and made\n *   available to all Slice components\n */\nexport type DefineComponentSliceComponentProps<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n> = {\n\tslice: {\n\t\ttype: PropType<SliceComponentProps<TSlice, TContext>[\"slice\"]>;\n\t\trequired: true;\n\t};\n\tindex: {\n\t\ttype: PropType<SliceComponentProps<TSlice, TContext>[\"index\"]>;\n\t\trequired: true;\n\t};\n\tslices: {\n\t\ttype: PropType<SliceComponentProps<TSlice, TContext>[\"slices\"]>;\n\t\trequired: true;\n\t};\n\tcontext: {\n\t\ttype: PropType<SliceComponentProps<TSlice, TContext>[\"context\"]>;\n\t\trequired: true;\n\t};\n};\n\n/**\n * Gets native Vue props for a component rendering content from a Prismic Slice\n * using the `<SliceZone />` component. Props are: `[\"slice\", \"index\", \"slices\",\n * \"context\"]`\n *\n * @example Defining a new slice component:\n *\n * ```javascript\n * import { getSliceComponentProps } from \"@prismicio/vue\";\n *\n * export default {\n * \tprops: getSliceComponentProps(),\n * };\n * ```\n *\n * @example Defining a new slice component with visual hint:\n *\n * ```javascript\n * import { getSliceComponentProps } from \"@prismicio/vue\";\n *\n * export default {\n * \tprops: getSliceComponentProps([\"slice\", \"index\", \"slices\", \"context\"]),\n * };\n * ```\n *\n * @typeParam TSlice - The Slice type\n * @typeParam TContext - Arbitrary data passed to `<SliceZone />` and made\n *   available to all Slice components\n * @param propsHint - An optional array of prop names used for the sole purpose\n *   of having a visual hint of which props are made available to the slice,\n *   this parameters doesn't have any effect\n *\n * @returns Props object to use with {@link defineComponent}\n */\nexport const getSliceComponentProps = <\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n>(\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tpropsHint?: [\"slice\", \"index\", \"slices\", \"context\"],\n): DefineComponentSliceComponentProps<TSlice, TContext> => ({\n\tslice: {\n\t\ttype: Object as PropType<SliceComponentProps<TSlice, TContext>[\"slice\"]>,\n\t\trequired: true,\n\t},\n\tindex: {\n\t\ttype: Number as PropType<SliceComponentProps<TSlice, TContext>[\"index\"]>,\n\t\trequired: true,\n\t},\n\tslices: {\n\t\ttype: Array as PropType<SliceComponentProps<TSlice, TContext>[\"slices\"]>,\n\t\trequired: true,\n\t},\n\tcontext: {\n\t\ttype: null as unknown as PropType<\n\t\t\tSliceComponentProps<TSlice, TContext>[\"context\"]\n\t\t>,\n\t\trequired: true,\n\t},\n});\n\n/**\n * A Vue component to be rendered for each instance of its Slice.\n *\n * @typeParam TSlice - The type(s) of slices in the Slice Zone\n * @typeParam TContext - Arbitrary data made available to all Slice components\n */\nexport type SliceComponentType<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n> =\n\t| DefineComponent<SliceComponentProps<TSlice, TContext>>\n\t| FunctionalComponent<SliceComponentProps<TSlice, TContext>>;\n\n/**\n * This Slice component can be used as a reminder to provide a proper\n * implementation.\n *\n * This is also the default Vue component rendered when a component mapping\n * cannot be found in `<SliceZone />`.\n */\nexport const TODOSliceComponent = __PRODUCTION__\n\t? ((() => null) as FunctionalComponent<SliceComponentProps>)\n\t: /*#__PURE__*/ (defineComponent({\n\t\t\tname: \"TODOSliceComponent\",\n\t\t\tprops: getSliceComponentProps(),\n\t\t\tsetup(props) {\n\t\t\t\tconst type = computed(() =>\n\t\t\t\t\t\"slice_type\" in props.slice\n\t\t\t\t\t\t? props.slice.slice_type\n\t\t\t\t\t\t: props.slice.type,\n\t\t\t\t);\n\n\t\t\t\twatchEffect(() => {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[SliceZone] Could not find a component for Slice type \"${type.value}\"`,\n\t\t\t\t\t\tprops.slice,\n\t\t\t\t\t);\n\t\t\t\t});\n\n\t\t\t\treturn () => {\n\t\t\t\t\treturn h(\n\t\t\t\t\t\t\"section\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"data-slice-zone-todo-component\": \"\",\n\t\t\t\t\t\t\t\"data-slice-type\": type.value,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t[`Could not find a component for Slice type \"${type.value}\"`],\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t},\n\t  }) as SliceComponentType);\n\n/**\n * A record of Slice types mapped to Vue components. Each components will be\n * rendered for each instance of their Slice type.\n *\n * @typeParam TSlice - The type(s) of slices in the Slice Zone\n * @typeParam TContext - Arbitrary data made available to all Slice components\n */\nexport type SliceZoneComponents<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> =\n\t// This is purposely not wrapped in Partial to ensure a component is provided\n\t// for all Slice types. <SliceZone /> will render a default component if one is\n\t// not provided, but it *should* be a type error if an explicit component is\n\t// missing.\n\t//\n\t// If a developer purposely does not want to provide a component, they can\n\t// assign it to the TODOSliceComponent exported from this package. This\n\t// signals to future developers that it is a placeholder and should be\n\t// implemented.\n\t{\n\t\t[SliceType in ExtractSliceType<TSlice>]:\n\t\t\t| SliceComponentType<Extract<TSlice, SliceLike<SliceType>>, TContext>\n\t\t\t| string;\n\t};\n\n/**\n * Gets an optimized record of Slice types mapped to Vue components. Each\n * components will be rendered for each instance of their Slice type.\n *\n * @remarks\n * This is essentially an helper function to ensure {@link markRaw} is correctly\n * applied on each components, improving performances.\n * @example Defining a slice components:\n *\n * ```javascript\n * import { defineSliceZoneComponents } from \"@prismicio/vue\";\n *\n * export default {\n *   data() {\n *     components: defineSliceZoneComponents({\n *       foo: Foo,\n *       bar: defineAsyncComponent(\n *         () => new Promise((res) => res(Bar)),\n *       ),\n *       baz: \"Baz\",\n *     }),\n *   }\n * };\n * ```\n *\n * @typeParam TSlice - The type(s) of slices in the Slice Zone\n * @typeParam TContext - Arbitrary data made available to all Slice components\n *\n * @param components - {@link SliceZoneComponents}\n *\n * @returns A new optimized record of {@link SliceZoneComponents}\n */\nexport const defineSliceZoneComponents = <\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n>(\n\tcomponents: SliceZoneComponents<TSlice, TContext>,\n): SliceZoneComponents<TSlice, TContext> => {\n\tconst result = {} as SliceZoneComponents<TSlice, TContext>;\n\n\tlet type: keyof typeof components;\n\tfor (type in components) {\n\t\tconst component = components[type];\n\t\tresult[type] =\n\t\t\ttypeof component === \"string\"\n\t\t\t\t? component\n\t\t\t\t: markRaw(\n\t\t\t\t\t\tcomponent as SliceComponentType<\n\t\t\t\t\t\t\tExtract<TSlice, SliceLike<typeof type>>,\n\t\t\t\t\t\t\tTContext\n\t\t\t\t\t\t>,\n\t\t\t\t  );\n\t}\n\n\treturn result;\n};\n\n/**\n * Arguments for a `<SliceZone>` `resolver` function.\n */\nexport type SliceZoneResolverArgs<TSlice extends SliceLike = SliceLike> = {\n\t/**\n\t * The Slice to resolve to a Vue component..\n\t */\n\tslice: TSlice;\n\n\t/**\n\t * The name of the Slice.\n\t */\n\tsliceName: ExtractSliceType<TSlice>;\n\n\t/**\n\t * The index of the Slice in the Slice Zone.\n\t */\n\ti: number;\n};\n\n/**\n * A function that determines the rendered Vue component for each Slice in the\n * Slice Zone. If a nullish value is returned, the component will fallback to\n * the `components` or `defaultComponent` props to determine the rendered\n * component.\n *\n * @deprecated Use the `components` prop instead.\n *\n * @param args - Arguments for the resolver function.\n *\n * @returns The Vue component to render for a Slice.\n */\nexport type SliceZoneResolver<\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tTSlice extends SliceLike = any,\n\tTContext = unknown,\n> = (\n\targs: SliceZoneResolverArgs<TSlice>,\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => SliceComponentType<any, TContext> | string | undefined | null;\n\n/**\n * Props for `<SliceZone />`.\n *\n * @typeParam TContext - Arbitrary data made available to all Slice components\n */\nexport type SliceZoneProps<TContext = unknown> = {\n\t/**\n\t * List of Slice data from the Slice Zone.\n\t */\n\tslices: SliceZoneLike;\n\n\t/**\n\t * A record mapping Slice types to Vue components.\n\t */\n\tcomponents?: SliceZoneComponents;\n\n\t/**\n\t * A function that determines the rendered Vue component for each Slice in the\n\t * Slice Zone.\n\t *\n\t * @deprecated Use the `components` prop instead.\n\t *\n\t * @param args - Arguments for the resolver function.\n\t *\n\t * @returns The Vue component to render for a Slice.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tresolver?: SliceZoneResolver<any, TContext>;\n\n\t/**\n\t * Arbitrary data made available to all Slice components.\n\t */\n\tcontext?: TContext;\n\n\t/**\n\t * A component or a functional component rendered if a component mapping from\n\t * the `components` prop cannot be found.\n\t *\n\t * @remarks\n\t * Components will be rendered using the {@link SliceComponentProps} interface.\n\t *\n\t * @defaultValue The Slice Zone default component provided to `@prismicio/vue` plugin if configured, otherwise `null` when `process.env.NODE_ENV === \"production\"` else {@link TODOSliceComponent}.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tdefaultComponent?: SliceComponentType<any, TContext>;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to wrap the\n\t * output. The Slice Zone is not wrapped by default.\n\t */\n\twrapper?: string | ConcreteComponent;\n};\n\n/**\n * `<SliceZone />` implementation.\n *\n * @internal\n */\nexport const SliceZoneImpl = /*#__PURE__*/ defineComponent({\n\tname: \"SliceZone\",\n\tprops: {\n\t\tslices: {\n\t\t\ttype: Array as PropType<SliceZoneLike>,\n\t\t\trequired: true,\n\t\t},\n\t\tcomponents: {\n\t\t\ttype: Object as PropType<SliceZoneComponents>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tresolver: {\n\t\t\ttype: Function as PropType<SliceZoneResolver>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tcontext: {\n\t\t\ttype: null,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\tdefaultComponent: {\n\t\t\ttype: Object as PropType<SliceComponentType>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t\twrapper: {\n\t\t\ttype: [String, Object, Function] as PropType<string | ConcreteComponent>,\n\t\t\tdefault: undefined,\n\t\t\trequired: false,\n\t\t},\n\t},\n\tsetup(props) {\n\t\t// Prevent fatal if user didn't check for field, throws `Invalid prop` warn\n\t\tif (!props.slices) {\n\t\t\treturn () => null;\n\t\t}\n\n\t\tconst { options } = usePrismic();\n\n\t\tconst renderedSlices = computed(() => {\n\t\t\treturn props.slices.map((slice, index) => {\n\t\t\t\tconst type = \"slice_type\" in slice ? slice.slice_type : slice.type;\n\n\t\t\t\tlet component =\n\t\t\t\t\tprops.components && type in props.components\n\t\t\t\t\t\t? props.components[type]\n\t\t\t\t\t\t: props.defaultComponent ||\n\t\t\t\t\t\t  options.components?.sliceZoneDefaultComponent ||\n\t\t\t\t\t\t  TODOSliceComponent;\n\n\t\t\t\t// TODO: Remove `resolver` in v3 in favor of `components`.\n\t\t\t\tif (props.resolver) {\n\t\t\t\t\tconst resolvedComponent = props.resolver({\n\t\t\t\t\t\tslice,\n\t\t\t\t\t\tsliceName: type,\n\t\t\t\t\t\ti: index,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (resolvedComponent) {\n\t\t\t\t\t\tcomponent = resolvedComponent;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst key =\n\t\t\t\t\t\"id\" in slice && slice.id\n\t\t\t\t\t\t? slice.id\n\t\t\t\t\t\t: `${index}-${JSON.stringify(slice)}`;\n\n\t\t\t\tconst p = {\n\t\t\t\t\tkey,\n\t\t\t\t\tslice,\n\t\t\t\t\tindex,\n\t\t\t\t\tcontext: props.context,\n\t\t\t\t\tslices: props.slices,\n\t\t\t\t};\n\n\t\t\t\treturn h(simplyResolveComponent(component as ConcreteComponent), p);\n\t\t\t});\n\t\t});\n\n\t\treturn () => {\n\t\t\tif (props.wrapper) {\n\t\t\t\tconst parent = simplyResolveComponent(props.wrapper);\n\n\t\t\t\tif (typeof parent === \"string\") {\n\t\t\t\t\treturn h(parent, null, renderedSlices.value);\n\t\t\t\t} else {\n\t\t\t\t\treturn h(parent, null, { default: () => renderedSlices.value });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn renderedSlices.value;\n\t\t\t}\n\t\t};\n\t},\n});\n\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to render a Prismic Slice Zone.\n *\n * @see Component props {@link SliceZoneProps}\n * @see Templating Slice Zones {@link https://prismic.io/docs/technologies/vue-template-content#slices-and-groups}\n */\nexport const SliceZone = SliceZoneImpl as unknown as {\n\tnew (): {\n\t\t$props: AllowedComponentProps &\n\t\t\tComponentCustomProps &\n\t\t\tVNodeProps &\n\t\t\tSliceZoneProps;\n\t};\n};\n", "import { App } from \"vue\";\n\nimport {\n\tcreateClient,\n\tpredicate,\n\tcookie,\n\tClient,\n\tFetchLike,\n} from \"@prismicio/client\";\nimport {\n\tasText,\n\tasHTML,\n\tasLink,\n\tasDate,\n\tasImageSrc,\n\tasImageWidthSrcSet,\n\tasImagePixelDensitySrcSet,\n\tdocumentToLinkField,\n} from \"@prismicio/helpers\";\n\nimport {\n\tPrismicEmbed,\n\tPrismicImage,\n\tPrismicLink,\n\tPrismicRichText,\n\tPrismicText,\n\tSliceZone,\n} from \"./components\";\nimport { prismicKey } from \"./injectionSymbols\";\nimport type {\n\tPrismicPlugin,\n\tPrismicPluginClient,\n\tPrismicPluginHelpers,\n\tPrismicPluginOptions,\n} from \"./types\";\n\n/**\n * Creates a `@prismicio/vue` plugin instance that can be used by a Vue app.\n *\n * @param options - {@link PrismicPluginOptions}\n *\n * @returns `@prismicio/vue` plugin instance {@link PrismicPlugin}\n *\n * @see Prismic Official Vue.js documentation: {@link https://prismic.io/docs/technologies/vuejs}\n * @see Plugin repository: {@link https://github.com/prismicio/prismic-vue}\n */\nexport const createPrismic = (options: PrismicPluginOptions): PrismicPlugin => {\n\t// Create plugin client\n\tlet client: Client;\n\tif (options.client) {\n\t\tclient = options.client;\n\t} else {\n\t\tclient = createClient(options.endpoint, {\n\t\t\tfetch: async (endpoint, options) => {\n\t\t\t\tlet fetchFunction: FetchLike;\n\t\t\t\tif (typeof globalThis.fetch === \"function\") {\n\t\t\t\t\t// TODO: Remove after https://github.com/prismicio/prismic-client/issues/254\n\t\t\t\t\tfetchFunction = globalThis.fetch as FetchLike;\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Remove after https://github.com/prismicio/prismic-client/issues/254\n\t\t\t\t\tfetchFunction = (await import(\"isomorphic-unfetch\"))\n\t\t\t\t\t\t.default as FetchLike;\n\t\t\t\t}\n\n\t\t\t\treturn await fetchFunction(endpoint, options);\n\t\t\t},\n\t\t\t...options.clientConfig,\n\t\t});\n\t}\n\n\tconst prismicClient: PrismicPluginClient = {\n\t\tclient,\n\t\tpredicate,\n\t\tcookie,\n\t};\n\n\t// Create plugin helpers\n\tconst prismicHelpers: PrismicPluginHelpers = {\n\t\tasText,\n\t\tasHTML: (richTextField, linkResolver, htmlSerializer) => {\n\t\t\treturn asHTML(\n\t\t\t\trichTextField,\n\t\t\t\tlinkResolver || options.linkResolver,\n\t\t\t\thtmlSerializer || options.htmlSerializer,\n\t\t\t);\n\t\t},\n\t\tasLink: (linkField, linkResolver) => {\n\t\t\treturn asLink(linkField, linkResolver || options.linkResolver);\n\t\t},\n\t\tasDate,\n\t\tasImageSrc,\n\t\tasImageWidthSrcSet,\n\t\tasImagePixelDensitySrcSet,\n\t\tdocumentToLinkField,\n\t};\n\n\t// Create plugin interface\n\tconst prismic: PrismicPlugin = {\n\t\toptions,\n\n\t\t...prismicClient,\n\t\t...prismicHelpers,\n\n\t\tinstall(app: App): void {\n\t\t\tapp.provide(prismicKey, this);\n\t\t\tapp.config.globalProperties.$prismic = this;\n\n\t\t\tif (options.injectComponents !== false) {\n\t\t\t\tapp.component(PrismicLink.name, PrismicLink);\n\t\t\t\tapp.component(PrismicEmbed.name, PrismicEmbed);\n\t\t\t\tapp.component(PrismicImage.name, PrismicImage);\n\t\t\t\tapp.component(PrismicText.name, PrismicText);\n\t\t\t\tapp.component(PrismicRichText.name, PrismicRichText);\n\t\t\t\tapp.component(SliceZone.name, SliceZone);\n\t\t\t}\n\t\t},\n\t};\n\n\treturn prismic;\n};\n", "import type { App, ConcreteComponent, Ref } from \"vue\";\n\nimport type {\n\tClient,\n\tClientConfig,\n\tcookie,\n\tpredicate,\n} from \"@prismicio/client\";\nimport type {\n\tasText,\n\tasHTML,\n\tasLink,\n\tasDate,\n\tdocumentToLinkField,\n\tHTMLFunctionSerializer,\n\tHTMLMapSerializer,\n\tLinkResolverFunction,\n\tasImageSrc,\n\tasImageWidthSrcSet,\n\tasImagePixelDensitySrcSet,\n} from \"@prismicio/helpers\";\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// Imports for @link references:\n\nimport type { RouterLink } from \"vue-router\";\n\nimport type {\n\tSliceComponentProps,\n\tSliceComponentType,\n\tTODOSliceComponent,\n} from \"./components/SliceZone\";\n\nimport type { usePrismicDocuments } from \"./composables\";\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n\n/**\n * Options used by `@prismicio/vue` components.\n */\ntype PrismicPluginComponentsOptions = {\n\t/**\n\t * Value of the `rel` attribute to use on links rendered with\n\t * `target=\"_blank\"`\n\t *\n\t * @defaultValue `\"noopener noreferrer\"`\n\t */\n\tlinkBlankTargetRelAttribute?: string;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to render\n\t * internal links.\n\t *\n\t * @remarks\n\t * HTML tag names will be rendered using the anchor tag interface (`href`,\n\t * `target`, and `rel` attributes).\n\t * @remarks\n\t * Components will be rendered using Vue Router {@link RouterLink} interface\n\t * (`to` props).\n\t * @defaultValue {@link RouterLink}\n\t */\n\tlinkInternalComponent?: string | ConcreteComponent;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to render\n\t * external links.\n\t *\n\t * @remarks\n\t * HTML tag names will be rendered using the anchor tag interface (`href`,\n\t * `target`, and `rel` attributes).\n\t * @remarks\n\t * Components will be rendered using Vue Router {@link RouterLink} interface\n\t * (`to` props).\n\t * @defaultValue `\"a\"`\n\t */\n\tlinkExternalComponent?: string | ConcreteComponent;\n\n\t/**\n\t * An HTML tag name, a component, or a functional component used to render\n\t * images.\n\t *\n\t * @remarks\n\t * HTML tag names and components will be rendered using the `img` tag\n\t * interface (`src` and `alt` attribute). Components will also receive an\n\t * additional `copyright` props.\n\t * @defaultValue `\"img\"`\n\t */\n\timageComponent?: string | ConcreteComponent;\n\n\t/**\n\t * Default widths to use when rendering an image with `widths=\"defaults\"`\n\t *\n\t * @remarks\n\t * Consider configuring image widths within your content type definition and\n\t * using `widths=\"auto\"` instead to give content writers the ability to crop\n\t * images in the editor.\n\t * @defaultValue `@prismicio/helpers` defaults\n\t */\n\timageWidthSrcSetDefaults?: number[];\n\n\t/**\n\t * Default pixel densities to use when rendering an image with\n\t * `pixel-densities=\"defaults\"`\n\t *\n\t * @defaultValue `@prismicio/helpers` defaults\n\t */\n\timagePixelDensitySrcSetDefaults?: number[];\n\n\t/**\n\t * A component or a functional component rendered if a component mapping from\n\t * the `components` prop cannot be found.\n\t *\n\t * @remarks\n\t * Components will be rendered using the {@link SliceComponentProps} interface.\n\t *\n\t * @defaultValue `null` when `process.env.NODE_ENV === \"production\"` else {@link TODOSliceComponent}\n\t */\n\tsliceZoneDefaultComponent?: SliceComponentType;\n};\n\n/**\n * Common options supported by `@prismicio/vue` plugin.\n */\ntype PrismicPluginOptionsBase = {\n\t/**\n\t * An optional link resolver function used to resolve links to Prismic\n\t * documents when not using the route resolver parameter with\n\t * `@prismicio/client`.\n\t *\n\t * @see Link resolver documentation {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#link-resolver}\n\t */\n\tlinkResolver?: LinkResolverFunction;\n\n\t/**\n\t * An optional HTML serializer to customize the way rich text fields are\n\t * rendered.\n\t *\n\t * @see HTML serializer documentation {@link https://prismic.io/docs/core-concepts/html-serializer}\n\t */\n\thtmlSerializer?: HTMLFunctionSerializer | HTMLMapSerializer;\n\n\t/**\n\t * Whether or not to inject components globally.\n\t *\n\t * @defaultValue `true`\n\t */\n\tinjectComponents?: boolean;\n\n\t/**\n\t * Options used by Prismic Vue components.\n\t *\n\t * @see Components options {@link PrismicPluginComponentsOptions}\n\t */\n\tcomponents?: PrismicPluginComponentsOptions;\n};\n\n/**\n * Options to init `@prismicio/vue` plugin with a client instance.\n *\n * @see {@link PrismicPluginOptionsBase} for shared options\n */\ntype PrismicPluginOptionsWithClient = PrismicPluginOptionsBase & {\n\t/**\n\t * A `@prismicio/client` instance used to fetch content from a Prismic\n\t * repository to configure the plugin with.\n\t *\n\t * @remarks\n\t * The client will be used by `@prismicio/vue` composables, such as\n\t * {@link usePrismicDocuments} and exposed through `this.$prismic.client` and\n\t * `usePrismic().client`.\n\t * @see Prismic client documentation {@link https://prismic.io/docs/technologies/javascript}\n\t */\n\tclient: Client;\n\n\t/**\n\t * Ensures type union is a strict or.\n\t *\n\t * @internal\n\t */\n\tendpoint?: never;\n\n\t/**\n\t * Ensures type union is a strict or.\n\t *\n\t * @internal\n\t */\n\tclientConfig?: never;\n};\n\n/**\n * Options to init `@prismicio/vue` plugin with a repository ID or API endpoint.\n *\n * @see {@link PrismicPluginOptionsBase} for shared options\n */\ntype PrismicPluginOptionsWithEndpoint = PrismicPluginOptionsBase & {\n\t/**\n\t * A Prismic repository endpoint to init the plugin's `@prismicio/client`\n\t * instance used to fetch content from a Prismic repository with.\n\t *\n\t * @remarks\n\t * Said client will be used by `@prismicio/vue` composables, such as\n\t * {@link usePrismicDocuments} and exposed through `this.$prismic.client` and\n\t * `usePrismic().client`.\n\t * @example A repository ID:\n\t *\n\t *     \"my-repo\";\n\t *\n\t * @example A full repository endpoint:\n\t *\n\t *     \"https://my-repo.cdn.prismic.io/api/v2\";\n\t *\n\t * @see Prismic client documentation {@link https://prismic.io/docs/technologies/javascript}\n\t */\n\tendpoint: string;\n\n\t/**\n\t * An optional object to configure `@prismicio/client` instance further.\n\t *\n\t * @example Accessing a private private repository:\n\t *\n\t * ```javascript\n\t * {\n\t * \t\"accessToken\": \"abc\"\n\t * }\n\t * ```\n\t *\n\t * @example Using a route resolver:\n\t *\n\t * ```javascript\n\t * {\n\t * \t\"defaultParams\": {\n\t * \t\t\"routes\": [\n\t * \t\t\t{\n\t * \t\t\t\t\"type\": \"page\",\n\t * \t\t\t\t\"path\": \"/:uid\"\n\t * \t\t\t},\n\t * \t\t\t{\n\t * \t\t\t\t\"type\": \"post\",\n\t * \t\t\t\t\"path\": \"/blog/:uid\"\n\t * \t\t\t}\n\t * \t\t]\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @see Prismic client documentation {@link https://prismic.io/docs/technologies/javascript}\n\t * @see Route resolver documentation {@link https://prismic.io/docs/core-concepts/link-resolver-route-resolver#route-resolver}\n\t */\n\tclientConfig?: ClientConfig;\n\n\t/**\n\t * Ensures type union is a strict or.\n\t *\n\t * @internal\n\t */\n\tclient?: never;\n};\n\n/**\n * `@prismicio/vue` plugin options.\n *\n * @see Prismic Official Vue.js documentation: {@link https://prismic.io/docs/technologies/vuejs}\n * @see Plugin repository: {@link https://github.com/prismicio/prismic-vue}\n */\nexport type PrismicPluginOptions =\n\t| PrismicPluginOptionsWithClient\n\t| PrismicPluginOptionsWithEndpoint;\n\n/**\n * `@prismicio/client` related methods and properties exposed by\n * `@prismicio/vue` plugin and accessible through `this.$prismic` and\n * `usePrismic()`.\n */\nexport type PrismicPluginClient = {\n\t/**\n\t * A `@prismicio/client` instance.\n\t */\n\tclient: Client;\n\n\t/**\n\t * Query predicates from `@prismicio/client`.\n\t */\n\tpredicate: typeof predicate;\n\n\t/**\n\t * Prismic cookies from `@prismicio/client`.\n\t */\n\tcookie: typeof cookie;\n};\n\n/**\n * `@prismicio/helpers` related methods exposed by `@prismicio/vue` plugin and\n * accessible through `this.$prismic` and `usePrismic()`.\n */\nexport type PrismicPluginHelpers = {\n\t/**\n\t * Serializes a rich text or title field to a plain text string. This is\n\t * `@prismicio/helpers` {@link asText} function.\n\t *\n\t * @see Templating rich text and title fields {@link https://prismic.io/docs/technologies/vue-template-content#rich-text-and-titles}\n\t */\n\tasText: typeof asText;\n\n\t/**\n\t * Serializes a rich text or title field to an HTML string. This is\n\t * `@prismicio/helpers` {@link asHTML} function.\n\t *\n\t * @remarks\n\t * If no `linkResolver` is provided the function will use the one provided to\n\t * the plugin at {@link PrismicPluginOptions.linkResolver} if available.\n\t * @remarks\n\t * If no `htmlSerializer` is provided the function will use the one provided\n\t * to the plugin at {@link PrismicPluginOptions.htmlSerializer} if available.\n\t * @see Templating rich text and title fields {@link https://prismic.io/docs/technologies/vue-template-content#rich-text-and-titles}\n\t */\n\tasHTML: typeof asHTML;\n\n\t/**\n\t * Resolves any type of link field or document to a URL. This is\n\t * `@prismicio/helpers` {@link asLink} function.\n\t *\n\t * @remarks\n\t * If no `linkResolver` is provided the function will use the one provided to\n\t * the plugin at {@link PrismicPluginOptions.linkResolver} if available.\n\t * @see Templating link fields {@link https://prismic.io/docs/technologies/vue-template-content#links-and-content-relationships}\n\t */\n\tasLink: (\n\t\tlinkField: Parameters<typeof asLink>[0],\n\t\tlinkResolver?: LinkResolverFunction,\n\t) => string | null;\n\n\t/**\n\t * Transforms a date or timestamp field into a JavaScript Date object. This is\n\t * `@prismicio/helpers` {@link asDate} function.\n\t */\n\tasDate: typeof asDate;\n\n\t/**\n\t * Returns the URL of an Image field with optional image transformations (via\n\t * Imgix URL parameters). This is `@prismicio/helpers` {@link asImageSrc}\n\t * function.\n\t */\n\tasImageSrc: typeof asImageSrc;\n\n\t/**\n\t * Creates a width-based `srcset` from an Image field with optional image\n\t * transformations (via Imgix URL parameters). This is `@prismicio/helpers`\n\t * {@link asImageWidthSrcSet} function.\n\t */\n\tasImageWidthSrcSet: typeof asImageWidthSrcSet;\n\n\t/**\n\t * Creates a pixel-density-based `srcset` from an Image field with optional\n\t * image transformations (via Imgix URL parameters). This is\n\t * `@prismicio/helpers` {@link asImagePixelDensitySrcSet} function.\n\t */\n\tasImagePixelDensitySrcSet: typeof asImagePixelDensitySrcSet;\n\n\t/**\n\t * Converts a document into a link field. This is `@prismicio/helpers`\n\t * {@link documentToLinkField} function.\n\t *\n\t * @internal\n\t */\n\tdocumentToLinkField: typeof documentToLinkField;\n};\n\n/**\n * Methods and properties exposed by `@prismicio/vue` plugin and accessible\n * through `this.$prismic` and `usePrismic()`.\n */\nexport type PrismicPlugin = {\n\t/**\n\t * Options uses to initialize the plugin.\n\t *\n\t * @see `@prismicio/vue` plugin options {@link PrismicPluginOptions}\n\t */\n\treadonly options: PrismicPluginOptions;\n\n\t/**\n\t * `@prismicio/vue` plugin install function used by Vue.\n\t *\n\t * @internal\n\t */\n\tinstall: (app: App) => void;\n} & PrismicPluginClient &\n\tPrismicPluginHelpers;\n\n/**\n * States of a `@prismicio/client` composable.\n */\nexport const enum PrismicClientComposableState {\n\t/**\n\t * The composable has not started fetching.\n\t */\n\tIdle = \"idle\",\n\n\t/**\n\t * The composable is fetching data.\n\t */\n\tPending = \"pending\",\n\n\t/**\n\t * The composable sucessfully fetched data.\n\t */\n\tSuccess = \"success\",\n\n\t/**\n\t * The composable failed to fetch data.\n\t */\n\tError = \"error\",\n}\n\n// Helpers\n\n/**\n * Type to transform a static object into one that allows passing Refs as\n * values.\n *\n * @internal\n */\nexport type VueUseOptions<T> = {\n\t[K in keyof T]: Ref<T[K]> | T[K];\n};\n\n/**\n * Type to transform a static tuple into one that allows passing Refs as values.\n *\n * @internal\n */\nexport type VueUseParameters<T> = {\n\t[K in keyof T]: T extends number ? Ref<T[K]> | T[K] : T[K];\n};\n", "import { isRef, ref, Ref, shallowRef, unref, watch } from \"vue\";\n\nimport {\n\tClient,\n\tForbiddenError,\n\tParsingError,\n\tPrismicError,\n} from \"@prismicio/client\";\n\nimport { usePrismic } from \"./usePrismic\";\nimport { PrismicClientComposableState, VueUseParameters } from \"./types\";\n\n// Helpers\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ClientMethodLike = (...args: any[]) => Promise<any> | any;\ntype ClientMethods = typeof Client.prototype;\ntype ClientError = PrismicError<unknown> | ParsingError | ForbiddenError;\n\n// Interfaces\n\n/**\n * @internal\n */\nexport type ClientMethodParameters<TMethodName extends keyof ClientMethods> =\n\tClientMethods[TMethodName] extends ClientMethodLike\n\t\t? VueUseParameters<Parameters<ClientMethods[TMethodName]>>\n\t\t: never;\n\n/**\n * @internal\n */\nexport type ClientMethodReturnType<TMethodName extends keyof ClientMethods> =\n\tClientMethods[TMethodName] extends ClientMethodLike\n\t\t? ReturnType<ClientMethods[TMethodName]>\n\t\t: never;\n\n/**\n * @internal\n */\nexport type ComposableOnlyParameters = {\n\tclient?: Ref<Client> | Client;\n};\n\n/**\n * The return type of a `@prismicio/client` Vue composable.\n *\n * @typeParam TData - The expected format of the `data` property of the returned\n *   object\n */\nexport type ClientComposableReturnType<TData = unknown> = {\n\t/**\n\t * The current state of the composable's client method call.\n\t */\n\tstate: Ref<PrismicClientComposableState>;\n\n\t/**\n\t * Data returned by the client.\n\t */\n\tdata: Ref<TData | null>;\n\n\t/**\n\t * Error returned by the composable's client method call if in an errror\n\t * state.\n\t */\n\terror: Ref<ClientError | Error | null>;\n\n\t/**\n\t * Perform the composable's client method call again.\n\t */\n\trefresh: () => Promise<void>;\n};\n\n/**\n * Determines if a value is a `@prismicio/client` params object.\n *\n * @param value - The value to check\n *\n * @returns `true` if `value` is a `@prismicio/client` params object, `false`\n *   otherwise\n */\nconst isParams = (\n\tvalue: unknown,\n): value is ClientMethodParameters<\"get\">[0] & ComposableOnlyParameters => {\n\t// This is a *very* naive check.\n\treturn typeof value === \"object\" && value !== null && !Array.isArray(value);\n};\n\n/**\n * A low level Vue composable that uses provided method name on plugin or\n * provided client with given arguments. The composable has its own internal\n * state manager to report async status, such as pending or error statuses.\n *\n * @typeParam TClientMethodName - A method name from `@prismicio/client`\n * @typeParam TClientMethodArguments - The method expected arguments\n * @typeParam TClientMethodReturnType - The method expected return type\n *\n * @param method - The `@prismicio/client` method name to use\n * @param args - The arguments to use with requested method\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @internal\n */\nexport const useStatefulPrismicClientMethod = <\n\tTClientMethodName extends keyof ClientMethods,\n\tTClientMethodArguments extends ClientMethodParameters<TClientMethodName>,\n\tTClientMethodReturnType extends UnwrapPromise<\n\t\tClientMethodReturnType<TClientMethodName>\n\t>,\n>(\n\tmethodName: TClientMethodName,\n\targs: TClientMethodArguments,\n): ClientComposableReturnType<TClientMethodReturnType> => {\n\tconst { client } = usePrismic();\n\n\tconst state = ref<PrismicClientComposableState>(\n\t\tPrismicClientComposableState.Idle,\n\t);\n\tconst data = shallowRef<TClientMethodReturnType | null>(null);\n\tconst error = ref<ClientError | Error | null>(null);\n\tconst refresh = async (): Promise<void> => {\n\t\tconst lastArg = unref(args[args.length - 1]);\n\t\tconst { client: explicitClient, ...params } = isParams(lastArg)\n\t\t\t? (lastArg as ClientMethodParameters<\"get\">[0] & ComposableOnlyParameters)\n\t\t\t: ({} as ComposableOnlyParameters);\n\t\tconst argsWithoutParams = isParams(lastArg) ? args.slice(0, -1) : args;\n\n\t\tstate.value = PrismicClientComposableState.Pending;\n\t\tdata.value = null;\n\t\terror.value = null;\n\t\ttry {\n\t\t\tdata.value = await (\n\t\t\t\t(unref(explicitClient) || client)[methodName] as ClientMethodLike\n\t\t\t)(\n\t\t\t\t...argsWithoutParams.map((arg: Ref<unknown> | unknown) => unref(arg)),\n\t\t\t\tparams,\n\t\t\t);\n\t\t\tstate.value = PrismicClientComposableState.Success;\n\t\t} catch (err) {\n\t\t\tstate.value = PrismicClientComposableState.Error;\n\t\t\terror.value = err as ClientError | Error;\n\t\t}\n\t};\n\n\t// Watch reactive args\n\tconst refArgs = args.filter((arg) => isRef(arg));\n\tif (refArgs.length) {\n\t\twatch(refArgs, refresh, { deep: true });\n\t}\n\n\t// Fetch once\n\trefresh();\n\n\treturn { state, data, error, refresh };\n};\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// Imports for @link references:\n\nimport type { Client } from \"@prismicio/client\";\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n\nimport { PrismicDocument, Query } from \"@prismicio/types\";\n\nimport {\n\tClientMethodParameters,\n\tClientComposableReturnType,\n\tuseStatefulPrismicClientMethod,\n\tComposableOnlyParameters,\n} from \"./useStatefulPrismicClientMethod\";\n\n// Composables\n\n/**\n * A composable that queries content from the Prismic repository.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.get}\n */\nexport const usePrismicDocuments = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tparams?: ClientMethodParameters<\"get\">[0] & ComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<Query<TDocument>> =>\n\tuseStatefulPrismicClientMethod(\"get\", args);\n\n/**\n * A composable that queries content from the Prismic repository and returns\n * only the first result, if any.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of the Prismic document returned\n *\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getFirst}\n */\nexport const useFirstPrismicDocument = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tparams?: ClientMethodParameters<\"getFirst\">[0] & ComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument> =>\n\tuseStatefulPrismicClientMethod(\"getFirst\", args);\n\n/**\n * A composable that queries a document from the Prismic repository with a\n * specific ID.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of the Prismic document returned\n *\n * @param id - ID of the document\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getByID}\n */\nexport const usePrismicDocumentByID = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tid: ClientMethodParameters<\"getByID\">[0],\n\t\tparams?: ClientMethodParameters<\"getByID\">[1] & ComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument> =>\n\tuseStatefulPrismicClientMethod(\"getByID\", args);\n\n/**\n * A composable that queries documents from the Prismic repository with specific\n * IDs.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param ids - A list of document IDs\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getByIDs}\n */\nexport const usePrismicDocumentsByIDs = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tids: ClientMethodParameters<\"getByIDs\">[0],\n\t\tparams?: ClientMethodParameters<\"getByIDs\">[1] & ComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<Query<TDocument>> =>\n\tuseStatefulPrismicClientMethod(\"getByIDs\", args);\n\n/**\n * A composable that queries all documents from the Prismic repository with\n * specific IDs.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param ids - A list of document IDs\n * @param params - Parameters to filter and sort results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getAllByIDs}\n */\nexport const useAllPrismicDocumentsByIDs = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tids: ClientMethodParameters<\"getAllByIDs\">[0],\n\t\tparams?: ClientMethodParameters<\"getAllByIDs\">[1] &\n\t\t\tComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument[]> =>\n\tuseStatefulPrismicClientMethod(\"getAllByIDs\", args);\n\n/**\n * A composable that queries a document from the Prismic repository with a\n * specific UID and Custom Type.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of the Prismic document returned\n *\n * @param documentType - The API ID of the document's Custom Type\n * @param uid - UID of the document\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getByUID}\n */\nexport const usePrismicDocumentByUID = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tdocumentType: ClientMethodParameters<\"getByUID\">[0],\n\t\tuid: ClientMethodParameters<\"getByUID\">[1],\n\t\tparams?: ClientMethodParameters<\"getByUID\">[2] & ComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument> =>\n\tuseStatefulPrismicClientMethod(\"getByUID\", args);\n\n/**\n * A composable that queries documents from the Prismic repository with specific\n * UIDs.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param documentType - The API ID of the document's Custom Type\n * @param uids - A list of document UIDs\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getByIDs}\n */\nexport const usePrismicDocumentsByUIDs = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tdocumentType: ClientMethodParameters<\"getByUIDs\">[0],\n\t\tuids: ClientMethodParameters<\"getByUIDs\">[1],\n\t\tparams?: ClientMethodParameters<\"getByUIDs\">[2] & ComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<Query<TDocument>> =>\n\tuseStatefulPrismicClientMethod(\"getByUIDs\", args);\n\n/**\n * A composable that queries all documents from the Prismic repository with\n * specific UIDs.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param documentType - The API ID of the document's Custom Type\n * @param uids - A list of document UIDs\n * @param params - Parameters to filter and sort results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getAllByIDs}\n */\nexport const useAllPrismicDocumentsByUIDs = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tdocumentType: ClientMethodParameters<\"getAllByUIDs\">[0],\n\t\tids: ClientMethodParameters<\"getAllByUIDs\">[1],\n\t\tparams?: ClientMethodParameters<\"getAllByUIDs\">[2] &\n\t\t\tComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument[]> =>\n\tuseStatefulPrismicClientMethod(\"getAllByUIDs\", args);\n\n/**\n * A composable that queries a singleton document from the Prismic repository\n * for a specific Custom Type.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of the Prismic document returned\n *\n * @param documentType - The API ID of the singleton Custom Type\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getSingle}\n */\nexport const useSinglePrismicDocument = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tdocumentType: ClientMethodParameters<\"getSingle\">[0],\n\t\tparams?: ClientMethodParameters<\"getSingle\">[1] & ComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument> =>\n\tuseStatefulPrismicClientMethod(\"getSingle\", args);\n\n/**\n * A composable that queries documents from the Prismic repository for a\n * specific Custom Type.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param documentType - The API ID of the Custom Type\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getByType}\n */\nexport const usePrismicDocumentsByType = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tdocumentType: ClientMethodParameters<\"getByType\">[0],\n\t\tparams?: ClientMethodParameters<\"getByType\">[1] & ComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<Query<TDocument>> =>\n\tuseStatefulPrismicClientMethod(\"getByType\", args);\n\n/**\n * A composable that queries all documents from the Prismic repository for a\n * specific Custom Type.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param documentType - The API ID of the Custom Type\n * @param params - Parameters to filter and sort results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getAllByType}\n */\nexport const useAllPrismicDocumentsByType = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\tdocumentType: ClientMethodParameters<\"getAllByType\">[0],\n\t\tparams?: ClientMethodParameters<\"getAllByType\">[1] &\n\t\t\tComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument[]> =>\n\tuseStatefulPrismicClientMethod(\"getAllByType\", args);\n\n/**\n * A composable that queries documents from the Prismic repository with a\n * specific tag.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param tag - The tag that must be included on a document\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getByTag}\n */\nexport const usePrismicDocumentsByTag = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\ttag: ClientMethodParameters<\"getByTag\">[0],\n\t\tparams?: ClientMethodParameters<\"getByTag\">[1] & ComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<Query<TDocument>> =>\n\tuseStatefulPrismicClientMethod(\"getByTag\", args);\n\n/**\n * A composable that queries all documents from the Prismic repository with a\n * specific tag.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param tag - The tag that must be included on a document\n * @param params - Parameters to filter and sort results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getAllByTag}\n */\nexport const useAllPrismicDocumentsByTag = <TDocument extends PrismicDocument>(\n\t...args: [\n\t\ttag: ClientMethodParameters<\"getAllByTag\">[0],\n\t\tparams?: ClientMethodParameters<\"getAllByTag\">[1] &\n\t\t\tComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument[]> =>\n\tuseStatefulPrismicClientMethod(\"getAllByTag\", args);\n\n/**\n * A composable that queries documents from the Prismic repository with specific\n * tags. A document must be tagged with all of the queried tags to be included.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param tags - A list of tags that must be included on a document\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getByTags}\n */\nexport const usePrismicDocumentsByEveryTag = <\n\tTDocument extends PrismicDocument,\n>(\n\t...args: [\n\t\ttags: ClientMethodParameters<\"getByEveryTag\">[0],\n\t\tparams?: ClientMethodParameters<\"getByEveryTag\">[1] &\n\t\t\tComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<Query<TDocument>> =>\n\tuseStatefulPrismicClientMethod(\"getByEveryTag\", args);\n\n/**\n * A composable that queries all documents from the Prismic repository with\n * specific tags. A document must be tagged with all of the queried tags to be\n * included.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param tags - A list of tags that must be included on a document\n * @param params - Parameters to filter and sort results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getAllByTags}\n */\nexport const useAllPrismicDocumentsByEveryTag = <\n\tTDocument extends PrismicDocument,\n>(\n\t...args: [\n\t\ttags: ClientMethodParameters<\"getAllByEveryTag\">[0],\n\t\tparams?: ClientMethodParameters<\"getAllByEveryTag\">[1] &\n\t\t\tComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument[]> =>\n\tuseStatefulPrismicClientMethod(\"getAllByEveryTag\", args);\n\n/**\n * A composable that queries documents from the Prismic repository with specific\n * tags. A document must be tagged with at least one of the queried tags to be\n * included.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param tags - A list of tags that must be included on a document\n * @param params - Parameters to filter, sort, and paginate results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getByTags}\n */\nexport const usePrismicDocumentsBySomeTags = <\n\tTDocument extends PrismicDocument,\n>(\n\t...args: [\n\t\ttags: ClientMethodParameters<\"getBySomeTags\">[0],\n\t\tparams?: ClientMethodParameters<\"getBySomeTags\">[1] &\n\t\t\tComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<Query<TDocument>> =>\n\tuseStatefulPrismicClientMethod(\"getBySomeTags\", args);\n\n/**\n * A composable that queries all documents from the Prismic repository with\n * specific tags. A document must be tagged with at least one of the queried\n * tags to be included.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param tags - A list of tags that must be included on a document\n * @param params - Parameters to filter and sort results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getAllByTags}\n */\nexport const useAllPrismicDocumentsBySomeTags = <\n\tTDocument extends PrismicDocument,\n>(\n\t...args: [\n\t\ttags: ClientMethodParameters<\"getAllBySomeTags\">[0],\n\t\tparams?: ClientMethodParameters<\"getAllBySomeTags\">[1] &\n\t\t\tComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument[]> =>\n\tuseStatefulPrismicClientMethod(\"getAllBySomeTags\", args);\n\n/**\n * **IMPORTANT**: Avoid using `dangerouslyUseAllPrismicDocuments` as it may be\n * slower and require more resources than other composables. Prefer using other\n * composables that filter by predicates such as\n * `useAllPrismicDocumentsByType`.\n *\n * A composable that queries content from the Prismic repository and returns all\n * matching content. If no predicates are provided, all documents will be\n * fetched.\n *\n * @remarks\n * An additional `@prismicio/client` instance can be provided at\n * `params.client`.\n * @typeParam TDocument - Type of Prismic documents returned\n *\n * @param params - Parameters to filter and sort results\n *\n * @returns The composable payload {@link ClientComposableReturnType}\n *\n * @see Underlying `@prismicio/client` method {@link Client.getAll}\n */\nexport const dangerouslyUseAllPrismicDocuments = <\n\tTDocument extends PrismicDocument,\n>(\n\t...args: [\n\t\tparams?: ClientMethodParameters<\"dangerouslyGetAll\">[0] &\n\t\t\tComposableOnlyParameters,\n\t]\n): ClientComposableReturnType<TDocument[]> =>\n\tuseStatefulPrismicClientMethod(\"dangerouslyGetAll\", args);\n"],
  "mappings": "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",
  "names": ["escapeHtml", "asText", "baseAsText", "escapeHtml", "group", "isImageThumbnailFilled", "predicate", "ref", "cookie", "previewCookieName", "defaultWrapper", "target", "rel", "asText", "link", "options", "PrismicClientComposableState"]
}
