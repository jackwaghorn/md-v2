import {
  routerKey
} from "./chunk-MTS6OJJN.js";
import {
  computed,
  defineComponent,
  h,
  inject,
  isRef,
  markRaw,
  nextTick,
  onBeforeUnmount,
  reactive,
  ref,
  resolveDynamicComponent,
  shallowRef,
  unref,
  watch,
  watchEffect
} from "./chunk-QO6ZHO7P.js";
import {
  __commonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/escape-html/index.js
var require_escape_html = __commonJS({
  "node_modules/escape-html/index.js"(exports, module) {
    "use strict";
    var matchHtmlRegExp = /["'&<>]/;
    module.exports = escapeHtml2;
    function escapeHtml2(string) {
      var str = "" + string;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape;
      var html = "";
      var index = 0;
      var lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escape = "&quot;";
            break;
          case 38:
            escape = "&amp;";
            break;
          case 39:
            escape = "&#39;";
            break;
          case 60:
            escape = "&lt;";
            break;
          case 62:
            escape = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
  }
});

// node_modules/@prismicio/types/dist/index.js
var RichTextNodeType = {
  heading1: "heading1",
  heading2: "heading2",
  heading3: "heading3",
  heading4: "heading4",
  heading5: "heading5",
  heading6: "heading6",
  paragraph: "paragraph",
  preformatted: "preformatted",
  strong: "strong",
  em: "em",
  listItem: "list-item",
  oListItem: "o-list-item",
  list: "group-list-item",
  oList: "group-o-list-item",
  image: "image",
  embed: "embed",
  hyperlink: "hyperlink",
  label: "label",
  span: "span"
};
var LinkType = {
  Any: "Any",
  Document: "Document",
  Media: "Media",
  Web: "Web"
};

// node_modules/@prismicio/richtext/dist/index.js
var uuid = () => {
  return (++uuid.i).toString();
};
uuid.i = 0;
var asTree = (nodes) => {
  const preparedNodes = prepareNodes(nodes);
  const children = [];
  for (let i = 0; i < preparedNodes.length; i++) {
    children.push(nodeToTreeNode(preparedNodes[i]));
  }
  return {
    key: uuid(),
    children
  };
};
var createTreeNode = (node, children = []) => {
  return {
    key: uuid(),
    type: node.type,
    text: "text" in node ? node.text : void 0,
    node,
    children
  };
};
var createTextTreeNode = (text) => {
  return createTreeNode({
    type: RichTextNodeType.span,
    text,
    spans: []
  });
};
var prepareNodes = (nodes) => {
  const mutNodes = nodes.slice(0);
  for (let i = 0; i < mutNodes.length; i++) {
    const node = mutNodes[i];
    if (node.type === RichTextNodeType.listItem || node.type === RichTextNodeType.oListItem) {
      const items = [
        node
      ];
      while (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {
        items.push(mutNodes[i + 1]);
        mutNodes.splice(i, 1);
      }
      if (node.type === RichTextNodeType.listItem) {
        mutNodes[i] = {
          type: RichTextNodeType.list,
          items
        };
      } else {
        mutNodes[i] = {
          type: RichTextNodeType.oList,
          items
        };
      }
    }
  }
  return mutNodes;
};
var nodeToTreeNode = (node) => {
  if ("text" in node) {
    return createTreeNode(
      node,
      textNodeSpansToTreeNodeChildren(node.spans, node)
    );
  }
  if ("items" in node) {
    const children = [];
    for (let i = 0; i < node.items.length; i++) {
      children.push(nodeToTreeNode(node.items[i]));
    }
    return createTreeNode(node, children);
  }
  return createTreeNode(node);
};
var textNodeSpansToTreeNodeChildren = (spans, node, parentSpan) => {
  if (!spans.length) {
    return [createTextTreeNode(node.text)];
  }
  const mutSpans = spans.slice(0);
  mutSpans.sort((a, b) => a.start - b.start || b.end - a.end);
  const children = [];
  for (let i = 0; i < mutSpans.length; i++) {
    const span = mutSpans[i];
    const parentSpanStart = parentSpan && parentSpan.start || 0;
    const spanStart = span.start - parentSpanStart;
    const spanEnd = span.end - parentSpanStart;
    const text = node.text.slice(spanStart, spanEnd);
    const childSpans = [];
    for (let j = i; j < mutSpans.length; j++) {
      const siblingSpan = mutSpans[j];
      if (siblingSpan !== span && siblingSpan.start >= span.start && siblingSpan.end <= span.end) {
        childSpans.push(siblingSpan);
        mutSpans.splice(j, 1);
        j--;
      }
    }
    if (i === 0 && spanStart > 0) {
      children.push(createTextTreeNode(node.text.slice(0, spanStart)));
    }
    const spanWithText = { ...span, text };
    children.push(
      createTreeNode(
        spanWithText,
        textNodeSpansToTreeNodeChildren(
          childSpans,
          {
            ...node,
            text
          },
          span
        )
      )
    );
    if (spanEnd < node.text.length) {
      children.push(
        createTextTreeNode(
          node.text.slice(
            spanEnd,
            mutSpans[i + 1] ? mutSpans[i + 1].start - parentSpanStart : void 0
          )
        )
      );
    }
  }
  return children;
};
var asText = (richTextField, separator = " ") => {
  let result = "";
  for (let i = 0; i < richTextField.length; i++) {
    if ("text" in richTextField[i]) {
      result += (result ? separator : "") + richTextField[i].text;
    }
  }
  return result;
};
var serialize = (richTextField, serializer) => {
  return serializeTreeNodes(
    asTree(richTextField).children,
    serializer
  );
};
var serializeTreeNodes = (nodes, serializer) => {
  const serializedTreeNodes = [];
  for (let i = 0; i < nodes.length; i++) {
    const treeNode = nodes[i];
    const serializedTreeNode = serializer(
      treeNode.type,
      treeNode.node,
      treeNode.text,
      serializeTreeNodes(treeNode.children, serializer),
      treeNode.key
    );
    if (serializedTreeNode != null) {
      serializedTreeNodes.push(serializedTreeNode);
    }
  }
  return serializedTreeNodes;
};
var RichTextReversedNodeType = {
  [RichTextNodeType.listItem]: "listItem",
  [RichTextNodeType.oListItem]: "oListItem",
  [RichTextNodeType.list]: "list",
  [RichTextNodeType.oList]: "oList"
};
var wrapMapSerializer = (mapSerializer) => {
  return (type, node, text, children, key) => {
    const tagSerializer = mapSerializer[RichTextReversedNodeType[type] || type];
    if (tagSerializer) {
      return tagSerializer({
        type,
        node,
        text,
        children,
        key
      });
    }
  };
};
var composeSerializers = (...serializers) => {
  return (...args) => {
    for (let i = 0; i < serializers.length; i++) {
      const serializer = serializers[i];
      if (serializer) {
        const res = serializer(...args);
        if (res != null) {
          return res;
        }
      }
    }
  };
};

// node_modules/@prismicio/helpers/dist/index.js
var import_escape_html = __toESM(require_escape_html());

// node_modules/imgix-url-builder/dist/index.mjs
var camelCaseToParamCase = (input) => {
  return input.replace(/[A-Z]/g, (match) => {
    return `-${match.toLowerCase()}`;
  });
};
var buildURL = (url, params) => {
  const instance = new URL(url);
  for (const camelCasedParamKey in params) {
    const paramKey = camelCaseToParamCase(camelCasedParamKey);
    const paramValue = params[camelCasedParamKey];
    if (paramValue === void 0) {
      instance.searchParams.delete(paramKey);
    } else if (Array.isArray(paramValue)) {
      instance.searchParams.set(paramKey, paramValue.join(","));
    } else {
      instance.searchParams.set(paramKey, `${paramValue}`);
    }
  }
  const s = instance.searchParams.get("s");
  if (s) {
    instance.searchParams.delete("s");
    instance.searchParams.append("s", s);
  }
  return instance.toString();
};
var buildPixelDensitySrcSet = (url, { pixelDensities, ...params }) => {
  return pixelDensities.map((dpr) => {
    return `${buildURL(url, { ...params, dpr })} ${dpr}x`;
  }).join(", ");
};
var buildWidthSrcSet = (url, { widths, ...params }) => {
  return widths.map((width) => {
    return `${buildURL(url, { ...params, w: void 0, width })} ${width}w`;
  }).join(", ");
};

// node_modules/@prismicio/helpers/dist/index.js
var asDate = (dateOrTimestampField) => {
  if (!dateOrTimestampField) {
    return null;
  }
  if (dateOrTimestampField.length === 24) {
    return new Date(
      dateOrTimestampField.replace(/(\+|-)(\d{2})(\d{2})$/, ".000$1$2:$3")
    );
  } else {
    return new Date(dateOrTimestampField);
  }
};
var documentToLinkField = (prismicDocument) => {
  var _a, _b, _c;
  return {
    link_type: LinkType.Document,
    id: prismicDocument.id,
    uid: (_a = prismicDocument.uid) != null ? _a : void 0,
    type: prismicDocument.type,
    tags: prismicDocument.tags,
    lang: prismicDocument.lang,
    url: (_b = prismicDocument.url) != null ? _b : void 0,
    slug: (_c = prismicDocument.slugs) == null ? void 0 : _c[0],
    ...prismicDocument.data && Object.keys(prismicDocument.data).length > 0 ? { data: prismicDocument.data } : {}
  };
};
var asLink = (linkFieldOrDocument, linkResolver) => {
  if (!linkFieldOrDocument) {
    return null;
  }
  const linkField = "link_type" in linkFieldOrDocument ? linkFieldOrDocument : documentToLinkField(linkFieldOrDocument);
  switch (linkField.link_type) {
    case LinkType.Media:
    case LinkType.Web:
      return "url" in linkField ? linkField.url : null;
    case LinkType.Document: {
      if ("id" in linkField && linkResolver) {
        const resolvedURL = linkResolver(linkField);
        if (resolvedURL != null) {
          return resolvedURL;
        }
      }
      if ("url" in linkField && linkField.url) {
        return linkField.url;
      }
      return null;
    }
    case LinkType.Any:
    default:
      return null;
  }
};
var asText2 = (richTextField, separator) => {
  if (richTextField) {
    return asText(richTextField, separator);
  } else {
    return null;
  }
};
var getLabel = (node) => {
  return "data" in node && "label" in node.data ? ` class="${node.data.label}"` : "";
};
var serializeStandardTag = (tag, node, children) => {
  return `<${tag}${getLabel(node)}>${children.join("")}</${tag}>`;
};
var serializePreFormatted = (node) => {
  return `<pre${getLabel(node)}>${(0, import_escape_html.default)(node.text)}</pre>`;
};
var serializeImage = (linkResolver, node) => {
  let imageTag = `<img src="${node.url}" alt="${(0, import_escape_html.default)(node.alt)}"${node.copyright ? ` copyright="${(0, import_escape_html.default)(node.copyright)}"` : ""} />`;
  if (node.linkTo) {
    imageTag = serializeHyperlink(
      linkResolver,
      {
        type: RichTextNodeType.hyperlink,
        data: node.linkTo,
        start: 0,
        end: 0
      },
      [imageTag]
    );
  }
  return `<p class="block-img">${imageTag}</p>`;
};
var serializeEmbed = (node) => {
  return `<div data-oembed="${node.oembed.embed_url}" data-oembed-type="${node.oembed.type}" data-oembed-provider="${node.oembed.provider_name}"${getLabel(node)}>${node.oembed.html}</div>`;
};
var serializeHyperlink = (linkResolver, node, children) => {
  switch (node.data.link_type) {
    case LinkType.Web: {
      return `<a href="${(0, import_escape_html.default)(node.data.url)}" ${node.data.target ? `target="${node.data.target}" ` : ""}rel="noopener noreferrer"${getLabel(node)}>${children.join("")}</a>`;
    }
    case LinkType.Document: {
      return `<a href="${asLink(node.data, linkResolver)}"${getLabel(
        node
      )}>${children.join("")}</a>`;
    }
    case LinkType.Media: {
      return `<a href="${node.data.url}"${getLabel(node)}>${children.join(
        ""
      )}</a>`;
    }
  }
};
var serializeSpan = (content) => {
  return content ? (0, import_escape_html.default)(content).replace(/\n/g, "<br />") : "";
};
var createDefaultHTMLSerializer = (linkResolver) => {
  return (_type, node, text, children, _key) => {
    switch (node.type) {
      case RichTextNodeType.heading1:
        return serializeStandardTag("h1", node, children);
      case RichTextNodeType.heading2:
        return serializeStandardTag("h2", node, children);
      case RichTextNodeType.heading3:
        return serializeStandardTag("h3", node, children);
      case RichTextNodeType.heading4:
        return serializeStandardTag("h4", node, children);
      case RichTextNodeType.heading5:
        return serializeStandardTag("h5", node, children);
      case RichTextNodeType.heading6:
        return serializeStandardTag("h6", node, children);
      case RichTextNodeType.paragraph:
        return serializeStandardTag("p", node, children);
      case RichTextNodeType.preformatted:
        return serializePreFormatted(node);
      case RichTextNodeType.strong:
        return serializeStandardTag("strong", node, children);
      case RichTextNodeType.em:
        return serializeStandardTag("em", node, children);
      case RichTextNodeType.listItem:
        return serializeStandardTag("li", node, children);
      case RichTextNodeType.oListItem:
        return serializeStandardTag("li", node, children);
      case RichTextNodeType.list:
        return serializeStandardTag("ul", node, children);
      case RichTextNodeType.oList:
        return serializeStandardTag("ol", node, children);
      case RichTextNodeType.image:
        return serializeImage(linkResolver, node);
      case RichTextNodeType.embed:
        return serializeEmbed(node);
      case RichTextNodeType.hyperlink:
        return serializeHyperlink(linkResolver, node, children);
      case RichTextNodeType.label:
        return serializeStandardTag("span", node, children);
      case RichTextNodeType.span:
      default:
        return serializeSpan(text);
    }
  };
};
var wrapMapSerializerWithStringChildren = (mapSerializer) => {
  const modifiedMapSerializer = {};
  for (const tag in mapSerializer) {
    const tagSerializer = mapSerializer[tag];
    if (tagSerializer) {
      modifiedMapSerializer[tag] = (payload) => {
        return tagSerializer({
          ...payload,
          children: payload.children.join("")
        });
      };
    }
  }
  return wrapMapSerializer(modifiedMapSerializer);
};
var asHTML = (richTextField, linkResolver, htmlSerializer) => {
  if (richTextField) {
    let serializer;
    if (htmlSerializer) {
      serializer = composeSerializers(
        typeof htmlSerializer === "object" ? wrapMapSerializerWithStringChildren(htmlSerializer) : (type, node, text, children, key) => htmlSerializer(type, node, text, children.join(""), key),
        createDefaultHTMLSerializer(linkResolver)
      );
    } else {
      serializer = createDefaultHTMLSerializer(linkResolver);
    }
    return serialize(richTextField, serializer).join(
      ""
    );
  } else {
    return null;
  }
};
var isNonNullish = (input) => {
  return input != null;
};
var isNonEmptyArray = (input) => {
  return !!input.length;
};
var richText = (field) => {
  if (!isNonNullish(field)) {
    return false;
  } else if (field.length === 1 && "text" in field[0]) {
    return !!field[0].text;
  } else {
    return !!field.length;
  }
};
var title = richText;
var imageThumbnail = (thumbnail) => {
  return isNonNullish(thumbnail) && !!thumbnail.url;
};
var image = imageThumbnail;
var link = (field) => {
  return isNonNullish(field) && ("id" in field || "url" in field);
};
var linkToMedia = link;
var contentRelationship = link;
var date = isNonNullish;
var timestamp = isNonNullish;
var color = isNonNullish;
var number = isNonNullish;
var keyText = (field) => {
  return isNonNullish(keyText) && !!field;
};
var select = isNonNullish;
var embed = (field) => {
  return isNonNullish(field) && !!field.embed_url;
};
var geoPoint = (field) => {
  return isNonNullish(field) && "longitude" in field;
};
var integrationFields = isNonNullish;
var group = (group2) => {
  return isNonNullish(group2) && isNonEmptyArray(group2);
};
var sliceZone = (slices) => {
  return isNonNullish(slices) && isNonEmptyArray(slices);
};
var isFilled = Object.freeze({
  __proto__: null,
  richText,
  title,
  imageThumbnail,
  image,
  link,
  linkToMedia,
  contentRelationship,
  date,
  timestamp,
  color,
  number,
  keyText,
  select,
  embed,
  geoPoint,
  integrationFields,
  group,
  sliceZone
});
var asImageSrc = (field, params = {}) => {
  if (field && imageThumbnail(field)) {
    return buildURL(field.url, params);
  } else {
    return null;
  }
};
var DEFAULT_WIDTHS = [640, 828, 1200, 2048, 3840];
var asImageWidthSrcSet = (field, params = {}) => {
  if (field && imageThumbnail(field)) {
    let {
      widths = DEFAULT_WIDTHS,
      ...imgixParams
    } = params;
    const {
      url,
      dimensions,
      alt: _alt,
      copyright: _copyright,
      ...responsiveViews
    } = field;
    const responsiveViewObjects = Object.values(responsiveViews);
    if (widths === "thumbnails" && responsiveViewObjects.length < 1) {
      widths = DEFAULT_WIDTHS;
    }
    return {
      src: buildURL(url, imgixParams),
      srcset: widths === "thumbnails" ? [
        buildWidthSrcSet(url, {
          ...imgixParams,
          widths: [dimensions.width]
        }),
        ...responsiveViewObjects.map((thumbnail) => {
          return buildWidthSrcSet(thumbnail.url, {
            ...imgixParams,
            widths: [thumbnail.dimensions.width]
          });
        })
      ].join(", ") : buildWidthSrcSet(field.url, {
        ...imgixParams,
        widths
      })
    };
  } else {
    return null;
  }
};
var DEFAULT_PIXEL_DENSITIES = [1, 2, 3];
var asImagePixelDensitySrcSet = (field, params = {}) => {
  if (field && imageThumbnail(field)) {
    const { pixelDensities = DEFAULT_PIXEL_DENSITIES, ...imgixParams } = params;
    return {
      src: buildURL(field.url, imgixParams),
      srcset: buildPixelDensitySrcSet(field.url, {
        ...imgixParams,
        pixelDensities
      })
    };
  } else {
    return null;
  }
};

// node_modules/@prismicio/client/dist/index.js
var isRepositoryName = (input) => {
  return /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(input);
};
var PrismicError = class extends Error {
  constructor(message = "An invalid API response was returned", url, response) {
    super(message);
    this.url = url;
    this.response = response;
  }
};
var getRepositoryEndpoint = (repositoryName) => {
  if (isRepositoryName(repositoryName)) {
    return `https://${repositoryName}.cdn.prismic.io/api/v2`;
  } else {
    throw new PrismicError(
      `An invalid Prismic repository name was given: ${repositoryName}`,
      void 0,
      void 0
    );
  }
};
var isRepositoryEndpoint = (input) => {
  try {
    new URL(input);
    return true;
  } catch (e) {
    return false;
  }
};
var castArray = (a) => Array.isArray(a) ? a : [a];
var RENAMED_PARAMS = {
  accessToken: "access_token"
};
var castOrderingToString = (ordering) => typeof ordering === "string" ? ordering : [
  ordering.field,
  ordering.direction === "desc" ? ordering.direction : void 0
].filter(Boolean).join(" ");
var buildQueryURL = (endpoint, args) => {
  var _a;
  const { predicates, ...params } = args;
  const url = new URL(`documents/search`, `${endpoint}/`);
  if (predicates) {
    for (const predicate2 of castArray(predicates)) {
      url.searchParams.append("q", `[${predicate2}]`);
    }
  }
  for (const k in params) {
    const name = (_a = RENAMED_PARAMS[k]) != null ? _a : k;
    let value = params[k];
    if (name === "orderings") {
      const scopedValue = params[name];
      if (scopedValue != null) {
        const v = castArray(scopedValue).map((ordering) => castOrderingToString(ordering)).join(",");
        value = `[${v}]`;
      }
    } else if (name === "routes") {
      if (typeof params[name] === "object") {
        value = JSON.stringify(castArray(params[name]));
      }
    }
    if (value != null) {
      url.searchParams.set(name, castArray(value).join(","));
    }
  }
  return url.toString();
};
var appendPredicates = (objWithPredicates = {}, predicates) => {
  return {
    ...objWithPredicates,
    predicates: [
      ...objWithPredicates.predicates || [],
      ...castArray(predicates)
    ]
  };
};
var castThunk = (a) => typeof a === "function" ? a : () => a;
var findRef = (refs, predicate2) => {
  const ref2 = refs.find((ref22) => predicate2(ref22));
  if (!ref2) {
    throw new PrismicError("Ref could not be found.", void 0, void 0);
  }
  return ref2;
};
var findMasterRef = (refs) => {
  return findRef(refs, (ref2) => ref2.isMasterRef);
};
var findRefByID = (refs, id) => {
  return findRef(refs, (ref2) => ref2.id === id);
};
var findRefByLabel = (refs, label) => {
  return findRef(refs, (ref2) => ref2.label === label);
};
var preview = "io.prismic.preview";
var cookie = Object.freeze({
  __proto__: null,
  preview
});
var readValue = (value) => {
  return value.replace(/%3B/g, ";");
};
var getPreviewCookie = (cookieJar) => {
  const cookies = cookieJar.split("; ");
  let value;
  for (const cookie2 of cookies) {
    const parts = cookie2.split("=");
    const name = readValue(parts[0]).replace(/%3D/g, "=");
    if (name === preview) {
      value = readValue(parts.slice(1).join("="));
      continue;
    }
  }
  return value;
};
var minifyGraphQLQuery = (query) => {
  return query.replace(
    /(\n| )*( |{|})(\n| )*/gm,
    (_chars, _spaces, brackets) => brackets
  );
};
var ForbiddenError = class extends PrismicError {
};
var NotFoundError = class extends PrismicError {
};
var ParsingError = class extends PrismicError {
};
var formatValue = (value) => {
  if (Array.isArray(value)) {
    return `[${value.map(formatValue).join(", ")}]`;
  }
  if (typeof value === "string") {
    return `"${value}"`;
  }
  if (value instanceof Date) {
    return `${value.getTime()}`;
  }
  return `${value}`;
};
var pathWithArgsPredicate = (name) => {
  const fn = (path, ...args) => {
    const formattedArgs = args.map(formatValue).join(", ");
    const joiner = path && args.length ? ", " : "";
    return `[${name}(${path}${joiner}${formattedArgs})]`;
  };
  return fn;
};
var pathPredicate = (name) => {
  const predicateFn = pathWithArgsPredicate(name);
  const fn = (path) => {
    return predicateFn(path);
  };
  return fn;
};
var argsPredicate = (name) => {
  const predicateFn = pathWithArgsPredicate(name);
  const fn = (...args) => {
    return predicateFn("", ...args);
  };
  return fn;
};
var predicate = {
  at: pathWithArgsPredicate("at"),
  not: pathWithArgsPredicate("not"),
  any: pathWithArgsPredicate(
    "any"
  ),
  in: pathWithArgsPredicate("in"),
  fulltext: pathWithArgsPredicate("fulltext"),
  has: pathPredicate("has"),
  missing: pathPredicate("missing"),
  similar: argsPredicate("similar"),
  geopointNear: pathWithArgsPredicate("geopoint.near"),
  numberLessThan: pathWithArgsPredicate("number.lt"),
  numberGreaterThan: pathWithArgsPredicate("number.gt"),
  numberInRange: pathWithArgsPredicate(
    "number.inRange"
  ),
  dateAfter: pathWithArgsPredicate("date.after"),
  dateBefore: pathWithArgsPredicate("date.before"),
  dateBetween: pathWithArgsPredicate("date.between"),
  dateDayOfMonth: pathWithArgsPredicate("date.day-of-month"),
  dateDayOfMonthAfter: pathWithArgsPredicate(
    "date.day-of-month-after"
  ),
  dateDayOfMonthBefore: pathWithArgsPredicate(
    "date.day-of-month-before"
  ),
  dateDayOfWeek: pathWithArgsPredicate("date.day-of-week"),
  dateDayOfWeekAfter: pathWithArgsPredicate(
    "date.day-of-week-after"
  ),
  dateDayOfWeekBefore: pathWithArgsPredicate(
    "date.day-of-week-before"
  ),
  dateMonth: pathWithArgsPredicate("date.month"),
  dateMonthAfter: pathWithArgsPredicate("date.month-after"),
  dateMonthBefore: pathWithArgsPredicate("date.month-before"),
  dateYear: pathWithArgsPredicate("date.year"),
  dateHour: pathWithArgsPredicate("date.hour"),
  dateHourAfter: pathWithArgsPredicate("date.hour-after"),
  dateHourBefore: pathWithArgsPredicate("date.hour-before")
};
var MAX_PAGE_SIZE = 100;
var REPOSITORY_CACHE_TTL = 5e3;
var GET_ALL_QUERY_DELAY = 500;
var typePredicate = (documentType) => predicate.at("document.type", documentType);
var everyTagPredicate = (tags) => predicate.at("document.tags", castArray(tags));
var someTagsPredicate = (tags) => predicate.any("document.tags", castArray(tags));
var createClient = (repositoryNameOrEndpoint, options) => new Client(repositoryNameOrEndpoint, options);
var Client = class {
  constructor(repositoryNameOrEndpoint, options = {}) {
    this.refState = {
      mode: "Master",
      autoPreviewsEnabled: true
    };
    this.cachedRepositoryExpiration = 0;
    this.graphqlFetch = this.graphQLFetch.bind(this);
    if (isRepositoryEndpoint(repositoryNameOrEndpoint)) {
      if (/\.prismic\.io\/(?!api\/v2\/?)/.test(repositoryNameOrEndpoint)) {
        throw new PrismicError(
          "@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.",
          void 0,
          void 0
        );
      }
      this.endpoint = repositoryNameOrEndpoint;
    } else {
      this.endpoint = getRepositoryEndpoint(repositoryNameOrEndpoint);
    }
    this.accessToken = options.accessToken;
    this.routes = options.routes;
    this.brokenRoute = options.brokenRoute;
    this.defaultParams = options.defaultParams;
    if (options.ref) {
      this.queryContentFromRef(options.ref);
    }
    if (typeof options.fetch === "function") {
      this.fetchFn = options.fetch;
    } else if (typeof globalThis.fetch === "function") {
      this.fetchFn = globalThis.fetch;
    } else {
      throw new PrismicError(
        "A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.",
        void 0,
        void 0
      );
    }
    if (this.fetchFn === globalThis.fetch) {
      this.fetchFn = this.fetchFn.bind(globalThis);
    }
    this.graphQLFetch = this.graphQLFetch.bind(this);
  }
  enableAutoPreviews() {
    this.refState.autoPreviewsEnabled = true;
  }
  enableAutoPreviewsFromReq(req) {
    this.refState.httpRequest = req;
    this.refState.autoPreviewsEnabled = true;
  }
  disableAutoPreviews() {
    this.refState.autoPreviewsEnabled = false;
  }
  async query(predicates, params) {
    const url = await this.buildQueryURL({ ...params, predicates });
    return await this.fetch(url, params);
  }
  async get(params) {
    const url = await this.buildQueryURL(params);
    return await this.fetch(url, params);
  }
  async getFirst(params) {
    var _a, _b;
    const actualParams = { ...params };
    if (!(params && params.page) && !(params == null ? void 0 : params.pageSize)) {
      actualParams.pageSize = (_b = (_a = this.defaultParams) == null ? void 0 : _a.pageSize) != null ? _b : 1;
    }
    const url = await this.buildQueryURL(actualParams);
    const result = await this.fetch(url, params);
    const firstResult = result.results[0];
    if (firstResult) {
      return firstResult;
    }
    throw new PrismicError("No documents were returned", url, void 0);
  }
  async dangerouslyGetAll(params = {}) {
    var _a;
    const { limit = Infinity, ...actualParams } = params;
    const resolvedParams = {
      ...actualParams,
      pageSize: Math.min(
        limit,
        actualParams.pageSize || ((_a = this.defaultParams) == null ? void 0 : _a.pageSize) || MAX_PAGE_SIZE
      )
    };
    const documents = [];
    let latestResult;
    while ((!latestResult || latestResult.next_page) && documents.length < limit) {
      const page = latestResult ? latestResult.page + 1 : void 0;
      latestResult = await this.get({ ...resolvedParams, page });
      documents.push(...latestResult.results);
      if (latestResult.next_page) {
        await new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));
      }
    }
    return documents.slice(0, limit);
  }
  async getByID(id, params) {
    return await this.getFirst(
      appendPredicates(params, predicate.at("document.id", id))
    );
  }
  async getByIDs(ids, params) {
    return await this.get(
      appendPredicates(params, predicate.in("document.id", ids))
    );
  }
  async getAllByIDs(ids, params) {
    return await this.dangerouslyGetAll(
      appendPredicates(params, predicate.in("document.id", ids))
    );
  }
  async getByUID(documentType, uid, params) {
    return await this.getFirst(
      appendPredicates(params, [
        typePredicate(documentType),
        predicate.at(`my.${documentType}.uid`, uid)
      ])
    );
  }
  async getByUIDs(documentType, uids, params) {
    return await this.get(
      appendPredicates(params, [
        typePredicate(documentType),
        predicate.in(`my.${documentType}.uid`, uids)
      ])
    );
  }
  async getAllByUIDs(documentType, uids, params) {
    return await this.dangerouslyGetAll(
      appendPredicates(params, [
        typePredicate(documentType),
        predicate.in(`my.${documentType}.uid`, uids)
      ])
    );
  }
  async getSingle(documentType, params) {
    return await this.getFirst(
      appendPredicates(params, typePredicate(documentType))
    );
  }
  async getByType(documentType, params) {
    return await this.get(
      appendPredicates(params, typePredicate(documentType))
    );
  }
  async getAllByType(documentType, params) {
    return await this.dangerouslyGetAll(appendPredicates(params, typePredicate(documentType)));
  }
  async getByTag(tag, params) {
    return await this.get(
      appendPredicates(params, someTagsPredicate(tag))
    );
  }
  async getAllByTag(tag, params) {
    return await this.dangerouslyGetAll(
      appendPredicates(params, someTagsPredicate(tag))
    );
  }
  async getByEveryTag(tags, params) {
    return await this.get(
      appendPredicates(params, everyTagPredicate(tags))
    );
  }
  async getAllByEveryTag(tags, params) {
    return await this.dangerouslyGetAll(
      appendPredicates(params, everyTagPredicate(tags))
    );
  }
  async getBySomeTags(tags, params) {
    return await this.get(
      appendPredicates(params, someTagsPredicate(tags))
    );
  }
  async getAllBySomeTags(tags, params) {
    return await this.dangerouslyGetAll(
      appendPredicates(params, someTagsPredicate(tags))
    );
  }
  async getRepository(params) {
    const url = new URL(this.endpoint);
    if (this.accessToken) {
      url.searchParams.set("access_token", this.accessToken);
    }
    return await this.fetch(url.toString(), params);
  }
  async getRefs(params) {
    const repository = await this.getRepository(params);
    return repository.refs;
  }
  async getRefByID(id, params) {
    const refs = await this.getRefs(params);
    return findRefByID(refs, id);
  }
  async getRefByLabel(label, params) {
    const refs = await this.getRefs(params);
    return findRefByLabel(refs, label);
  }
  async getMasterRef(params) {
    const refs = await this.getRefs(params);
    return findMasterRef(refs);
  }
  async getReleases(params) {
    const refs = await this.getRefs(params);
    return refs.filter((ref2) => !ref2.isMasterRef);
  }
  async getReleaseByID(id, params) {
    const releases = await this.getReleases(params);
    return findRefByID(releases, id);
  }
  async getReleaseByLabel(label, params) {
    const releases = await this.getReleases(params);
    return findRefByLabel(releases, label);
  }
  async getTags(params) {
    try {
      const tagsForm = await this.getCachedRepositoryForm("tags", params);
      const url = new URL(tagsForm.action);
      if (this.accessToken) {
        url.searchParams.set("access_token", this.accessToken);
      }
      return await this.fetch(url.toString(), params);
    } catch (e) {
      const repository = await this.getRepository(params);
      return repository.tags;
    }
  }
  async buildQueryURL({
    signal,
    ...params
  } = {}) {
    const ref2 = params.ref || await this.getResolvedRefString();
    const integrationFieldsRef = params.integrationFieldsRef || (await this.getCachedRepository({ signal })).integrationFieldsRef || void 0;
    return buildQueryURL(this.endpoint, {
      ...this.defaultParams,
      ...params,
      ref: ref2,
      integrationFieldsRef,
      routes: params.routes || this.routes,
      brokenRoute: params.brokenRoute || this.brokenRoute,
      accessToken: params.accessToken || this.accessToken
    });
  }
  async resolvePreviewURL(args) {
    var _a, _b;
    let documentID = args.documentID;
    let previewToken = args.previewToken;
    if (typeof globalThis.location !== "undefined") {
      const searchParams = new URLSearchParams(globalThis.location.search);
      documentID = documentID || searchParams.get("documentId");
      previewToken = previewToken || searchParams.get("token");
    } else if (this.refState.httpRequest) {
      if ("query" in this.refState.httpRequest) {
        documentID = documentID || ((_a = this.refState.httpRequest.query) == null ? void 0 : _a.documentId);
        previewToken = previewToken || ((_b = this.refState.httpRequest.query) == null ? void 0 : _b.token);
      } else if ("url" in this.refState.httpRequest && this.refState.httpRequest.url) {
        const searchParams = new URL(this.refState.httpRequest.url).searchParams;
        documentID = documentID || searchParams.get("documentId");
        previewToken = previewToken || searchParams.get("token");
      }
    }
    if (documentID != null && previewToken != null) {
      const document = await this.getByID(documentID, {
        signal: args.signal,
        ref: previewToken,
        lang: "*"
      });
      const url = asLink(document, args.linkResolver);
      if (typeof url === "string") {
        return url;
      }
    }
    return args.defaultURL;
  }
  queryLatestContent() {
    this.refState.mode = "Master";
  }
  queryContentFromReleaseByID(releaseID) {
    this.refState = {
      ...this.refState,
      mode: "ReleaseID",
      releaseID
    };
  }
  queryContentFromReleaseByLabel(releaseLabel) {
    this.refState = {
      ...this.refState,
      mode: "ReleaseLabel",
      releaseLabel
    };
  }
  queryContentFromRef(ref2) {
    this.refState = {
      ...this.refState,
      mode: "Manual",
      ref: ref2
    };
  }
  async graphQLFetch(input, init) {
    const cachedRepository = await this.getCachedRepository();
    const ref2 = await this.getResolvedRefString();
    const unsanitizedHeaders = {
      "Prismic-ref": ref2,
      Authorization: this.accessToken ? `Token ${this.accessToken}` : "",
      ...init ? init.headers : {}
    };
    if (cachedRepository.integrationFieldsRef) {
      unsanitizedHeaders["Prismic-integration-field-ref"] = cachedRepository.integrationFieldsRef;
    }
    const headers = {};
    for (const key in unsanitizedHeaders) {
      if (unsanitizedHeaders[key]) {
        headers[key.toLowerCase()] = unsanitizedHeaders[key];
      }
    }
    const url = new URL(
      input
    );
    url.searchParams.set("ref", ref2);
    const query = url.searchParams.get("query");
    if (query) {
      url.searchParams.set(
        "query",
        minifyGraphQLQuery(query)
      );
    }
    return await this.fetchFn(url.toString(), {
      ...init,
      headers
    });
  }
  async getCachedRepository(params) {
    if (!this.cachedRepository || Date.now() >= this.cachedRepositoryExpiration) {
      this.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;
      this.cachedRepository = await this.getRepository(params);
    }
    return this.cachedRepository;
  }
  async getCachedRepositoryForm(name, params) {
    const cachedRepository = await this.getCachedRepository(params);
    const form = cachedRepository.forms[name];
    if (!form) {
      throw new PrismicError(
        `Form with name "${name}" could not be found`,
        void 0,
        void 0
      );
    }
    return form;
  }
  async getResolvedRefString(params) {
    var _a, _b;
    if (this.refState.autoPreviewsEnabled) {
      let previewRef;
      let cookieJar;
      if ((_a = this.refState.httpRequest) == null ? void 0 : _a.headers) {
        if ("get" in this.refState.httpRequest.headers && typeof this.refState.httpRequest.headers.get === "function") {
          cookieJar = this.refState.httpRequest.headers.get("cookie");
        } else if ("cookie" in this.refState.httpRequest.headers) {
          cookieJar = this.refState.httpRequest.headers.cookie;
        }
      } else if ((_b = globalThis.document) == null ? void 0 : _b.cookie) {
        cookieJar = globalThis.document.cookie;
      }
      if (cookieJar) {
        previewRef = getPreviewCookie(cookieJar);
      }
      if (previewRef) {
        return previewRef;
      }
    }
    const cachedRepository = await this.getCachedRepository(params);
    const refModeType = this.refState.mode;
    if (refModeType === "ReleaseID") {
      return findRefByID(cachedRepository.refs, this.refState.releaseID).ref;
    } else if (refModeType === "ReleaseLabel") {
      return findRefByLabel(cachedRepository.refs, this.refState.releaseLabel).ref;
    } else if (refModeType === "Manual") {
      const res = await castThunk(this.refState.ref)();
      if (typeof res === "string") {
        return res;
      }
    }
    return findMasterRef(cachedRepository.refs).ref;
  }
  async fetch(url, params = {}) {
    const res = await this.fetchFn(url, {
      signal: params.signal
    });
    let json;
    try {
      json = await res.json();
    } catch (e) {
      if (res.status === 404) {
        throw new NotFoundError(
          `Prismic repository not found. Check that "${this.endpoint}" is pointing to the correct repository.`,
          url,
          void 0
        );
      } else {
        throw new PrismicError(void 0, url, void 0);
      }
    }
    switch (res.status) {
      case 200: {
        return json;
      }
      case 400: {
        throw new ParsingError(json.message, url, json);
      }
      case 401:
      case 403: {
        throw new ForbiddenError(
          "error" in json ? json.error : json.message,
          url,
          json
        );
      }
    }
    throw new PrismicError(void 0, url, json);
  }
};

// node_modules/@prismicio/vue/dist/index.js
var simplyResolveComponent = (component) => {
  return resolveDynamicComponent(component);
};
var defaultWrapper$2 = "div";
var PrismicEmbedImpl = defineComponent({
  name: "PrismicEmbed",
  props: {
    field: {
      type: Object,
      required: true
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    }
  },
  setup(props) {
    if (!props.field) {
      return () => null;
    }
    return () => {
      return h(simplyResolveComponent(props.wrapper || defaultWrapper$2), {
        "data-oembed": props.field.embed_url,
        "data-oembed-type": props.field.type,
        "data-oembed-provider": props.field.provider_name,
        innerHTML: props.field.html || null
      });
    };
  }
});
var PrismicEmbed = PrismicEmbedImpl;
if (typeof process === "undefined") {
  globalThis.process = { env: {} };
}
var __PRODUCTION__ = false;
var prismicKey = Symbol("prismic");
var usePrismic = () => {
  return inject(prismicKey, { options: { endpoint: "" } });
};
var defaultImageComponent = "img";
var usePrismicImage = (props) => {
  const { options } = usePrismic();
  const asImage = computed(() => {
    var _a, _b;
    const field = unref(props.field);
    if (!isFilled.image(field)) {
      return {
        src: null,
        srcset: null
      };
    }
    const imgixParams = unref(props.imgixParams);
    const widths = unref(props.widths);
    const pixelDensities = unref(props.pixelDensities);
    if (widths) {
      if (!__PRODUCTION__ && pixelDensities) {
        console.warn(
          "[PrismicImage] Only one of `widths` or `pixelDensities` props can be provided. You can resolve this warning by removing either the `widths` or `pixelDensities` prop. `widths` will be used in this case.",
          props
        );
      }
      return asImageWidthSrcSet(field, {
        ...imgixParams,
        widths: widths === "defaults" ? (_a = options.components) == null ? void 0 : _a.imageWidthSrcSetDefaults : widths
      });
    } else if (pixelDensities) {
      return asImagePixelDensitySrcSet(field, {
        ...imgixParams,
        pixelDensities: pixelDensities === "defaults" ? (_b = options.components) == null ? void 0 : _b.imagePixelDensitySrcSetDefaults : pixelDensities
      });
    } else {
      return {
        src: asImageSrc(field, imgixParams),
        srcset: null
      };
    }
  });
  const src = computed(() => {
    return asImage.value.src;
  });
  const srcset = computed(() => {
    return asImage.value.srcset;
  });
  const alt = computed(() => {
    return unref(props.field).alt || "";
  });
  const copyright = computed(() => {
    return unref(props.field).copyright || null;
  });
  return {
    src,
    srcset,
    alt,
    copyright
  };
};
var PrismicImageImpl = defineComponent({
  name: "PrismicImage",
  props: {
    field: {
      type: Object,
      required: true
    },
    imageComponent: {
      type: [String, Object],
      default: void 0,
      required: false
    },
    imgixParams: {
      type: Object,
      default: void 0,
      required: false
    },
    widths: {
      type: [String, Object],
      default: void 0,
      required: false
    },
    pixelDensities: {
      type: [String, Object],
      default: void 0,
      required: false
    }
  },
  setup(props) {
    if (!props.field) {
      return () => null;
    }
    const { options } = usePrismic();
    const type = computed(() => {
      var _a;
      return props.imageComponent || ((_a = options.components) == null ? void 0 : _a.imageComponent) || defaultImageComponent;
    });
    const { src, srcset, alt, copyright } = usePrismicImage(props);
    return () => {
      const attributes = {
        src: src.value,
        srcset: srcset.value,
        alt: alt.value
      };
      switch (type.value) {
        case "img":
          return h("img", attributes);
        default:
          return h(simplyResolveComponent(type.value), {
            ...attributes,
            copyright: copyright.value
          });
      }
    };
  }
});
var PrismicImage = PrismicImageImpl;
var isInternalURL = (url) => {
  const isInternal = /^\/(?!\/)/.test(url);
  const isSpecialLink = !isInternal && !/^https?:\/\//i.test(url);
  return isInternal && !isSpecialLink;
};
var getSlots = (parent, slots, defaultPayload) => {
  if (typeof parent === "string") {
    return slots.default && slots.default(defaultPayload);
  } else {
    if (slots.default) {
      const content = slots.default(defaultPayload);
      return {
        ...slots,
        default: () => content
      };
    } else {
      return slots;
    }
  }
};
var defaultInternalComponent = "router-link";
var defaultExternalComponent = "a";
var defaultBlankTargetRelAttribute = "noopener noreferrer";
var usePrismicLink = (props) => {
  const { options } = usePrismic();
  const type = computed(() => {
    var _a, _b;
    const internalComponent = unref(props.internalComponent) || ((_a = options.components) == null ? void 0 : _a.linkInternalComponent) || defaultInternalComponent;
    const externalComponent = unref(props.externalComponent) || ((_b = options.components) == null ? void 0 : _b.linkExternalComponent) || defaultExternalComponent;
    return href.value && isInternalURL(href.value) && !target.value ? internalComponent : externalComponent;
  });
  const href = computed(() => {
    var _a, _b;
    const field = unref(props.field);
    const linkResolver = (_a = unref(props.linkResolver)) != null ? _a : options.linkResolver;
    return (_b = asLink(field, linkResolver)) != null ? _b : "";
  });
  const target = computed(() => {
    const field = unref(props.field);
    const target2 = unref(props.target);
    if (typeof target2 !== "undefined") {
      return target2;
    } else {
      return field && "target" in field && field.target ? field.target : null;
    }
  });
  const rel = computed(() => {
    var _a;
    const rel2 = unref(props.rel);
    if (typeof rel2 !== "undefined") {
      return rel2;
    } else if (target.value === "_blank") {
      const blankTargetRelAttribute = unref(props.blankTargetRelAttribute);
      if (typeof blankTargetRelAttribute !== "undefined") {
        return blankTargetRelAttribute;
      } else {
        return typeof ((_a = options.components) == null ? void 0 : _a.linkBlankTargetRelAttribute) !== "undefined" ? options.components.linkBlankTargetRelAttribute : defaultBlankTargetRelAttribute;
      }
    } else {
      return null;
    }
  });
  return {
    type,
    href,
    target,
    rel
  };
};
var PrismicLinkImpl = defineComponent({
  name: "PrismicLink",
  props: {
    field: {
      type: Object,
      required: true
    },
    linkResolver: {
      type: Function,
      default: void 0,
      required: false
    },
    target: {
      type: String,
      default: void 0,
      required: false
    },
    rel: {
      type: String,
      default: void 0,
      required: false
    },
    blankTargetRelAttribute: {
      type: String,
      default: void 0,
      required: false
    },
    internalComponent: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    },
    externalComponent: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    }
  },
  setup(props, { slots }) {
    if (!props.field) {
      return () => null;
    }
    const { type, href, target, rel } = usePrismicLink(props);
    return () => {
      const parent = type.value === "a" ? "a" : simplyResolveComponent(type.value);
      const computedSlots = getSlots(
        parent,
        slots,
        reactive({ href: href.value })
      );
      if (typeof parent === "string") {
        return h(
          parent,
          { href: href.value, target: target.value, rel: rel.value },
          computedSlots
        );
      } else {
        return h(parent, { to: href.value }, computedSlots);
      }
    };
  }
});
var PrismicLink = PrismicLinkImpl;
var defaultWrapper$1 = "div";
var usePrismicText = (props) => {
  const text = computed(() => {
    var _a;
    const field = unref(props.field);
    if (!isFilled.richText(field)) {
      return (_a = unref(props.fallback)) != null ? _a : "";
    }
    return asText2(unref(field), unref(props.separator));
  });
  return {
    text
  };
};
var PrismicTextImpl = defineComponent({
  name: "PrismicText",
  props: {
    field: {
      type: Array,
      default: void 0,
      required: false
    },
    separator: {
      type: String,
      default: void 0,
      required: false
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    },
    fallback: {
      type: String,
      default: void 0,
      required: false
    }
  },
  setup(props) {
    const { text } = usePrismicText(props);
    return () => {
      const parent = simplyResolveComponent(props.wrapper || defaultWrapper$1);
      return h(parent, null, {
        default: () => text.value
      });
    };
  }
});
var PrismicText = PrismicTextImpl;
var defaultWrapper = "div";
var usePrismicRichText = (props) => {
  const { options } = usePrismic();
  const html = computed(() => {
    var _a, _b, _c;
    const field = unref(props.field);
    if (!isFilled.richText(field)) {
      return (_a = unref(props.fallback)) != null ? _a : "";
    }
    const linkResolver = (_b = unref(props.linkResolver)) != null ? _b : options.linkResolver;
    const htmlSerializer = (_c = unref(props.htmlSerializer)) != null ? _c : options.htmlSerializer;
    return asHTML(unref(field), linkResolver, htmlSerializer);
  });
  return {
    html
  };
};
var PrismicRichTextImpl = defineComponent({
  name: "PrismicRichText",
  props: {
    field: {
      type: Array,
      default: void 0,
      required: false
    },
    linkResolver: {
      type: Function,
      default: void 0,
      required: false
    },
    htmlSerializer: {
      type: [Function, Object],
      default: void 0,
      required: false
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    },
    fallback: {
      type: String,
      default: void 0,
      required: false
    }
  },
  setup(props) {
    const { html } = usePrismicRichText(props);
    const root = ref(null);
    const maybeRouter = inject(routerKey, null);
    if (maybeRouter) {
      let links = [];
      const navigate = function(event) {
        event.preventDefault();
        maybeRouter.push(this.href);
      };
      const addListeners = () => {
        const node = root.value && "$el" in root.value ? root.value.$el : root.value;
        if (node && "querySelectorAll" in node) {
          links = Array.from(node.querySelectorAll("a")).map((element) => {
            const href = element.getAttribute("href");
            if (href && isInternalURL(href)) {
              const listener = navigate.bind({ href });
              element.addEventListener("click", listener);
              return { element, listener };
            } else {
              return false;
            }
          }).filter((link2) => link2);
        }
      };
      const removeListeners = () => {
        links.forEach(
          ({ element, listener }) => element.removeEventListener("click", listener)
        );
        links = [];
      };
      watch(
        html,
        () => {
          removeListeners();
          nextTick(addListeners);
        },
        { immediate: true }
      );
      onBeforeUnmount(() => {
        removeListeners();
      });
    }
    return () => {
      return h(simplyResolveComponent(props.wrapper || defaultWrapper), {
        innerHTML: html.value,
        ref: root
      });
    };
  }
});
var PrismicRichText = PrismicRichTextImpl;
var getSliceComponentProps = (propsHint) => ({
  slice: {
    type: Object,
    required: true
  },
  index: {
    type: Number,
    required: true
  },
  slices: {
    type: Array,
    required: true
  },
  context: {
    type: null,
    required: true
  }
});
var TODOSliceComponent = __PRODUCTION__ ? () => null : defineComponent({
  name: "TODOSliceComponent",
  props: getSliceComponentProps(),
  setup(props) {
    const type = computed(
      () => "slice_type" in props.slice ? props.slice.slice_type : props.slice.type
    );
    watchEffect(() => {
      console.warn(
        `[SliceZone] Could not find a component for Slice type "${type.value}"`,
        props.slice
      );
    });
    return () => {
      return h(
        "section",
        {
          "data-slice-zone-todo-component": "",
          "data-slice-type": type.value
        },
        [`Could not find a component for Slice type "${type.value}"`]
      );
    };
  }
});
var defineSliceZoneComponents = (components) => {
  const result = {};
  let type;
  for (type in components) {
    const component = components[type];
    result[type] = typeof component === "string" ? component : markRaw(
      component
    );
  }
  return result;
};
var SliceZoneImpl = defineComponent({
  name: "SliceZone",
  props: {
    slices: {
      type: Array,
      required: true
    },
    components: {
      type: Object,
      default: void 0,
      required: false
    },
    resolver: {
      type: Function,
      default: void 0,
      required: false
    },
    context: {
      type: null,
      default: void 0,
      required: false
    },
    defaultComponent: {
      type: Object,
      default: void 0,
      required: false
    },
    wrapper: {
      type: [String, Object, Function],
      default: void 0,
      required: false
    }
  },
  setup(props) {
    if (!props.slices) {
      return () => null;
    }
    const { options } = usePrismic();
    const renderedSlices = computed(() => {
      return props.slices.map((slice, index) => {
        var _a;
        const type = "slice_type" in slice ? slice.slice_type : slice.type;
        let component = props.components && type in props.components ? props.components[type] : props.defaultComponent || ((_a = options.components) == null ? void 0 : _a.sliceZoneDefaultComponent) || TODOSliceComponent;
        if (props.resolver) {
          const resolvedComponent = props.resolver({
            slice,
            sliceName: type,
            i: index
          });
          if (resolvedComponent) {
            component = resolvedComponent;
          }
        }
        const key = "id" in slice && slice.id ? slice.id : `${index}-${JSON.stringify(slice)}`;
        const p = {
          key,
          slice,
          index,
          context: props.context,
          slices: props.slices
        };
        return h(simplyResolveComponent(component), p);
      });
    });
    return () => {
      if (props.wrapper) {
        const parent = simplyResolveComponent(props.wrapper);
        if (typeof parent === "string") {
          return h(parent, null, renderedSlices.value);
        } else {
          return h(parent, null, { default: () => renderedSlices.value });
        }
      } else {
        return renderedSlices.value;
      }
    };
  }
});
var SliceZone = SliceZoneImpl;
var createPrismic = (options) => {
  let client;
  if (options.client) {
    client = options.client;
  } else {
    client = createClient(options.endpoint, {
      fetch: async (endpoint, options2) => {
        let fetchFunction;
        if (typeof globalThis.fetch === "function") {
          fetchFunction = globalThis.fetch;
        } else {
          fetchFunction = (await import("./browser-UJD4JMLZ.js")).default;
        }
        return await fetchFunction(endpoint, options2);
      },
      ...options.clientConfig
    });
  }
  const prismicClient = {
    client,
    predicate,
    cookie
  };
  const prismicHelpers = {
    asText: asText2,
    asHTML: (richTextField, linkResolver, htmlSerializer) => {
      return asHTML(
        richTextField,
        linkResolver || options.linkResolver,
        htmlSerializer || options.htmlSerializer
      );
    },
    asLink: (linkField, linkResolver) => {
      return asLink(linkField, linkResolver || options.linkResolver);
    },
    asDate,
    asImageSrc,
    asImageWidthSrcSet,
    asImagePixelDensitySrcSet,
    documentToLinkField
  };
  const prismic = {
    options,
    ...prismicClient,
    ...prismicHelpers,
    install(app) {
      app.provide(prismicKey, this);
      app.config.globalProperties.$prismic = this;
      if (options.injectComponents !== false) {
        app.component(PrismicLink.name, PrismicLink);
        app.component(PrismicEmbed.name, PrismicEmbed);
        app.component(PrismicImage.name, PrismicImage);
        app.component(PrismicText.name, PrismicText);
        app.component(PrismicRichText.name, PrismicRichText);
        app.component(SliceZone.name, SliceZone);
      }
    }
  };
  return prismic;
};
var PrismicClientComposableState = ((PrismicClientComposableState2) => {
  PrismicClientComposableState2["Idle"] = "idle";
  PrismicClientComposableState2["Pending"] = "pending";
  PrismicClientComposableState2["Success"] = "success";
  PrismicClientComposableState2["Error"] = "error";
  return PrismicClientComposableState2;
})(PrismicClientComposableState || {});
var isParams = (value) => {
  return typeof value === "object" && value !== null && !Array.isArray(value);
};
var useStatefulPrismicClientMethod = (methodName, args) => {
  const { client } = usePrismic();
  const state = ref(
    PrismicClientComposableState.Idle
  );
  const data = shallowRef(null);
  const error = ref(null);
  const refresh = async () => {
    const lastArg = unref(args[args.length - 1]);
    const { client: explicitClient, ...params } = isParams(lastArg) ? lastArg : {};
    const argsWithoutParams = isParams(lastArg) ? args.slice(0, -1) : args;
    state.value = PrismicClientComposableState.Pending;
    data.value = null;
    error.value = null;
    try {
      data.value = await (unref(explicitClient) || client)[methodName](
        ...argsWithoutParams.map((arg) => unref(arg)),
        params
      );
      state.value = PrismicClientComposableState.Success;
    } catch (err) {
      state.value = PrismicClientComposableState.Error;
      error.value = err;
    }
  };
  const refArgs = args.filter((arg) => isRef(arg));
  if (refArgs.length) {
    watch(refArgs, refresh, { deep: true });
  }
  refresh();
  return { state, data, error, refresh };
};
var usePrismicDocuments = (...args) => useStatefulPrismicClientMethod("get", args);
var useFirstPrismicDocument = (...args) => useStatefulPrismicClientMethod("getFirst", args);
var usePrismicDocumentByID = (...args) => useStatefulPrismicClientMethod("getByID", args);
var usePrismicDocumentsByIDs = (...args) => useStatefulPrismicClientMethod("getByIDs", args);
var useAllPrismicDocumentsByIDs = (...args) => useStatefulPrismicClientMethod("getAllByIDs", args);
var usePrismicDocumentByUID = (...args) => useStatefulPrismicClientMethod("getByUID", args);
var usePrismicDocumentsByUIDs = (...args) => useStatefulPrismicClientMethod("getByUIDs", args);
var useAllPrismicDocumentsByUIDs = (...args) => useStatefulPrismicClientMethod("getAllByUIDs", args);
var useSinglePrismicDocument = (...args) => useStatefulPrismicClientMethod("getSingle", args);
var usePrismicDocumentsByType = (...args) => useStatefulPrismicClientMethod("getByType", args);
var useAllPrismicDocumentsByType = (...args) => useStatefulPrismicClientMethod("getAllByType", args);
var usePrismicDocumentsByTag = (...args) => useStatefulPrismicClientMethod("getByTag", args);
var useAllPrismicDocumentsByTag = (...args) => useStatefulPrismicClientMethod("getAllByTag", args);
var usePrismicDocumentsByEveryTag = (...args) => useStatefulPrismicClientMethod("getByEveryTag", args);
var useAllPrismicDocumentsByEveryTag = (...args) => useStatefulPrismicClientMethod("getAllByEveryTag", args);
var usePrismicDocumentsBySomeTags = (...args) => useStatefulPrismicClientMethod("getBySomeTags", args);
var useAllPrismicDocumentsBySomeTags = (...args) => useStatefulPrismicClientMethod("getAllBySomeTags", args);
var dangerouslyUseAllPrismicDocuments = (...args) => useStatefulPrismicClientMethod("dangerouslyGetAll", args);
export {
  PrismicClientComposableState,
  PrismicEmbed,
  PrismicImage,
  PrismicLink,
  PrismicRichText,
  PrismicText,
  SliceZone,
  TODOSliceComponent,
  createPrismic,
  dangerouslyUseAllPrismicDocuments,
  defineSliceZoneComponents,
  getSliceComponentProps,
  prismicKey,
  useAllPrismicDocumentsByEveryTag,
  useAllPrismicDocumentsByIDs,
  useAllPrismicDocumentsBySomeTags,
  useAllPrismicDocumentsByTag,
  useAllPrismicDocumentsByType,
  useAllPrismicDocumentsByUIDs,
  useFirstPrismicDocument,
  usePrismic,
  usePrismicDocumentByID,
  usePrismicDocumentByUID,
  usePrismicDocuments,
  usePrismicDocumentsByEveryTag,
  usePrismicDocumentsByIDs,
  usePrismicDocumentsBySomeTags,
  usePrismicDocumentsByTag,
  usePrismicDocumentsByType,
  usePrismicDocumentsByUIDs,
  usePrismicImage,
  usePrismicLink,
  usePrismicRichText,
  usePrismicText,
  useSinglePrismicDocument
};
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
//# sourceMappingURL=@prismicio_vue.js.map
